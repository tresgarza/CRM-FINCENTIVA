{"ast":null,"code":"import{TABLES}from'../utils/constants/tables';import{APPLICATION_STATUS}from'../utils/constants/statuses';import{executeQuery}from'../utils/databaseUtils';// Verify if APPLICATION_HISTORY table is defined in TABLES\nlet APPLICATION_HISTORY_TABLE=TABLES.APPLICATION_HISTORY;if(!APPLICATION_HISTORY_TABLE){// If not defined, create a fallback\nAPPLICATION_HISTORY_TABLE='application_history';}// Define the type of application statuses\n// Define application interface\n// Get all applications with filters\nexport const getApplications=async(filters,entityFilter)=>{let query=`SELECT * FROM ${TABLES.APPLICATIONS} WHERE 1=1`;// Aplicar filtro por entidad (asesor o empresa)\nif(entityFilter){if(entityFilter.advisor_id){query+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){query+=` AND company_id = '${entityFilter.company_id}'`;}}// Aplicar otros filtros\nif(filters){// Filter by status\nif(filters.status&&filters.status!=='all'){query+=` AND status = '${filters.status}'`;}// Filter by application type\nif(filters.application_type&&filters.application_type!=='all'){query+=` AND application_type = '${filters.application_type}'`;}// Filter by advisor\nif(filters.advisor_id){query+=` AND assigned_to = '${filters.advisor_id}'`;}// Filter by company\nif(filters.company_id){query+=` AND company_id = '${filters.company_id}'`;}// Filter by date range\nif(filters.dateFrom){query+=` AND created_at >= '${filters.dateFrom}'`;}if(filters.dateTo){query+=` AND created_at <= '${filters.dateTo}'`;}// Filter by amount range\nif(filters.amountMin!==undefined){query+=` AND amount >= ${filters.amountMin}`;}if(filters.amountMax!==undefined){query+=` AND amount <= ${filters.amountMax}`;}// Search by name, email or phone (ajustado a los campos reales)\nif(filters.searchQuery){query+=` AND (\n        client_name ILIKE '%${filters.searchQuery}%' OR \n        client_email ILIKE '%${filters.searchQuery}%'\n      )`;}}// Ordenar por fecha de creación más reciente\nquery+=` ORDER BY created_at DESC`;try{const data=await executeQuery(query);// Mapear los campos de la BD a nuestra interfaz\nreturn data.map(app=>({id:app.id,client_id:app.source_id||\"\",company_id:app.company_id||\"\",assigned_to:app.assigned_to||\"\",application_type:app.application_type||\"\",requested_amount:parseFloat(app.amount)||0,status:mapStatusFromDB(app.status),created_at:app.created_at,updated_at:app.updated_at,client_name:app.client_name,client_email:app.client_email,company_name:app.company_name,advisor_name:\"\",// Este campo no está en la BD\napproved_by_advisor:app.approved_by_advisor||false,approved_by_company:app.approved_by_company||false,approval_date_advisor:app.approval_date_advisor,approval_date_company:app.approval_date_company,// Mapeo directo de campos adicionales de la BD\nclient_phone:app.client_phone,client_address:app.client_address,dni:app.dni,amount:parseFloat(app.amount)||0,term:app.term?parseInt(app.term):undefined,interest_rate:app.interest_rate?parseFloat(app.interest_rate):undefined,monthly_payment:app.monthly_payment?parseFloat(app.monthly_payment):undefined}));}catch(error){console.error('Error fetching applications:',error);throw error;}};// Función auxiliar para mapear estados de la BD a nuestro enum\nconst mapStatusFromDB=dbStatus=>{// Si el estado es undefined o null, devolver un valor por defecto\nif(dbStatus===undefined||dbStatus===null){console.log('Estado de BD es undefined o null, usando PENDING como valor por defecto');return APPLICATION_STATUS.PENDING;}// Primero verificamos si coincide con algún enum directamente\nconst directMapping=Object.values(APPLICATION_STATUS).find(status=>status.toLowerCase()===dbStatus.toLowerCase());if(directMapping){return directMapping;}// Si no hay coincidencia directa, usamos un mapeo manual\nconst statusMap={'Solicitud':APPLICATION_STATUS.SOLICITUD,'Pendiente':APPLICATION_STATUS.PENDING,'En Revisión':APPLICATION_STATUS.IN_REVIEW,'Revisión':APPLICATION_STATUS.IN_REVIEW,'Aprobado':APPLICATION_STATUS.APPROVED,'Rechazado':APPLICATION_STATUS.REJECTED,'Por Dispersar':APPLICATION_STATUS.POR_DISPERSAR,'Completado':APPLICATION_STATUS.COMPLETED,'Cancelado':APPLICATION_STATUS.CANCELLED,'Expirado':APPLICATION_STATUS.EXPIRED};console.log(`Mapeando estado desde BD: \"${dbStatus}\" -> \"${statusMap[dbStatus]||APPLICATION_STATUS.PENDING}\"`);return statusMap[dbStatus]||APPLICATION_STATUS.PENDING;};// Get a single application by ID\nexport const getApplicationById=async(id,entityFilter)=>{let query=`SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;// Aplicar filtro por entidad si es necesario\nif(entityFilter){if(entityFilter.advisor_id){query+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){query+=` AND company_id = '${entityFilter.company_id}'`;}}try{const data=await executeQuery(query);if(data&&data.length>0){return data[0];}throw new Error('Application not found');}catch(error){console.error(`Error fetching application with ID ${id}:`,error);throw error;}};// Create a new application\nexport const createApplication=async application=>{const fields=Object.keys(application).join(', ');const values=Object.values(application).map(val=>typeof val==='string'?`'${val}'`:val).join(', ');const query=`\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;try{const data=await executeQuery(query);return data[0];}catch(error){console.error('Error creating application:',error);throw error;}};// Update an existing application\nexport const updateApplication=async(id,updates,entityFilter)=>{const setClause=Object.entries(updates).map(_ref=>{let[key,value]=_ref;return`${key} = ${typeof value==='string'?`'${value}'`:value}`;}).join(', ');let query=`\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;// Aplicar filtro por entidad si es necesario\nif(entityFilter){if(entityFilter.advisor_id){query+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){query+=` AND company_id = '${entityFilter.company_id}'`;}}query+=' RETURNING *';try{const data=await executeQuery(query);if(data&&data.length>0){return data[0];}throw new Error('Application not found or you do not have permission to update it');}catch(error){console.error(`Error updating application with ID ${id}:`,error);throw error;}};// Update application status and add to history\nexport const updateApplicationStatus=async(id,status,comment,user_id,entityFilter)=>{// 1. Obtener estado actual de la aplicación\nlet currentQuery=`\n    SELECT status FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;// Aplicar filtro por entidad si es necesario\nif(entityFilter){if(entityFilter.advisor_id){currentQuery+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){currentQuery+=` AND company_id = '${entityFilter.company_id}'`;}}try{// Obtener el estado actual\nconst currentState=await executeQuery(currentQuery);if(!currentState||currentState.length===0){throw new Error('Application not found or you do not have permission to update it');}const currentStatus=currentState[0].status;// 2. Actualizar el estado de la aplicación\nlet updateQuery=`\n      UPDATE ${TABLES.APPLICATIONS}\n      SET status = '${status}',\n          status_previous = '${currentStatus}'\n    `;// Si el nuevo estado es \"completed\", actualizar la fecha de dispersión\nif(status==='completed'){updateQuery+=`, dispersal_date = NOW()`;}updateQuery+=` WHERE id = '${id}'`;// Aplicar filtro por entidad si es necesario\nif(entityFilter){if(entityFilter.advisor_id){updateQuery+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){updateQuery+=` AND company_id = '${entityFilter.company_id}'`;}}updateQuery+=' RETURNING *';// Ejecutar la actualización\nconst updatedApp=await executeQuery(updateQuery);if(!updatedApp||updatedApp.length===0){throw new Error('Application not found or you do not have permission to update it');}// 3. Añadir al historial\nconst historyComment=currentStatus!==status?`${comment} (Cambio de estado: ${currentStatus} → ${status})`:comment;const historyQuery=`\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', '${status}', '${historyComment}', '${user_id}')\n      RETURNING *\n    `;await executeQuery(historyQuery);console.log(`Estado de aplicación actualizado: ${currentStatus} → ${status}`);return updatedApp[0];}catch(error){console.error(`Error updating status of application ${id}:`,error);throw error;}};// Aprobar solicitud por asesor\nexport const approveByAdvisor=async(id,comment,advisor_id,entityFilter)=>{// Verificar que el usuario es realmente un asesor\nif(!(entityFilter!==null&&entityFilter!==void 0&&entityFilter.advisor_id)){throw new Error('Solo los asesores pueden realizar esta acción');}// Actualizar la solicitud\nlet updateQuery=`\n    UPDATE ${TABLES.APPLICATIONS}\n    SET approved_by_advisor = true, \n        approval_date_advisor = NOW()\n    WHERE id = '${id}' AND assigned_to = '${advisor_id}'\n    RETURNING *\n  `;try{// Ejecutar la actualización\nconst updatedApp=await executeQuery(updateQuery);if(!updatedApp||updatedApp.length===0){throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');}// Añadir al historial\nconst historyQuery=`\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', 'approved_by_advisor', '${comment}', '${advisor_id}')\n      RETURNING *\n    `;await executeQuery(historyQuery);// Verificar si ambas aprobaciones están completas, para actualizar el estado principal\nconst app=updatedApp[0];if(app.approved_by_advisor&&app.approved_by_company&&app.status!=='approved'){console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");// Si ambos han aprobado, actualizar el estado a aprobado\nreturn await updateApplicationStatus(id,'approved','Aprobación completa: Asesor y Empresa han aprobado esta solicitud',advisor_id,entityFilter);}return app;}catch(error){console.error(`Error aprobando solicitud ${id} por asesor:`,error);throw error;}};// Aprobar solicitud por empresa\nexport const approveByCompany=async(id,comment,company_admin_id,company_id,entityFilter)=>{// Verificar que el usuario es realmente un administrador de la empresa correcta\nif(!(entityFilter!==null&&entityFilter!==void 0&&entityFilter.company_id)||entityFilter.company_id!==company_id){throw new Error('Solo los administradores de la empresa pueden realizar esta acción');}// Actualizar la solicitud\nlet updateQuery=`\n    UPDATE ${TABLES.APPLICATIONS}\n    SET approved_by_company = true, \n        approval_date_company = NOW()\n    WHERE id = '${id}' AND company_id = '${company_id}'\n    RETURNING *\n  `;try{// Ejecutar la actualización\nconst updatedApp=await executeQuery(updateQuery);if(!updatedApp||updatedApp.length===0){throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');}// Añadir al historial\nconst historyQuery=`\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', 'approved_by_company', '${comment}', '${company_admin_id}')\n      RETURNING *\n    `;await executeQuery(historyQuery);// Verificar si ambas aprobaciones están completas, para actualizar el estado principal\nconst app=updatedApp[0];if(app.approved_by_advisor&&app.approved_by_company&&app.status!=='approved'){console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");// Si ambos han aprobado, actualizar el estado a aprobado\nreturn await updateApplicationStatus(id,'approved','Aprobación completa: Asesor y Empresa han aprobado esta solicitud',company_admin_id,entityFilter);}return app;}catch(error){console.error(`Error aprobando solicitud ${id} por empresa:`,error);throw error;}};// Obtener estado de aprobación de una solicitud\nexport const getApprovalStatus=async(id,entityFilter)=>{let query=`\n    SELECT \n      approved_by_advisor, \n      approved_by_company, \n      approval_date_advisor, \n      approval_date_company\n    FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;// Aplicar filtro por entidad si es necesario\nif(entityFilter){if(entityFilter.advisor_id){query+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){query+=` AND company_id = '${entityFilter.company_id}'`;}}try{const data=await executeQuery(query);if(data&&data.length>0){return{approvedByAdvisor:data[0].approved_by_advisor||false,approvedByCompany:data[0].approved_by_company||false,approvalDateAdvisor:data[0].approval_date_advisor,approvalDateCompany:data[0].approval_date_company};}throw new Error('Solicitud no encontrada');}catch(error){console.error(`Error obteniendo estado de aprobación para solicitud ${id}:`,error);throw error;}};// Delete an application\nexport const deleteApplication=async(id,entityFilter)=>{let query=`DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;// Aplicar filtro por entidad si es necesario\nif(entityFilter){if(entityFilter.advisor_id){query+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){query+=` AND company_id = '${entityFilter.company_id}'`;}}try{await executeQuery(query);return true;}catch(error){console.error(`Error deleting application with ID ${id}:`,error);throw error;}};// Get application history\nexport const getApplicationHistory=async(applicationId,entityFilter)=>{// Verificar primero si el usuario tiene permiso para ver esta aplicación\nif(entityFilter){let appQuery=`\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;if(entityFilter.advisor_id){appQuery+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){appQuery+=` AND company_id = '${entityFilter.company_id}'`;}const app=await executeQuery(appQuery);if(!app||app.length===0){throw new Error('Application not found or you do not have permission to view it');}}const query=`\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${APPLICATION_HISTORY_TABLE} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;try{return await executeQuery(query);}catch(error){console.error(`Error fetching history for application ${applicationId}:`,error);throw error;}};// Add a comment to an application\nexport const addComment=async(applicationId,userId,text,entityFilter)=>{// Verificar primero si el usuario tiene permiso para comentar esta aplicación\nif(entityFilter){let appQuery=`\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;if(entityFilter.advisor_id){appQuery+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){appQuery+=` AND company_id = '${entityFilter.company_id}'`;}const app=await executeQuery(appQuery);if(!app||app.length===0){throw new Error('Application not found or you do not have permission to comment on it');}}const query=`\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;try{const data=await executeQuery(query);return data[0];}catch(error){console.error(`Error adding comment to application ${applicationId}:`,error);throw error;}};// Get comments for an application\nexport const getComments=async(applicationId,entityFilter)=>{// Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\nif(entityFilter){let appQuery=`\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;if(entityFilter.advisor_id){appQuery+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){appQuery+=` AND company_id = '${entityFilter.company_id}'`;}const app=await executeQuery(appQuery);if(!app||app.length===0){throw new Error('Application not found or you do not have permission to view its comments');}}const query=`\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;try{return await executeQuery(query);}catch(error){console.error(`Error fetching comments for application ${applicationId}:`,error);throw error;}};","map":{"version":3,"names":["TABLES","APPLICATION_STATUS","executeQuery","APPLICATION_HISTORY_TABLE","APPLICATION_HISTORY","getApplications","filters","entityFilter","query","APPLICATIONS","advisor_id","company_id","status","application_type","dateFrom","dateTo","amountMin","undefined","amountMax","searchQuery","data","map","app","id","client_id","source_id","assigned_to","requested_amount","parseFloat","amount","mapStatusFromDB","created_at","updated_at","client_name","client_email","company_name","advisor_name","approved_by_advisor","approved_by_company","approval_date_advisor","approval_date_company","client_phone","client_address","dni","term","parseInt","interest_rate","monthly_payment","error","console","dbStatus","log","PENDING","directMapping","Object","values","find","toLowerCase","statusMap","SOLICITUD","IN_REVIEW","APPROVED","REJECTED","POR_DISPERSAR","COMPLETED","CANCELLED","EXPIRED","getApplicationById","length","Error","createApplication","application","fields","keys","join","val","updateApplication","updates","setClause","entries","_ref","key","value","updateApplicationStatus","comment","user_id","currentQuery","currentState","currentStatus","updateQuery","updatedApp","historyComment","historyQuery","approveByAdvisor","approveByCompany","company_admin_id","getApprovalStatus","approvedByAdvisor","approvedByCompany","approvalDateAdvisor","approvalDateCompany","deleteApplication","getApplicationHistory","applicationId","appQuery","addComment","userId","text","COMMENTS","getComments"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/applicationService.ts"],"sourcesContent":["import { TABLES } from '../utils/constants/tables';\nimport { APPLICATION_STATUS } from '../utils/constants/statuses';\nimport { executeQuery } from '../utils/databaseUtils';\n\n// Verify if APPLICATION_HISTORY table is defined in TABLES\nlet APPLICATION_HISTORY_TABLE = TABLES.APPLICATION_HISTORY;\nif (!APPLICATION_HISTORY_TABLE) {\n  // If not defined, create a fallback\n  APPLICATION_HISTORY_TABLE = 'application_history';\n}\n\n// Define the type of application statuses\nexport type ApplicationStatus = 'pending' | 'in_review' | 'approved' | 'rejected' | 'cancelled' | 'expired' | 'completed' | 'solicitud' | 'new' | 'por_dispersar';\n\n// Define application interface\nexport interface Application {\n  id: string;\n  client_id: string;\n  company_id: string;\n  assigned_to: string;\n  application_type: string;\n  requested_amount: number;\n  status: ApplicationStatus;\n  status_previous?: string;\n  created_at: string;\n  updated_at: string;\n  client_name?: string;\n  client_email?: string;\n  client_phone?: string;\n  client_address?: string;\n  company_name?: string;\n  advisor_name?: string;\n  approved_by_advisor: boolean;\n  approved_by_company: boolean;\n  approval_date_advisor?: string;\n  approval_date_company?: string;\n  dispersal_date?: string;\n  dni?: string;\n  \n  // Campos adicionales que necesitan los formularios\n  amount?: number;\n  term?: number;\n  interest_rate?: number;\n  monthly_payment?: number;\n}\n\nexport interface ApplicationFilter {\n  status?: string;\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n  application_type?: string;\n  amountMin?: number;\n  amountMax?: number;\n}\n\n// Get all applications with filters\nexport const getApplications = async (filters?: ApplicationFilter, entityFilter?: Record<string, any> | null) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE 1=1`;\n  \n  // Aplicar filtro por entidad (asesor o empresa)\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n\n  // Aplicar otros filtros\n  if (filters) {\n    // Filter by status\n    if (filters.status && filters.status !== 'all') {\n      query += ` AND status = '${filters.status}'`;\n    }\n\n    // Filter by application type\n    if (filters.application_type && filters.application_type !== 'all') {\n      query += ` AND application_type = '${filters.application_type}'`;\n    }\n\n    // Filter by advisor\n    if (filters.advisor_id) {\n      query += ` AND assigned_to = '${filters.advisor_id}'`;\n    }\n\n    // Filter by company\n    if (filters.company_id) {\n      query += ` AND company_id = '${filters.company_id}'`;\n    }\n\n    // Filter by date range\n    if (filters.dateFrom) {\n      query += ` AND created_at >= '${filters.dateFrom}'`;\n    }\n\n    if (filters.dateTo) {\n      query += ` AND created_at <= '${filters.dateTo}'`;\n    }\n\n    // Filter by amount range\n    if (filters.amountMin !== undefined) {\n      query += ` AND amount >= ${filters.amountMin}`;\n    }\n\n    if (filters.amountMax !== undefined) {\n      query += ` AND amount <= ${filters.amountMax}`;\n    }\n\n    // Search by name, email or phone (ajustado a los campos reales)\n    if (filters.searchQuery) {\n      query += ` AND (\n        client_name ILIKE '%${filters.searchQuery}%' OR \n        client_email ILIKE '%${filters.searchQuery}%'\n      )`;\n    }\n  }\n\n  // Ordenar por fecha de creación más reciente\n  query += ` ORDER BY created_at DESC`;\n\n  try {\n    const data = await executeQuery(query);\n    \n    // Mapear los campos de la BD a nuestra interfaz\n    return data.map((app: any) => ({\n      id: app.id,\n      client_id: app.source_id || \"\",\n      company_id: app.company_id || \"\",\n      assigned_to: app.assigned_to || \"\",\n      application_type: app.application_type || \"\",\n      requested_amount: parseFloat(app.amount) || 0,\n      status: mapStatusFromDB(app.status),\n      created_at: app.created_at,\n      updated_at: app.updated_at,\n      client_name: app.client_name,\n      client_email: app.client_email,\n      company_name: app.company_name,\n      advisor_name: \"\", // Este campo no está en la BD\n      approved_by_advisor: app.approved_by_advisor || false,\n      approved_by_company: app.approved_by_company || false,\n      approval_date_advisor: app.approval_date_advisor,\n      approval_date_company: app.approval_date_company,\n      \n      // Mapeo directo de campos adicionales de la BD\n      client_phone: app.client_phone,\n      client_address: app.client_address,\n      dni: app.dni,\n      amount: parseFloat(app.amount) || 0,\n      term: app.term ? parseInt(app.term) : undefined,\n      interest_rate: app.interest_rate ? parseFloat(app.interest_rate) : undefined,\n      monthly_payment: app.monthly_payment ? parseFloat(app.monthly_payment) : undefined,\n    })) as Application[];\n  } catch (error) {\n    console.error('Error fetching applications:', error);\n    throw error;\n  }\n};\n\n// Función auxiliar para mapear estados de la BD a nuestro enum\nconst mapStatusFromDB = (dbStatus: string | undefined | null): ApplicationStatus => {\n  // Si el estado es undefined o null, devolver un valor por defecto\n  if (dbStatus === undefined || dbStatus === null) {\n    console.log('Estado de BD es undefined o null, usando PENDING como valor por defecto');\n    return APPLICATION_STATUS.PENDING;\n  }\n  \n  // Primero verificamos si coincide con algún enum directamente\n  const directMapping = Object.values(APPLICATION_STATUS).find(status => \n    status.toLowerCase() === dbStatus.toLowerCase()\n  );\n  \n  if (directMapping) {\n    return directMapping as ApplicationStatus;\n  }\n  \n  // Si no hay coincidencia directa, usamos un mapeo manual\n  const statusMap: Record<string, ApplicationStatus> = {\n    'Solicitud': APPLICATION_STATUS.SOLICITUD,\n    'Pendiente': APPLICATION_STATUS.PENDING,\n    'En Revisión': APPLICATION_STATUS.IN_REVIEW,\n    'Revisión': APPLICATION_STATUS.IN_REVIEW,\n    'Aprobado': APPLICATION_STATUS.APPROVED,\n    'Rechazado': APPLICATION_STATUS.REJECTED,\n    'Por Dispersar': APPLICATION_STATUS.POR_DISPERSAR,\n    'Completado': APPLICATION_STATUS.COMPLETED,\n    'Cancelado': APPLICATION_STATUS.CANCELLED,\n    'Expirado': APPLICATION_STATUS.EXPIRED\n  };\n  \n  console.log(`Mapeando estado desde BD: \"${dbStatus}\" -> \"${statusMap[dbStatus] || APPLICATION_STATUS.PENDING}\"`);\n  return statusMap[dbStatus] || APPLICATION_STATUS.PENDING;\n};\n\n// Get a single application by ID\nexport const getApplicationById = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found');\n  } catch (error) {\n    console.error(`Error fetching application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Create a new application\nexport const createApplication = async (application: Omit<Application, 'id' | 'created_at' | 'updated_at'>) => {\n  const fields = Object.keys(application).join(', ');\n  const values = Object.values(application)\n    .map(val => (typeof val === 'string' ? `'${val}'` : val))\n    .join(', ');\n  \n  const query = `\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0] as Application;\n  } catch (error) {\n    console.error('Error creating application:', error);\n    throw error;\n  }\n};\n\n// Update an existing application\nexport const updateApplication = async (id: string, updates: Partial<Application>, entityFilter?: Record<string, any> | null) => {\n  const setClause = Object.entries(updates)\n    .map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`)\n    .join(', ');\n  \n  let query = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  query += ' RETURNING *';\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found or you do not have permission to update it');\n  } catch (error) {\n    console.error(`Error updating application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Update application status and add to history\nexport const updateApplicationStatus = async (\n  id: string, \n  status: Application['status'], \n  comment: string, \n  user_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // 1. Obtener estado actual de la aplicación\n  let currentQuery = `\n    SELECT status FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      currentQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      currentQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    // Obtener el estado actual\n    const currentState = await executeQuery(currentQuery);\n    if (!currentState || currentState.length === 0) {\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    const currentStatus = currentState[0].status;\n    \n    // 2. Actualizar el estado de la aplicación\n    let updateQuery = `\n      UPDATE ${TABLES.APPLICATIONS}\n      SET status = '${status}',\n          status_previous = '${currentStatus}'\n    `;\n    \n    // Si el nuevo estado es \"completed\", actualizar la fecha de dispersión\n    if (status === 'completed') {\n      updateQuery += `, dispersal_date = NOW()`;\n    }\n    \n    updateQuery += ` WHERE id = '${id}'`;\n    \n    // Aplicar filtro por entidad si es necesario\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        updateQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n      }\n      if (entityFilter.company_id) {\n        updateQuery += ` AND company_id = '${entityFilter.company_id}'`;\n      }\n    }\n    \n    updateQuery += ' RETURNING *';\n    \n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    // 3. Añadir al historial\n    const historyComment = currentStatus !== status \n      ? `${comment} (Cambio de estado: ${currentStatus} → ${status})`\n      : comment;\n      \n    const historyQuery = `\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', '${status}', '${historyComment}', '${user_id}')\n      RETURNING *\n    `;\n    \n    await executeQuery(historyQuery);\n    \n    console.log(`Estado de aplicación actualizado: ${currentStatus} → ${status}`);\n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`Error updating status of application ${id}:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por asesor\nexport const approveByAdvisor = async (\n  id: string,\n  comment: string,\n  advisor_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un asesor\n  if (!entityFilter?.advisor_id) {\n    throw new Error('Solo los asesores pueden realizar esta acción');\n  }\n  \n  // Actualizar la solicitud\n  let updateQuery = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET approved_by_advisor = true, \n        approval_date_advisor = NOW()\n    WHERE id = '${id}' AND assigned_to = '${advisor_id}'\n    RETURNING *\n  `;\n  \n  try {\n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    // Añadir al historial\n    const historyQuery = `\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', 'approved_by_advisor', '${comment}', '${advisor_id}')\n      RETURNING *\n    `;\n    \n    await executeQuery(historyQuery);\n    \n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0] as Application;\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'approved') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");\n      \n      // Si ambos han aprobado, actualizar el estado a aprobado\n      return await updateApplicationStatus(\n        id, \n        'approved', \n        'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', \n        advisor_id,\n        entityFilter\n      );\n    }\n    \n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por empresa\nexport const approveByCompany = async (\n  id: string,\n  comment: string,\n  company_admin_id: string,\n  company_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!entityFilter?.company_id || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  \n  // Actualizar la solicitud\n  let updateQuery = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET approved_by_company = true, \n        approval_date_company = NOW()\n    WHERE id = '${id}' AND company_id = '${company_id}'\n    RETURNING *\n  `;\n  \n  try {\n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    // Añadir al historial\n    const historyQuery = `\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', 'approved_by_company', '${comment}', '${company_admin_id}')\n      RETURNING *\n    `;\n    \n    await executeQuery(historyQuery);\n    \n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0] as Application;\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'approved') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");\n      \n      // Si ambos han aprobado, actualizar el estado a aprobado\n      return await updateApplicationStatus(\n        id, \n        'approved', \n        'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', \n        company_admin_id,\n        entityFilter\n      );\n    }\n    \n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Obtener estado de aprobación de una solicitud\nexport const getApprovalStatus = async (\n  id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  let query = `\n    SELECT \n      approved_by_advisor, \n      approved_by_company, \n      approval_date_advisor, \n      approval_date_company\n    FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return {\n        approvedByAdvisor: data[0].approved_by_advisor || false,\n        approvedByCompany: data[0].approved_by_company || false,\n        approvalDateAdvisor: data[0].approval_date_advisor,\n        approvalDateCompany: data[0].approval_date_company\n      };\n    }\n    throw new Error('Solicitud no encontrada');\n  } catch (error) {\n    console.error(`Error obteniendo estado de aprobación para solicitud ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete an application\nexport const deleteApplication = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    await executeQuery(query);\n    return true;\n  } catch (error) {\n    console.error(`Error deleting application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Get application history\nexport const getApplicationHistory = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view it');\n    }\n  }\n  \n  const query = `\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${APPLICATION_HISTORY_TABLE} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching history for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Add a comment to an application\nexport const addComment = async (applicationId: string, userId: string, text: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para comentar esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to comment on it');\n    }\n  }\n  \n  const query = `\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error(`Error adding comment to application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Get comments for an application\nexport const getComments = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view its comments');\n    }\n  }\n  \n  const query = `\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching comments for application ${applicationId}:`, error);\n    throw error;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}