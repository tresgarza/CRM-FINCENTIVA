{"ast":null,"code":"import { executeQuery } from '../utils/databaseUtils';\nimport { TABLES } from '../utils/constants/tables';\n// Nombre de la tabla definido como constante para evitar errores de escritura\nconst CLIENTS_TABLE = TABLES.CLIENTS || 'clients';\n\n// Get all clients with filters\nexport const getClients = async filters => {\n  try {\n    // Construir la consulta base\n    let query = `SELECT * FROM ${CLIENTS_TABLE} WHERE 1=1`;\n\n    // Crear una consulta para el conteo total filtrado\n    let countQuery = `SELECT COUNT(*) as total FROM ${CLIENTS_TABLE} WHERE 1=1`;\n\n    // Aplicar filtros si existen\n    if (filters) {\n      let filterClause = '';\n\n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        filterClause += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n\n      // Filtro por asesor\n      if (filters.advisor_id) {\n        filterClause += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n\n      // Filtro por empresa\n      if (filters.company_id) {\n        filterClause += ` AND company_id = '${filters.company_id}'`;\n      }\n\n      // Filtro por fecha\n      if (filters.dateFrom) {\n        filterClause += ` AND created_at >= '${filters.dateFrom}'`;\n      }\n      if (filters.dateTo) {\n        filterClause += ` AND created_at <= '${filters.dateTo}'`;\n      }\n\n      // Aplicar los mismos filtros a ambas consultas\n      query += filterClause;\n      countQuery += filterClause;\n    }\n\n    // Agregar ordenamiento\n    query += ` ORDER BY created_at DESC`;\n\n    // Agregar paginación si se especifica\n    if ((filters === null || filters === void 0 ? void 0 : filters.page) !== undefined && filters !== null && filters !== void 0 && filters.pageSize) {\n      const offset = filters.page * filters.pageSize;\n      query += ` LIMIT ${filters.pageSize} OFFSET ${offset}`;\n    }\n\n    // Ejecutar las consultas\n    const clients = await executeQuery(query);\n    const totalCountResult = await executeQuery(countQuery);\n\n    // Extraer el valor del conteo total\n    const totalCount = totalCountResult && totalCountResult.length > 0 ? parseInt(totalCountResult[0].total) : 0;\n\n    // Devolver un objeto con clients y totalCount\n    return {\n      clients: clients || [],\n      totalCount\n    };\n  } catch (error) {\n    console.error('Error al obtener clientes:', error);\n    // Si la tabla no existe o hay otro error, devolver un objeto con arrays vacíos\n    return {\n      clients: [],\n      totalCount: 0\n    };\n  }\n};\n\n// Get a single client by ID\nexport const getClientById = async id => {\n  try {\n    const query = `SELECT * FROM ${CLIENTS_TABLE} WHERE id = '${id}'`;\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al obtener cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Escapa caracteres especiales en cadenas SQL\n */\nfunction escapeSQLString(str) {\n  return str.replace(/'/g, \"''\");\n}\n\n// Get applications for a specific client\nexport const getClientApplications = async clientId => {\n  try {\n    const query = `\n      SELECT * FROM ${TABLES.APPLICATIONS} \n      WHERE client_id = '${clientId}' OR source_id = '${clientId}'\n      ORDER BY created_at DESC\n    `;\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error al obtener aplicaciones del cliente ${clientId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new client\nexport const createClient = async client => {\n  try {\n    // Construir lista de campos y valores\n    const fields = Object.keys(client).join(', ');\n    const values = Object.values(client).map(value => typeof value === 'string' ? `'${escapeSQLString(value)}'` : value).join(', ');\n    const query = `\n      INSERT INTO ${CLIENTS_TABLE} (${fields})\n      VALUES (${values})\n      RETURNING *\n    `;\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Error al crear el cliente');\n  } catch (error) {\n    console.error('Error al crear cliente:', error);\n    throw error;\n  }\n};\n\n// Update an existing client\nexport const updateClient = async (id, updates) => {\n  try {\n    // Construir lista de cambios\n    const setClause = Object.entries(updates).map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${escapeSQLString(value)}'` : value}`).join(', ');\n    const query = `\n      UPDATE ${CLIENTS_TABLE}\n      SET ${setClause}\n      WHERE id = '${id}'\n      RETURNING *\n    `;\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al actualizar cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete a client\nexport const deleteClient = async id => {\n  try {\n    const query = `\n      DELETE FROM ${CLIENTS_TABLE}\n      WHERE id = '${id}'\n      RETURNING id\n    `;\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return true;\n    }\n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al eliminar cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Check if a client with the given email or RFC already exists\nexport const checkClientExists = async (email, rfc) => {\n  try {\n    let query = `\n      SELECT id, email, rfc FROM ${CLIENTS_TABLE}\n      WHERE email = '${escapeSQLString(email)}'\n    `;\n    if (rfc) {\n      query += ` OR rfc = '${escapeSQLString(rfc)}'`;\n    }\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return {\n        exists: true,\n        client: data[0]\n      };\n    }\n    return {\n      exists: false\n    };\n  } catch (error) {\n    console.error('Error al verificar existencia de cliente:', error);\n    throw error;\n  }\n};\n\n// Get total count of clients with filters\nexport const getClientCount = async filters => {\n  try {\n    let query = `SELECT COUNT(*) as count FROM ${CLIENTS_TABLE} WHERE 1=1`;\n\n    // Aplicar filtros si existen\n    if (filters) {\n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        query += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n\n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n\n      // Filtro por empresa\n      if (filters.company_id) {\n        query += ` AND company_id = '${filters.company_id}'`;\n      }\n    }\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return parseInt(data[0].count) || 0;\n    }\n    return 0;\n  } catch (error) {\n    console.error('Error al obtener conteo de clientes:', error);\n    return 0;\n  }\n};","map":{"version":3,"names":["executeQuery","TABLES","CLIENTS_TABLE","CLIENTS","getClients","filters","query","countQuery","filterClause","searchQuery","advisor_id","company_id","dateFrom","dateTo","page","undefined","pageSize","offset","clients","totalCountResult","totalCount","length","parseInt","total","error","console","getClientById","id","data","Error","escapeSQLString","str","replace","getClientApplications","clientId","APPLICATIONS","createClient","client","fields","Object","keys","join","values","map","value","updateClient","updates","setClause","entries","key","deleteClient","checkClientExists","email","rfc","exists","getClientCount","count"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/clientService.ts"],"sourcesContent":["import { executeQuery } from '../utils/databaseUtils';\nimport { TABLES } from '../utils/constants/tables';\n\nexport interface Client {\n  id: string;\n  created_at: string;\n  name: string;\n  email: string;\n  phone: string;\n  address?: string;\n  city?: string;\n  state?: string;\n  postal_code?: string;\n  birth_date?: string;\n  rfc?: string;\n  curp?: string;\n  company_id?: string;\n  advisor_id?: string;\n}\n\nexport interface ClientFilter {\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n  page?: number;\n  pageSize?: number;\n}\n\n// Nombre de la tabla definido como constante para evitar errores de escritura\nconst CLIENTS_TABLE = TABLES.CLIENTS || 'clients';\n\n// Get all clients with filters\nexport const getClients = async (filters?: ClientFilter) => {\n  try {\n    // Construir la consulta base\n    let query = `SELECT * FROM ${CLIENTS_TABLE} WHERE 1=1`;\n\n    // Crear una consulta para el conteo total filtrado\n    let countQuery = `SELECT COUNT(*) as total FROM ${CLIENTS_TABLE} WHERE 1=1`;\n\n    // Aplicar filtros si existen\n    if (filters) {\n      let filterClause = '';\n      \n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        filterClause += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n\n      // Filtro por asesor\n      if (filters.advisor_id) {\n        filterClause += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n\n      // Filtro por empresa\n      if (filters.company_id) {\n        filterClause += ` AND company_id = '${filters.company_id}'`;\n      }\n\n      // Filtro por fecha\n      if (filters.dateFrom) {\n        filterClause += ` AND created_at >= '${filters.dateFrom}'`;\n      }\n      if (filters.dateTo) {\n        filterClause += ` AND created_at <= '${filters.dateTo}'`;\n      }\n      \n      // Aplicar los mismos filtros a ambas consultas\n      query += filterClause;\n      countQuery += filterClause;\n    }\n\n    // Agregar ordenamiento\n    query += ` ORDER BY created_at DESC`;\n\n    // Agregar paginación si se especifica\n    if (filters?.page !== undefined && filters?.pageSize) {\n      const offset = filters.page * filters.pageSize;\n      query += ` LIMIT ${filters.pageSize} OFFSET ${offset}`;\n    }\n\n    // Ejecutar las consultas\n    const clients = await executeQuery(query);\n    const totalCountResult = await executeQuery(countQuery);\n    \n    // Extraer el valor del conteo total\n    const totalCount = totalCountResult && totalCountResult.length > 0 \n      ? parseInt(totalCountResult[0].total) \n      : 0;\n    \n    // Devolver un objeto con clients y totalCount\n    return {\n      clients: clients || [],\n      totalCount\n    };\n  } catch (error) {\n    console.error('Error al obtener clientes:', error);\n    // Si la tabla no existe o hay otro error, devolver un objeto con arrays vacíos\n    return {\n      clients: [],\n      totalCount: 0\n    };\n  }\n};\n\n// Get a single client by ID\nexport const getClientById = async (id: string) => {\n  try {\n    const query = `SELECT * FROM ${CLIENTS_TABLE} WHERE id = '${id}'`;\n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return data[0] as Client;\n    }\n    \n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al obtener cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Escapa caracteres especiales en cadenas SQL\n */\nfunction escapeSQLString(str: string) {\n  return str.replace(/'/g, \"''\");\n}\n\n// Get applications for a specific client\nexport const getClientApplications = async (clientId: string) => {\n  try {\n    const query = `\n      SELECT * FROM ${TABLES.APPLICATIONS} \n      WHERE client_id = '${clientId}' OR source_id = '${clientId}'\n      ORDER BY created_at DESC\n    `;\n    \n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error al obtener aplicaciones del cliente ${clientId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new client\nexport const createClient = async (client: Omit<Client, 'id' | 'created_at'>) => {\n  try {\n    // Construir lista de campos y valores\n    const fields = Object.keys(client).join(', ');\n    const values = Object.values(client)\n      .map(value => typeof value === 'string' ? `'${escapeSQLString(value)}'` : value)\n      .join(', ');\n    \n    const query = `\n      INSERT INTO ${CLIENTS_TABLE} (${fields})\n      VALUES (${values})\n      RETURNING *\n    `;\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return data[0] as Client;\n    }\n    \n    throw new Error('Error al crear el cliente');\n  } catch (error) {\n    console.error('Error al crear cliente:', error);\n    throw error;\n  }\n};\n\n// Update an existing client\nexport const updateClient = async (id: string, updates: Partial<Client>) => {\n  try {\n    // Construir lista de cambios\n    const setClause = Object.entries(updates)\n      .map(([key, value]) => \n        `${key} = ${typeof value === 'string' ? `'${escapeSQLString(value)}'` : value}`\n      )\n      .join(', ');\n    \n    const query = `\n      UPDATE ${CLIENTS_TABLE}\n      SET ${setClause}\n      WHERE id = '${id}'\n      RETURNING *\n    `;\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return data[0] as Client;\n    }\n    \n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al actualizar cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete a client\nexport const deleteClient = async (id: string) => {\n  try {\n    const query = `\n      DELETE FROM ${CLIENTS_TABLE}\n      WHERE id = '${id}'\n      RETURNING id\n    `;\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return true;\n    }\n    \n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al eliminar cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Check if a client with the given email or RFC already exists\nexport const checkClientExists = async (email: string, rfc?: string) => {\n  try {\n    let query = `\n      SELECT id, email, rfc FROM ${CLIENTS_TABLE}\n      WHERE email = '${escapeSQLString(email)}'\n    `;\n    \n    if (rfc) {\n      query += ` OR rfc = '${escapeSQLString(rfc)}'`;\n    }\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return {\n        exists: true,\n        client: data[0]\n      };\n    }\n    \n    return { exists: false };\n  } catch (error) {\n    console.error('Error al verificar existencia de cliente:', error);\n    throw error;\n  }\n};\n\n// Get total count of clients with filters\nexport const getClientCount = async (filters?: ClientFilter) => {\n  try {\n    let query = `SELECT COUNT(*) as count FROM ${CLIENTS_TABLE} WHERE 1=1`;\n    \n    // Aplicar filtros si existen\n    if (filters) {\n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        query += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n      \n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n      \n      // Filtro por empresa\n      if (filters.company_id) {\n        query += ` AND company_id = '${filters.company_id}'`;\n      }\n    }\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return parseInt(data[0].count) || 0;\n    }\n    \n    return 0;\n  } catch (error) {\n    console.error('Error al obtener conteo de clientes:', error);\n    return 0;\n  }\n}; "],"mappings":"AAAA,SAASA,YAAY,QAAQ,wBAAwB;AACrD,SAASC,MAAM,QAAQ,2BAA2B;AA6BlD;AACA,MAAMC,aAAa,GAAGD,MAAM,CAACE,OAAO,IAAI,SAAS;;AAEjD;AACA,OAAO,MAAMC,UAAU,GAAG,MAAOC,OAAsB,IAAK;EAC1D,IAAI;IACF;IACA,IAAIC,KAAK,GAAG,iBAAiBJ,aAAa,YAAY;;IAEtD;IACA,IAAIK,UAAU,GAAG,iCAAiCL,aAAa,YAAY;;IAE3E;IACA,IAAIG,OAAO,EAAE;MACX,IAAIG,YAAY,GAAG,EAAE;;MAErB;MACA,IAAIH,OAAO,CAACI,WAAW,EAAE;QACvBD,YAAY,IAAI;AACxB,yBAAyBH,OAAO,CAACI,WAAW;AAC5C,0BAA0BJ,OAAO,CAACI,WAAW;AAC7C,0BAA0BJ,OAAO,CAACI,WAAW;AAC7C,wBAAwBJ,OAAO,CAACI,WAAW;AAC3C,UAAU;MACJ;;MAEA;MACA,IAAIJ,OAAO,CAACK,UAAU,EAAE;QACtBF,YAAY,IAAI,sBAAsBH,OAAO,CAACK,UAAU,GAAG;MAC7D;;MAEA;MACA,IAAIL,OAAO,CAACM,UAAU,EAAE;QACtBH,YAAY,IAAI,sBAAsBH,OAAO,CAACM,UAAU,GAAG;MAC7D;;MAEA;MACA,IAAIN,OAAO,CAACO,QAAQ,EAAE;QACpBJ,YAAY,IAAI,uBAAuBH,OAAO,CAACO,QAAQ,GAAG;MAC5D;MACA,IAAIP,OAAO,CAACQ,MAAM,EAAE;QAClBL,YAAY,IAAI,uBAAuBH,OAAO,CAACQ,MAAM,GAAG;MAC1D;;MAEA;MACAP,KAAK,IAAIE,YAAY;MACrBD,UAAU,IAAIC,YAAY;IAC5B;;IAEA;IACAF,KAAK,IAAI,2BAA2B;;IAEpC;IACA,IAAI,CAAAD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAES,IAAI,MAAKC,SAAS,IAAIV,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEW,QAAQ,EAAE;MACpD,MAAMC,MAAM,GAAGZ,OAAO,CAACS,IAAI,GAAGT,OAAO,CAACW,QAAQ;MAC9CV,KAAK,IAAI,UAAUD,OAAO,CAACW,QAAQ,WAAWC,MAAM,EAAE;IACxD;;IAEA;IACA,MAAMC,OAAO,GAAG,MAAMlB,YAAY,CAACM,KAAK,CAAC;IACzC,MAAMa,gBAAgB,GAAG,MAAMnB,YAAY,CAACO,UAAU,CAAC;;IAEvD;IACA,MAAMa,UAAU,GAAGD,gBAAgB,IAAIA,gBAAgB,CAACE,MAAM,GAAG,CAAC,GAC9DC,QAAQ,CAACH,gBAAgB,CAAC,CAAC,CAAC,CAACI,KAAK,CAAC,GACnC,CAAC;;IAEL;IACA,OAAO;MACLL,OAAO,EAAEA,OAAO,IAAI,EAAE;MACtBE;IACF,CAAC;EACH,CAAC,CAAC,OAAOI,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;IAClD;IACA,OAAO;MACLN,OAAO,EAAE,EAAE;MACXE,UAAU,EAAE;IACd,CAAC;EACH;AACF,CAAC;;AAED;AACA,OAAO,MAAMM,aAAa,GAAG,MAAOC,EAAU,IAAK;EACjD,IAAI;IACF,MAAMrB,KAAK,GAAG,iBAAiBJ,aAAa,gBAAgByB,EAAE,GAAG;IACjE,MAAMC,IAAI,GAAG,MAAM5B,YAAY,CAACM,KAAK,CAAC;IAEtC,IAAIsB,IAAI,IAAIA,IAAI,CAACP,MAAM,GAAG,CAAC,EAAE;MAC3B,OAAOO,IAAI,CAAC,CAAC,CAAC;IAChB;IAEA,MAAM,IAAIC,KAAK,CAAC,uBAAuB,CAAC;EAC1C,CAAC,CAAC,OAAOL,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,mCAAmCG,EAAE,GAAG,EAAEH,KAAK,CAAC;IAC9D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA;AACA;AACA,SAASM,eAAeA,CAACC,GAAW,EAAE;EACpC,OAAOA,GAAG,CAACC,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC;AAChC;;AAEA;AACA,OAAO,MAAMC,qBAAqB,GAAG,MAAOC,QAAgB,IAAK;EAC/D,IAAI;IACF,MAAM5B,KAAK,GAAG;AAClB,sBAAsBL,MAAM,CAACkC,YAAY;AACzC,2BAA2BD,QAAQ,qBAAqBA,QAAQ;AAChE;AACA,KAAK;IAED,OAAO,MAAMlC,YAAY,CAACM,KAAK,CAAC;EAClC,CAAC,CAAC,OAAOkB,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,6CAA6CU,QAAQ,GAAG,EAAEV,KAAK,CAAC;IAC9E,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAMY,YAAY,GAAG,MAAOC,MAAyC,IAAK;EAC/E,IAAI;IACF;IACA,MAAMC,MAAM,GAAGC,MAAM,CAACC,IAAI,CAACH,MAAM,CAAC,CAACI,IAAI,CAAC,IAAI,CAAC;IAC7C,MAAMC,MAAM,GAAGH,MAAM,CAACG,MAAM,CAACL,MAAM,CAAC,CACjCM,GAAG,CAACC,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,GAAG,IAAId,eAAe,CAACc,KAAK,CAAC,GAAG,GAAGA,KAAK,CAAC,CAC/EH,IAAI,CAAC,IAAI,CAAC;IAEb,MAAMnC,KAAK,GAAG;AAClB,oBAAoBJ,aAAa,KAAKoC,MAAM;AAC5C,gBAAgBI,MAAM;AACtB;AACA,KAAK;IAED,MAAMd,IAAI,GAAG,MAAM5B,YAAY,CAACM,KAAK,CAAC;IAEtC,IAAIsB,IAAI,IAAIA,IAAI,CAACP,MAAM,GAAG,CAAC,EAAE;MAC3B,OAAOO,IAAI,CAAC,CAAC,CAAC;IAChB;IAEA,MAAM,IAAIC,KAAK,CAAC,2BAA2B,CAAC;EAC9C,CAAC,CAAC,OAAOL,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;IAC/C,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAMqB,YAAY,GAAG,MAAAA,CAAOlB,EAAU,EAAEmB,OAAwB,KAAK;EAC1E,IAAI;IACF;IACA,MAAMC,SAAS,GAAGR,MAAM,CAACS,OAAO,CAACF,OAAO,CAAC,CACtCH,GAAG,CAAC,CAAC,CAACM,GAAG,EAAEL,KAAK,CAAC,KAChB,GAAGK,GAAG,MAAM,OAAOL,KAAK,KAAK,QAAQ,GAAG,IAAId,eAAe,CAACc,KAAK,CAAC,GAAG,GAAGA,KAAK,EAC/E,CAAC,CACAH,IAAI,CAAC,IAAI,CAAC;IAEb,MAAMnC,KAAK,GAAG;AAClB,eAAeJ,aAAa;AAC5B,YAAY6C,SAAS;AACrB,oBAAoBpB,EAAE;AACtB;AACA,KAAK;IAED,MAAMC,IAAI,GAAG,MAAM5B,YAAY,CAACM,KAAK,CAAC;IAEtC,IAAIsB,IAAI,IAAIA,IAAI,CAACP,MAAM,GAAG,CAAC,EAAE;MAC3B,OAAOO,IAAI,CAAC,CAAC,CAAC;IAChB;IAEA,MAAM,IAAIC,KAAK,CAAC,uBAAuB,CAAC;EAC1C,CAAC,CAAC,OAAOL,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,sCAAsCG,EAAE,GAAG,EAAEH,KAAK,CAAC;IACjE,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAM0B,YAAY,GAAG,MAAOvB,EAAU,IAAK;EAChD,IAAI;IACF,MAAMrB,KAAK,GAAG;AAClB,oBAAoBJ,aAAa;AACjC,oBAAoByB,EAAE;AACtB;AACA,KAAK;IAED,MAAMC,IAAI,GAAG,MAAM5B,YAAY,CAACM,KAAK,CAAC;IAEtC,IAAIsB,IAAI,IAAIA,IAAI,CAACP,MAAM,GAAG,CAAC,EAAE;MAC3B,OAAO,IAAI;IACb;IAEA,MAAM,IAAIQ,KAAK,CAAC,uBAAuB,CAAC;EAC1C,CAAC,CAAC,OAAOL,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,oCAAoCG,EAAE,GAAG,EAAEH,KAAK,CAAC;IAC/D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAM2B,iBAAiB,GAAG,MAAAA,CAAOC,KAAa,EAAEC,GAAY,KAAK;EACtE,IAAI;IACF,IAAI/C,KAAK,GAAG;AAChB,mCAAmCJ,aAAa;AAChD,uBAAuB4B,eAAe,CAACsB,KAAK,CAAC;AAC7C,KAAK;IAED,IAAIC,GAAG,EAAE;MACP/C,KAAK,IAAI,cAAcwB,eAAe,CAACuB,GAAG,CAAC,GAAG;IAChD;IAEA,MAAMzB,IAAI,GAAG,MAAM5B,YAAY,CAACM,KAAK,CAAC;IAEtC,IAAIsB,IAAI,IAAIA,IAAI,CAACP,MAAM,GAAG,CAAC,EAAE;MAC3B,OAAO;QACLiC,MAAM,EAAE,IAAI;QACZjB,MAAM,EAAET,IAAI,CAAC,CAAC;MAChB,CAAC;IACH;IAEA,OAAO;MAAE0B,MAAM,EAAE;IAAM,CAAC;EAC1B,CAAC,CAAC,OAAO9B,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,2CAA2C,EAAEA,KAAK,CAAC;IACjE,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAM+B,cAAc,GAAG,MAAOlD,OAAsB,IAAK;EAC9D,IAAI;IACF,IAAIC,KAAK,GAAG,iCAAiCJ,aAAa,YAAY;;IAEtE;IACA,IAAIG,OAAO,EAAE;MACX;MACA,IAAIA,OAAO,CAACI,WAAW,EAAE;QACvBH,KAAK,IAAI;AACjB,yBAAyBD,OAAO,CAACI,WAAW;AAC5C,0BAA0BJ,OAAO,CAACI,WAAW;AAC7C,0BAA0BJ,OAAO,CAACI,WAAW;AAC7C,wBAAwBJ,OAAO,CAACI,WAAW;AAC3C,UAAU;MACJ;;MAEA;MACA,IAAIJ,OAAO,CAACK,UAAU,EAAE;QACtBJ,KAAK,IAAI,sBAAsBD,OAAO,CAACK,UAAU,GAAG;MACtD;;MAEA;MACA,IAAIL,OAAO,CAACM,UAAU,EAAE;QACtBL,KAAK,IAAI,sBAAsBD,OAAO,CAACM,UAAU,GAAG;MACtD;IACF;IAEA,MAAMiB,IAAI,GAAG,MAAM5B,YAAY,CAACM,KAAK,CAAC;IAEtC,IAAIsB,IAAI,IAAIA,IAAI,CAACP,MAAM,GAAG,CAAC,EAAE;MAC3B,OAAOC,QAAQ,CAACM,IAAI,CAAC,CAAC,CAAC,CAAC4B,KAAK,CAAC,IAAI,CAAC;IACrC;IAEA,OAAO,CAAC;EACV,CAAC,CAAC,OAAOhC,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,sCAAsC,EAAEA,KAAK,CAAC;IAC5D,OAAO,CAAC;EACV;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}