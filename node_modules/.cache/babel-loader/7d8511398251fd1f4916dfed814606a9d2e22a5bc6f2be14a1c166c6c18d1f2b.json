{"ast":null,"code":"import { TABLES } from '../utils/constants/tables';\nimport { executeQuery } from '../utils/databaseUtils';\n/**\n * Obtiene estadísticas generales para el dashboard\n */\nexport const getGeneralDashboardStats = async (filters = {}) => {\n  const {\n    dateFrom,\n    dateTo,\n    companyId,\n    advisorId,\n    includeSimulations = false\n  } = filters;\n\n  // Construir la parte de la consulta para los filtros de fecha\n  let dateFilter = '';\n  if (dateFrom) {\n    dateFilter += ` AND created_at >= '${dateFrom}'`;\n  }\n  if (dateTo) {\n    dateFilter += ` AND created_at <= '${dateTo}'`;\n  }\n\n  // Filtro por compañía si se proporciona\n  let companyFilter = '';\n  if (companyId) {\n    companyFilter = ` AND company_id = '${companyId}'`;\n  }\n\n  // Filtro por asesor si se proporciona\n  let advisorFilter = '';\n  if (advisorId) {\n    advisorFilter = ` AND assigned_to = '${advisorId}'`;\n  }\n\n  // Filtro para excluir simulaciones por defecto\n  let simulationFilter = '';\n  if (!includeSimulations) {\n    simulationFilter = ` AND application_type != 'product_simulations'`;\n  }\n  try {\n    var _totalApplicationsDat, _amountStatsData$, _amountStatsData$2, _amountStatsData$3;\n    // 1. Total de aplicaciones\n    const totalApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n    `;\n    let totalApplicationsData;\n    try {\n      totalApplicationsData = await executeQuery(totalApplicationsQuery);\n    } catch (error) {\n      console.error('Error al obtener total de aplicaciones:', error);\n      totalApplicationsData = [{\n        total: 0\n      }]; // Valor por defecto si falla\n    }\n    const totalApplications = ((_totalApplicationsDat = totalApplicationsData[0]) === null || _totalApplicationsDat === void 0 ? void 0 : _totalApplicationsDat.total) || 0;\n\n    // 2. Aplicaciones por estado\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n      GROUP BY status\n    `;\n    let applicationsByStatusData;\n    try {\n      applicationsByStatusData = await executeQuery(applicationsByStatusQuery);\n    } catch (error) {\n      console.error('Error al obtener aplicaciones por estado:', error);\n      applicationsByStatusData = []; // Valor por defecto si falla\n    }\n    const applicationsByStatus = {};\n    applicationsByStatusData.forEach(item => {\n      applicationsByStatus[item.status] = parseInt(item.count);\n    });\n    const pendingApplications = applicationsByStatus['pending'] || 0;\n    const approvedApplications = applicationsByStatus['approved'] || 0;\n    const rejectedApplications = applicationsByStatus['rejected'] || 0;\n\n    // 3. Promedio, mínimo y máximo de montos\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n    `;\n    let amountStatsData;\n    try {\n      amountStatsData = await executeQuery(amountStatsQuery);\n    } catch (error) {\n      console.error('Error al obtener estadísticas de montos:', error);\n      amountStatsData = [{\n        avg_amount: 0,\n        min_amount: 0,\n        max_amount: 0\n      }]; // Valor por defecto si falla\n    }\n    const averageAmount = parseFloat((_amountStatsData$ = amountStatsData[0]) === null || _amountStatsData$ === void 0 ? void 0 : _amountStatsData$.avg_amount) || 0;\n    const minAmount = parseFloat((_amountStatsData$2 = amountStatsData[0]) === null || _amountStatsData$2 === void 0 ? void 0 : _amountStatsData$2.min_amount) || 0;\n    const maxAmount = parseFloat((_amountStatsData$3 = amountStatsData[0]) === null || _amountStatsData$3 === void 0 ? void 0 : _amountStatsData$3.max_amount) || 0;\n\n    // 4. Aplicaciones recientes\n    const recentApplicationsQuery = `\n      SELECT id, client_name, company_name, created_at, status, amount, application_type\n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n      AND application_type = 'selected_plans'\n      ORDER BY created_at DESC \n      LIMIT 5\n    `;\n    let recentApplicationsData;\n    try {\n      recentApplicationsData = await executeQuery(recentApplicationsQuery);\n    } catch (error) {\n      console.error('Error al obtener aplicaciones recientes:', error);\n      recentApplicationsData = []; // Valor por defecto si falla\n    }\n\n    // 5. Aplicaciones por mes (para gráfico de líneas)\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n      GROUP BY month \n      ORDER BY month\n    `;\n    let applicationsByMonthData;\n    try {\n      applicationsByMonthData = await executeQuery(applicationsByMonthQuery);\n    } catch (error) {\n      console.error('Error al obtener aplicaciones por mes:', error);\n      applicationsByMonthData = []; // Valor por defecto si falla\n    }\n    const applicationsByMonth = {};\n    applicationsByMonthData.forEach(item => {\n      applicationsByMonth[item.month] = parseInt(item.count);\n    });\n\n    // 6. Rendimiento de asesores (solo para superadmin o filtrado por compañía)\n    let advisorsPerformance = [];\n    if (!advisorId) {\n      // Solo si no estamos filtrando por un asesor específico\n      const advisorsPerformanceQuery = `\n        SELECT \n          a.assigned_to as advisor_id, \n          u.name as advisor_name,\n          COUNT(*) as total_applications,\n          SUM(CASE WHEN a.status = 'approved' THEN 1 ELSE 0 END) as approved_applications,\n          SUM(CASE WHEN a.status = 'rejected' THEN 1 ELSE 0 END) as rejected_applications\n        FROM ${TABLES.APPLICATIONS} a\n        LEFT JOIN ${TABLES.ADVISORS} u ON a.assigned_to = u.id\n        WHERE 1=1 ${dateFilter} ${companyFilter} ${simulationFilter}\n        GROUP BY a.assigned_to, u.name\n        ORDER BY total_applications DESC\n      `;\n      try {\n        const advisorsData = await executeQuery(advisorsPerformanceQuery);\n        advisorsPerformance = advisorsData.map(advisor => ({\n          advisorId: advisor.advisor_id,\n          advisorName: advisor.advisor_name || 'Desconocido',\n          totalApplications: parseInt(advisor.total_applications) || 0,\n          approvedApplications: parseInt(advisor.approved_applications) || 0,\n          rejectedApplications: parseInt(advisor.rejected_applications) || 0,\n          approvalRate: advisor.total_applications > 0 ? parseInt(advisor.approved_applications) / parseInt(advisor.total_applications) * 100 : 0\n        }));\n      } catch (error) {\n        console.error('Error al obtener rendimiento de asesores:', error);\n        // Continuamos incluso si esta consulta falla\n      }\n    }\n\n    // 7. Total de clientes\n    let totalClients = 0;\n    const totalClientsQuery = `\n      SELECT COUNT(DISTINCT source_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE source_id IS NOT NULL ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n    `;\n    try {\n      var _totalClientsData$;\n      const totalClientsData = await executeQuery(totalClientsQuery);\n      totalClients = parseInt((_totalClientsData$ = totalClientsData[0]) === null || _totalClientsData$ === void 0 ? void 0 : _totalClientsData$.total) || 0;\n    } catch (error) {\n      console.error('Error al obtener total de clientes:', error);\n      // Continuamos incluso si esta consulta falla\n    }\n    return {\n      totalApplications: parseInt(totalApplications),\n      pendingApplications,\n      approvedApplications,\n      rejectedApplications,\n      averageAmount,\n      minAmount,\n      maxAmount,\n      recentApplications: recentApplicationsData,\n      applicationsByStatus,\n      applicationsByMonth,\n      advisorsPerformance,\n      totalClients\n    };\n  } catch (error) {\n    console.error('Error obteniendo estadísticas del dashboard:', error);\n    // En caso de error, devolvemos datos vacíos para evitar que la UI se rompa\n    return {\n      totalApplications: 0,\n      pendingApplications: 0,\n      approvedApplications: 0,\n      rejectedApplications: 0,\n      averageAmount: 0,\n      minAmount: 0,\n      maxAmount: 0,\n      recentApplications: [],\n      applicationsByStatus: {},\n      applicationsByMonth: {},\n      totalClients: 0\n    };\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para un asesor\n * @param advisorId ID del asesor\n * @param includeSimulations Si es true, incluye las simulaciones en las estadísticas\n */\nexport const getAdvisorDashboardStats = async (advisorId, includeSimulations = false) => {\n  try {\n    var _advisorAppResult$, _amountResult$, _amountResult$2, _amountResult$3, _companiesResult$, _conversionResult$, _conversionResult$2, _totalApprovedResult$, _totalRejectedResult$, _totalPendingResult$, _pendingApprovalResul, _timeResult$;\n    // Filtro para excluir simulaciones por defecto\n    let simulationFilter = '';\n    if (!includeSimulations) {\n      simulationFilter = ` AND application_type != 'product_simulations'`;\n    }\n\n    // No obtener estadísticas generales, sino filtrar todo por el asesor\n\n    // Total de aplicaciones del asesor\n    const advisorApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const advisorAppResult = await executeQuery(advisorApplicationsQuery);\n    const totalAdvisorApplications = parseInt(((_advisorAppResult$ = advisorAppResult[0]) === null || _advisorAppResult$ === void 0 ? void 0 : _advisorAppResult$.total) || '0');\n\n    // Aplicaciones por estado del asesor\n    const advisorStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n      GROUP BY status\n    `;\n    const advisorStatusResult = await executeQuery(advisorStatusQuery);\n    const advisorApplicationsByStatus = advisorStatusResult.map(row => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Estadísticas de montos específicas del asesor\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n      AND assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(((_amountResult$ = amountResult[0]) === null || _amountResult$ === void 0 ? void 0 : _amountResult$.avg_amount) || '0');\n    const minAmount = parseFloat(((_amountResult$2 = amountResult[0]) === null || _amountResult$2 === void 0 ? void 0 : _amountResult$2.min_amount) || '0');\n    const maxAmount = parseFloat(((_amountResult$3 = amountResult[0]) === null || _amountResult$3 === void 0 ? void 0 : _amountResult$3.max_amount) || '0');\n\n    // Calcular aplicaciones por mes para este asesor\n    const monthlyQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month,\n        COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    let applicationsByMonth = [];\n    try {\n      const monthlyResult = await executeQuery(monthlyQuery);\n      applicationsByMonth = monthlyResult.map(row => ({\n        month: row.month,\n        count: parseInt(row.count)\n      }));\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones por mes para asesor ${advisorId}:`, error);\n      applicationsByMonth = [];\n    }\n\n    // Total de clientes del asesor\n    let totalClients = 0;\n    try {\n      var _clientsResult$;\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE advisor_id = '${advisorId}'\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClients = parseInt(((_clientsResult$ = clientsResult[0]) === null || _clientsResult$ === void 0 ? void 0 : _clientsResult$.total) || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        var _clientNamesResult$;\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE assigned_to = '${advisorId}'\n          ${simulationFilter}\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClients = parseInt(((_clientNamesResult$ = clientNamesResult[0]) === null || _clientNamesResult$ === void 0 ? void 0 : _clientNamesResult$.total) || '0');\n      } catch (innerError) {\n        console.error(`Error counting clients for advisor ${advisorId}:`, innerError);\n        // If that also fails, default to 0\n        totalClients = 0;\n      }\n    }\n\n    // Total de empresas asignadas al asesor\n    const companiesQuery = `\n      SELECT COUNT(DISTINCT company_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const companiesResult = await executeQuery(companiesQuery);\n    const totalCompanies = parseInt(((_companiesResult$ = companiesResult[0]) === null || _companiesResult$ === void 0 ? void 0 : _companiesResult$.total) || '0');\n\n    // Tasa de conversión (aprobados / total)\n    const conversionRateQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'completed')) as approved,\n        COUNT(*) as total\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const conversionResult = await executeQuery(conversionRateQuery);\n    const approved = parseInt(((_conversionResult$ = conversionResult[0]) === null || _conversionResult$ === void 0 ? void 0 : _conversionResult$.approved) || '0');\n    const total = parseInt(((_conversionResult$2 = conversionResult[0]) === null || _conversionResult$2 === void 0 ? void 0 : _conversionResult$2.total) || '0');\n    const conversionRate = total > 0 ? approved / total * 100 : 0;\n\n    // Calcular totales específicos para cada estado\n    const totalApprovedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('approved', 'APROBADO', 'completed')\n      ${simulationFilter}\n    `;\n    const totalApprovedResult = await executeQuery(totalApprovedQuery);\n    const totalApproved = parseInt(((_totalApprovedResult$ = totalApprovedResult[0]) === null || _totalApprovedResult$ === void 0 ? void 0 : _totalApprovedResult$.count) || '0');\n    const totalRejectedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('rejected', 'RECHAZADO')\n      ${simulationFilter}\n    `;\n    const totalRejectedResult = await executeQuery(totalRejectedQuery);\n    const totalRejected = parseInt(((_totalRejectedResult$ = totalRejectedResult[0]) === null || _totalRejectedResult$ === void 0 ? void 0 : _totalRejectedResult$.count) || '0');\n    const totalPendingQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('pending', 'PENDIENTE', 'review', 'REVISION')\n      ${simulationFilter}\n    `;\n    const totalPendingResult = await executeQuery(totalPendingQuery);\n    const totalPending = parseInt(((_totalPendingResult$ = totalPendingResult[0]) === null || _totalPendingResult$ === void 0 ? void 0 : _totalPendingResult$.count) || '0');\n    const pendingApprovalQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const pendingApprovalResult = await executeQuery(pendingApprovalQuery);\n    const pendingApproval = parseInt(((_pendingApprovalResul = pendingApprovalResult[0]) === null || _pendingApprovalResul === void 0 ? void 0 : _pendingApprovalResul.pending_approval) || '0');\n\n    // Tiempo promedio hasta aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_advisor - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      AND approval_date_advisor IS NOT NULL\n      ${simulationFilter}\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgTimeToApproval = parseFloat(((_timeResult$ = timeResult[0]) === null || _timeResult$ === void 0 ? void 0 : _timeResult$.avg_days) || '0');\n\n    // Aplicaciones recientes del asesor\n    let recentAdvisorApps = [];\n    try {\n      const recentAdvisorAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${advisorId}'\n        AND application_type = 'selected_plans'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentAdvisorApps = await executeQuery(recentAdvisorAppsQuery);\n\n      // Asegurarse de que application_type esté presente en todos los registros\n      recentAdvisorApps = recentAdvisorApps.map(app => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes del asesor ${advisorId}:`, error);\n      recentAdvisorApps = [];\n    }\n    return {\n      totalApplications: totalAdvisorApplications,\n      applicationsByStatus: advisorApplicationsByStatus,\n      averageAmount: avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications: recentAdvisorApps,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients,\n      totalCompanies,\n      conversionRate,\n      avgTimeToApproval,\n      advisorId,\n      advisorName: '',\n      // This would be populated from user data\n      pendingApplications: totalPending,\n      approvedApplications: totalApproved,\n      rejectedApplications: totalRejected\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas del asesor ${advisorId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para una empresa\n * @param companyId ID de la empresa\n * @param includeSimulations Si es true, incluye las simulaciones en las estadísticas\n */\nexport const getCompanyDashboardStats = async (companyId, includeSimulations = false) => {\n  try {\n    var _companyAppResult$, _advisorsResult$, _clientNamesResult$2, _timeResult$2, _baseStats$pendingApp;\n    // Filtro para excluir simulaciones por defecto\n    let simulationFilter = '';\n    if (!includeSimulations) {\n      simulationFilter = ` AND application_type != 'product_simulations'`;\n    }\n\n    // Obtenemos las estadísticas generales primero con el mismo filtro\n    const baseStats = await getGeneralDashboardStats({\n      companyId,\n      includeSimulations\n    });\n\n    // Estadísticas específicas de la empresa\n    // Total de aplicaciones de la empresa\n    const companyApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n    `;\n    const companyAppResult = await executeQuery(companyApplicationsQuery);\n    const totalCompanyApplications = parseInt(((_companyAppResult$ = companyAppResult[0]) === null || _companyAppResult$ === void 0 ? void 0 : _companyAppResult$.total) || '0');\n\n    // Aplicaciones por estado de la empresa\n    const companyStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n      GROUP BY status\n    `;\n    const companyStatusResult = await executeQuery(companyStatusQuery);\n    const companyApplicationsByStatus = companyStatusResult.map(row => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de asesores asignados a la empresa\n    const advisorsQuery = `\n      SELECT COUNT(DISTINCT assigned_to) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n    `;\n    const advisorsResult = await executeQuery(advisorsQuery);\n    const totalAdvisors = parseInt(((_advisorsResult$ = advisorsResult[0]) === null || _advisorsResult$ === void 0 ? void 0 : _advisorsResult$.total) || '0');\n\n    // Total de clientes de la empresa\n    const clientNamesQuery = `\n      SELECT COUNT(DISTINCT client_name) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n    `;\n    const clientNamesResult = await executeQuery(clientNamesQuery);\n    const totalClientsCompany = parseInt(((_clientNamesResult$2 = clientNamesResult[0]) === null || _clientNamesResult$2 === void 0 ? void 0 : _clientNamesResult$2.total) || '0');\n\n    // Tiempo promedio de aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_company - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      AND approval_date_company IS NOT NULL\n      ${simulationFilter}\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgApprovalTime = parseFloat(((_timeResult$2 = timeResult[0]) === null || _timeResult$2 === void 0 ? void 0 : _timeResult$2.avg_days) || '0');\n\n    // Aplicaciones recientes de la empresa\n    let recentCompanyApps = [];\n    try {\n      const recentCompanyAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, assigned_to, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND application_type = 'selected_plans'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentCompanyApps = await executeQuery(recentCompanyAppsQuery);\n\n      // Asegurarse de que application_type esté presente en todos los registros\n      recentCompanyApps = recentCompanyApps.map(app => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes de la empresa ${companyId}:`, error);\n      // Datos de muestra en caso de error\n      recentCompanyApps = [{\n        id: '1',\n        created_at: new Date().toISOString(),\n        client_name: 'Cliente de Empresa',\n        status: 'pending',\n        amount: '15000',\n        assigned_to: 'Asesor Asignado',\n        application_type: 'selected_plans'\n      }];\n    }\n    return {\n      ...baseStats,\n      totalApplications: totalCompanyApplications,\n      applicationsByStatus: companyApplicationsByStatus,\n      recentApplications: recentCompanyApps,\n      totalAdvisors,\n      totalClientsCompany,\n      avgApprovalTime,\n      pendingApplications: parseInt(((_baseStats$pendingApp = baseStats.pendingApplications) === null || _baseStats$pendingApp === void 0 ? void 0 : _baseStats$pendingApp.toString()) || '0'),\n      applicationsByMonth: Array.isArray(baseStats.applicationsByMonth) ? baseStats.applicationsByMonth : Object.entries(baseStats.applicationsByMonth || {}).map(([month, count]) => ({\n        month,\n        count: Number(count)\n      }))\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas de la empresa ${companyId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas de aplicaciones pendientes de aprobación\n * @param userId ID del usuario (asesor o admin de empresa)\n * @param isCompanyAdmin Indica si el usuario es un admin de empresa\n */\nexport const getPendingApprovalStats = async (userId, isCompanyAdmin) => {\n  try {\n    var _result$;\n    let query = '';\n    if (isCompanyAdmin) {\n      var _companyResult$;\n      // Obtener ID de la compañía del admin\n      const companyQuery = `\n        SELECT company_id FROM ${TABLES.COMPANY_ADMINS} WHERE id = '${userId}'\n      `;\n      const companyResult = await executeQuery(companyQuery);\n      const companyId = (_companyResult$ = companyResult[0]) === null || _companyResult$ === void 0 ? void 0 : _companyResult$.company_id;\n      if (!companyId) {\n        throw new Error('No se encontró la compañía para este administrador');\n      }\n\n      // Aplicaciones pendientes de aprobación por la compañía\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND approved_by_advisor = true\n        AND approved_by_company = false\n      `;\n    } else {\n      // Aplicaciones pendientes de aprobación por el asesor\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;\n    }\n    const result = await executeQuery(query);\n    return {\n      pendingCount: parseInt(((_result$ = result[0]) === null || _result$ === void 0 ? void 0 : _result$.pending_count) || '0')\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas de aprobaciones pendientes:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["TABLES","executeQuery","getGeneralDashboardStats","filters","dateFrom","dateTo","companyId","advisorId","includeSimulations","dateFilter","companyFilter","advisorFilter","simulationFilter","_totalApplicationsDat","_amountStatsData$","_amountStatsData$2","_amountStatsData$3","totalApplicationsQuery","APPLICATIONS","totalApplicationsData","error","console","total","totalApplications","applicationsByStatusQuery","applicationsByStatusData","applicationsByStatus","forEach","item","status","parseInt","count","pendingApplications","approvedApplications","rejectedApplications","amountStatsQuery","amountStatsData","avg_amount","min_amount","max_amount","averageAmount","parseFloat","minAmount","maxAmount","recentApplicationsQuery","recentApplicationsData","applicationsByMonthQuery","applicationsByMonthData","applicationsByMonth","month","advisorsPerformance","advisorsPerformanceQuery","ADVISORS","advisorsData","map","advisor","advisor_id","advisorName","advisor_name","total_applications","approved_applications","rejected_applications","approvalRate","totalClients","totalClientsQuery","_totalClientsData$","totalClientsData","recentApplications","getAdvisorDashboardStats","_advisorAppResult$","_amountResult$","_amountResult$2","_amountResult$3","_companiesResult$","_conversionResult$","_conversionResult$2","_totalApprovedResult$","_totalRejectedResult$","_totalPendingResult$","_pendingApprovalResul","_timeResult$","advisorApplicationsQuery","advisorAppResult","totalAdvisorApplications","advisorStatusQuery","advisorStatusResult","advisorApplicationsByStatus","row","amountResult","avgAmount","monthlyQuery","monthlyResult","_clientsResult$","clientsQuery","CLIENTS","clientsResult","_clientNamesResult$","clientNamesQuery","clientNamesResult","innerError","companiesQuery","companiesResult","totalCompanies","conversionRateQuery","conversionResult","approved","conversionRate","totalApprovedQuery","totalApprovedResult","totalApproved","totalRejectedQuery","totalRejectedResult","totalRejected","totalPendingQuery","totalPendingResult","totalPending","pendingApprovalQuery","pendingApprovalResult","pendingApproval","pending_approval","avgTimeQuery","timeResult","avgTimeToApproval","avg_days","recentAdvisorApps","recentAdvisorAppsQuery","app","application_type","toLowerCase","includes","getCompanyDashboardStats","_companyAppResult$","_advisorsResult$","_clientNamesResult$2","_timeResult$2","_baseStats$pendingApp","baseStats","companyApplicationsQuery","companyAppResult","totalCompanyApplications","companyStatusQuery","companyStatusResult","companyApplicationsByStatus","advisorsQuery","advisorsResult","totalAdvisors","totalClientsCompany","avgApprovalTime","recentCompanyApps","recentCompanyAppsQuery","id","created_at","Date","toISOString","client_name","amount","assigned_to","toString","Array","isArray","Object","entries","Number","getPendingApprovalStats","userId","isCompanyAdmin","_result$","query","_companyResult$","companyQuery","COMPANY_ADMINS","companyResult","company_id","Error","result","pendingCount","pending_count"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/dashboardService.ts"],"sourcesContent":["import { TABLES } from '../utils/constants/tables';\nimport { executeQuery } from '../utils/databaseUtils';\n\ninterface DashboardStatsFilter {\n  dateFrom?: string;\n  dateTo?: string;\n  companyId?: string;\n  advisorId?: string;\n  includeSimulations?: boolean; // Nuevo parámetro para controlar si se incluyen simulaciones\n}\n\ninterface AdvisorPerformanceStats {\n  advisorId: string;\n  advisorName: string;\n  totalApplications: number;\n  approvedApplications: number;\n  rejectedApplications: number;\n  approvalRate: number;\n}\n\nexport interface DashboardStats {\n  totalApplications: number;\n  pendingApplications: number;\n  approvedApplications: number;\n  rejectedApplications: number;\n  averageAmount: number;\n  minAmount: number;\n  maxAmount: number;\n  recentApplications: any[];\n  applicationsByStatus: Record<string, number>;\n  applicationsByMonth: Record<string, number>;\n  advisorsPerformance?: AdvisorPerformanceStats[];\n  totalClients: number;\n}\n\nexport interface AdvisorStats extends Omit<DashboardStats, 'applicationsByMonth' | 'applicationsByStatus'> {\n  advisorId: string;\n  advisorName: string;\n  applicationsByMonth: Array<{month: string, count: number}>;\n  applicationsByStatus: Array<{status: string, count: number}>;\n  totalApproved: number;\n  totalRejected: number;\n  totalPending: number;\n  pendingApproval: number;\n  totalCompanies: number;\n  conversionRate: number;\n  avgTimeToApproval: number;\n}\n\nexport interface CompanyStats extends Omit<DashboardStats, 'applicationsByMonth' | 'applicationsByStatus'> {\n  totalAdvisors: number;\n  totalClientsCompany: number;\n  avgApprovalTime: number;\n  pendingApplications: number;\n  applicationsByStatus: Array<{status: string, count: number}>;\n  applicationsByMonth: Array<{month: string, count: number}>;\n}\n\n/**\n * Obtiene estadísticas generales para el dashboard\n */\nexport const getGeneralDashboardStats = async (filters: DashboardStatsFilter = {}): Promise<DashboardStats> => {\n  const { dateFrom, dateTo, companyId, advisorId, includeSimulations = false } = filters;\n  \n  // Construir la parte de la consulta para los filtros de fecha\n  let dateFilter = '';\n  if (dateFrom) {\n    dateFilter += ` AND created_at >= '${dateFrom}'`;\n  }\n  if (dateTo) {\n    dateFilter += ` AND created_at <= '${dateTo}'`;\n  }\n  \n  // Filtro por compañía si se proporciona\n  let companyFilter = '';\n  if (companyId) {\n    companyFilter = ` AND company_id = '${companyId}'`;\n  }\n  \n  // Filtro por asesor si se proporciona\n  let advisorFilter = '';\n  if (advisorId) {\n    advisorFilter = ` AND assigned_to = '${advisorId}'`;\n  }\n  \n  // Filtro para excluir simulaciones por defecto\n  let simulationFilter = '';\n  if (!includeSimulations) {\n    simulationFilter = ` AND application_type != 'product_simulations'`;\n  }\n\n  try {\n    // 1. Total de aplicaciones\n    const totalApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n    `;\n    \n    let totalApplicationsData;\n    try {\n      totalApplicationsData = await executeQuery(totalApplicationsQuery);\n    } catch (error) {\n      console.error('Error al obtener total de aplicaciones:', error);\n      totalApplicationsData = [{ total: 0 }]; // Valor por defecto si falla\n    }\n    \n    const totalApplications = totalApplicationsData[0]?.total || 0;\n    \n    // 2. Aplicaciones por estado\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n      GROUP BY status\n    `;\n    \n    let applicationsByStatusData;\n    try {\n      applicationsByStatusData = await executeQuery(applicationsByStatusQuery);\n    } catch (error) {\n      console.error('Error al obtener aplicaciones por estado:', error);\n      applicationsByStatusData = []; // Valor por defecto si falla\n    }\n    \n    const applicationsByStatus: Record<string, number> = {};\n    applicationsByStatusData.forEach((item: any) => {\n      applicationsByStatus[item.status] = parseInt(item.count);\n    });\n    \n    const pendingApplications = applicationsByStatus['pending'] || 0;\n    const approvedApplications = applicationsByStatus['approved'] || 0;\n    const rejectedApplications = applicationsByStatus['rejected'] || 0;\n    \n    // 3. Promedio, mínimo y máximo de montos\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n    `;\n    \n    let amountStatsData;\n    try {\n      amountStatsData = await executeQuery(amountStatsQuery);\n    } catch (error) {\n      console.error('Error al obtener estadísticas de montos:', error);\n      amountStatsData = [{ avg_amount: 0, min_amount: 0, max_amount: 0 }]; // Valor por defecto si falla\n    }\n    \n    const averageAmount = parseFloat(amountStatsData[0]?.avg_amount) || 0;\n    const minAmount = parseFloat(amountStatsData[0]?.min_amount) || 0;\n    const maxAmount = parseFloat(amountStatsData[0]?.max_amount) || 0;\n    \n    // 4. Aplicaciones recientes\n    const recentApplicationsQuery = `\n      SELECT id, client_name, company_name, created_at, status, amount, application_type\n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n      AND application_type = 'selected_plans'\n      ORDER BY created_at DESC \n      LIMIT 5\n    `;\n    \n    let recentApplicationsData;\n    try {\n      recentApplicationsData = await executeQuery(recentApplicationsQuery);\n    } catch (error) {\n      console.error('Error al obtener aplicaciones recientes:', error);\n      recentApplicationsData = []; // Valor por defecto si falla\n    }\n    \n    // 5. Aplicaciones por mes (para gráfico de líneas)\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n      GROUP BY month \n      ORDER BY month\n    `;\n    \n    let applicationsByMonthData;\n    try {\n      applicationsByMonthData = await executeQuery(applicationsByMonthQuery);\n    } catch (error) {\n      console.error('Error al obtener aplicaciones por mes:', error);\n      applicationsByMonthData = []; // Valor por defecto si falla\n    }\n    \n    const applicationsByMonth: Record<string, number> = {};\n    applicationsByMonthData.forEach((item: any) => {\n      applicationsByMonth[item.month] = parseInt(item.count);\n    });\n    \n    // 6. Rendimiento de asesores (solo para superadmin o filtrado por compañía)\n    let advisorsPerformance: AdvisorPerformanceStats[] = [];\n    \n    if (!advisorId) { // Solo si no estamos filtrando por un asesor específico\n      const advisorsPerformanceQuery = `\n        SELECT \n          a.assigned_to as advisor_id, \n          u.name as advisor_name,\n          COUNT(*) as total_applications,\n          SUM(CASE WHEN a.status = 'approved' THEN 1 ELSE 0 END) as approved_applications,\n          SUM(CASE WHEN a.status = 'rejected' THEN 1 ELSE 0 END) as rejected_applications\n        FROM ${TABLES.APPLICATIONS} a\n        LEFT JOIN ${TABLES.ADVISORS} u ON a.assigned_to = u.id\n        WHERE 1=1 ${dateFilter} ${companyFilter} ${simulationFilter}\n        GROUP BY a.assigned_to, u.name\n        ORDER BY total_applications DESC\n      `;\n      \n      try {\n        const advisorsData = await executeQuery(advisorsPerformanceQuery);\n        advisorsPerformance = advisorsData.map((advisor: any) => ({\n          advisorId: advisor.advisor_id,\n          advisorName: advisor.advisor_name || 'Desconocido',\n          totalApplications: parseInt(advisor.total_applications) || 0,\n          approvedApplications: parseInt(advisor.approved_applications) || 0,\n          rejectedApplications: parseInt(advisor.rejected_applications) || 0,\n          approvalRate: advisor.total_applications > 0 \n            ? (parseInt(advisor.approved_applications) / parseInt(advisor.total_applications)) * 100 \n            : 0\n        }));\n      } catch (error) {\n        console.error('Error al obtener rendimiento de asesores:', error);\n        // Continuamos incluso si esta consulta falla\n      }\n    }\n    \n    // 7. Total de clientes\n    let totalClients = 0;\n    const totalClientsQuery = `\n      SELECT COUNT(DISTINCT source_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE source_id IS NOT NULL ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n    `;\n    \n    try {\n      const totalClientsData = await executeQuery(totalClientsQuery);\n      totalClients = parseInt(totalClientsData[0]?.total) || 0;\n    } catch (error) {\n      console.error('Error al obtener total de clientes:', error);\n      // Continuamos incluso si esta consulta falla\n    }\n    \n    return {\n      totalApplications: parseInt(totalApplications),\n      pendingApplications,\n      approvedApplications,\n      rejectedApplications,\n      averageAmount,\n      minAmount,\n      maxAmount,\n      recentApplications: recentApplicationsData,\n      applicationsByStatus,\n      applicationsByMonth,\n      advisorsPerformance,\n      totalClients\n    };\n    \n  } catch (error) {\n    console.error('Error obteniendo estadísticas del dashboard:', error);\n    // En caso de error, devolvemos datos vacíos para evitar que la UI se rompa\n    return {\n      totalApplications: 0,\n      pendingApplications: 0,\n      approvedApplications: 0,\n      rejectedApplications: 0,\n      averageAmount: 0,\n      minAmount: 0,\n      maxAmount: 0,\n      recentApplications: [],\n      applicationsByStatus: {},\n      applicationsByMonth: {},\n      totalClients: 0\n    };\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para un asesor\n * @param advisorId ID del asesor\n * @param includeSimulations Si es true, incluye las simulaciones en las estadísticas\n */\nexport const getAdvisorDashboardStats = async (advisorId: string, includeSimulations: boolean = false): Promise<AdvisorStats> => {\n  try {\n    // Filtro para excluir simulaciones por defecto\n    let simulationFilter = '';\n    if (!includeSimulations) {\n      simulationFilter = ` AND application_type != 'product_simulations'`;\n    }\n    \n    // No obtener estadísticas generales, sino filtrar todo por el asesor\n    \n    // Total de aplicaciones del asesor\n    const advisorApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const advisorAppResult = await executeQuery(advisorApplicationsQuery);\n    const totalAdvisorApplications = parseInt(advisorAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado del asesor\n    const advisorStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n      GROUP BY status\n    `;\n    const advisorStatusResult = await executeQuery(advisorStatusQuery);\n    const advisorApplicationsByStatus = advisorStatusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Estadísticas de montos específicas del asesor\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n      AND assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(amountResult[0]?.avg_amount || '0');\n    const minAmount = parseFloat(amountResult[0]?.min_amount || '0');\n    const maxAmount = parseFloat(amountResult[0]?.max_amount || '0');\n\n    // Calcular aplicaciones por mes para este asesor\n    const monthlyQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month,\n        COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    \n    let applicationsByMonth: {month: string, count: number}[] = [];\n    try {\n      const monthlyResult = await executeQuery(monthlyQuery);\n      applicationsByMonth = monthlyResult.map((row: any) => ({\n        month: row.month,\n        count: parseInt(row.count)\n      }));\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones por mes para asesor ${advisorId}:`, error);\n      applicationsByMonth = [];\n    }\n\n    // Total de clientes del asesor\n    let totalClients = 0;\n    try {\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE advisor_id = '${advisorId}'\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClients = parseInt(clientsResult[0]?.total || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE assigned_to = '${advisorId}'\n          ${simulationFilter}\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClients = parseInt(clientNamesResult[0]?.total || '0');\n      } catch (innerError) {\n        console.error(`Error counting clients for advisor ${advisorId}:`, innerError);\n        // If that also fails, default to 0\n        totalClients = 0;\n      }\n    }\n\n    // Total de empresas asignadas al asesor\n    const companiesQuery = `\n      SELECT COUNT(DISTINCT company_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const companiesResult = await executeQuery(companiesQuery);\n    const totalCompanies = parseInt(companiesResult[0]?.total || '0');\n\n    // Tasa de conversión (aprobados / total)\n    const conversionRateQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'completed')) as approved,\n        COUNT(*) as total\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const conversionResult = await executeQuery(conversionRateQuery);\n    const approved = parseInt(conversionResult[0]?.approved || '0');\n    const total = parseInt(conversionResult[0]?.total || '0');\n    const conversionRate = total > 0 ? (approved / total) * 100 : 0;\n\n    // Calcular totales específicos para cada estado\n    const totalApprovedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('approved', 'APROBADO', 'completed')\n      ${simulationFilter}\n    `;\n    const totalApprovedResult = await executeQuery(totalApprovedQuery);\n    const totalApproved = parseInt(totalApprovedResult[0]?.count || '0');\n\n    const totalRejectedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('rejected', 'RECHAZADO')\n      ${simulationFilter}\n    `;\n    const totalRejectedResult = await executeQuery(totalRejectedQuery);\n    const totalRejected = parseInt(totalRejectedResult[0]?.count || '0');\n\n    const totalPendingQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('pending', 'PENDIENTE', 'review', 'REVISION')\n      ${simulationFilter}\n    `;\n    const totalPendingResult = await executeQuery(totalPendingQuery);\n    const totalPending = parseInt(totalPendingResult[0]?.count || '0');\n\n    const pendingApprovalQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const pendingApprovalResult = await executeQuery(pendingApprovalQuery);\n    const pendingApproval = parseInt(pendingApprovalResult[0]?.pending_approval || '0');\n\n    // Tiempo promedio hasta aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_advisor - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      AND approval_date_advisor IS NOT NULL\n      ${simulationFilter}\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgTimeToApproval = parseFloat(timeResult[0]?.avg_days || '0');\n\n    // Aplicaciones recientes del asesor\n    let recentAdvisorApps = [];\n    try {\n      const recentAdvisorAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${advisorId}'\n        AND application_type = 'selected_plans'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentAdvisorApps = await executeQuery(recentAdvisorAppsQuery);\n      \n      // Asegurarse de que application_type esté presente en todos los registros\n      recentAdvisorApps = recentAdvisorApps.map((app: any) => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes del asesor ${advisorId}:`, error);\n      recentAdvisorApps = [];\n    }\n\n    return {\n      totalApplications: totalAdvisorApplications,\n      applicationsByStatus: advisorApplicationsByStatus,\n      averageAmount: avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications: recentAdvisorApps,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients,\n      totalCompanies,\n      conversionRate,\n      avgTimeToApproval,\n      advisorId,\n      advisorName: '',  // This would be populated from user data\n      pendingApplications: totalPending,\n      approvedApplications: totalApproved,\n      rejectedApplications: totalRejected\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas del asesor ${advisorId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para una empresa\n * @param companyId ID de la empresa\n * @param includeSimulations Si es true, incluye las simulaciones en las estadísticas\n */\nexport const getCompanyDashboardStats = async (companyId: string, includeSimulations: boolean = false): Promise<CompanyStats> => {\n  try {\n    // Filtro para excluir simulaciones por defecto\n    let simulationFilter = '';\n    if (!includeSimulations) {\n      simulationFilter = ` AND application_type != 'product_simulations'`;\n    }\n    \n    // Obtenemos las estadísticas generales primero con el mismo filtro\n    const baseStats = await getGeneralDashboardStats({ companyId, includeSimulations });\n\n    // Estadísticas específicas de la empresa\n    // Total de aplicaciones de la empresa\n    const companyApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n    `;\n    const companyAppResult = await executeQuery(companyApplicationsQuery);\n    const totalCompanyApplications = parseInt(companyAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado de la empresa\n    const companyStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n      GROUP BY status\n    `;\n    const companyStatusResult = await executeQuery(companyStatusQuery);\n    const companyApplicationsByStatus = companyStatusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de asesores asignados a la empresa\n    const advisorsQuery = `\n      SELECT COUNT(DISTINCT assigned_to) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n    `;\n    const advisorsResult = await executeQuery(advisorsQuery);\n    const totalAdvisors = parseInt(advisorsResult[0]?.total || '0');\n\n    // Total de clientes de la empresa\n    const clientNamesQuery = `\n      SELECT COUNT(DISTINCT client_name) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n    `;\n    const clientNamesResult = await executeQuery(clientNamesQuery);\n    const totalClientsCompany = parseInt(clientNamesResult[0]?.total || '0');\n\n    // Tiempo promedio de aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_company - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      AND approval_date_company IS NOT NULL\n      ${simulationFilter}\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgApprovalTime = parseFloat(timeResult[0]?.avg_days || '0');\n\n    // Aplicaciones recientes de la empresa\n    let recentCompanyApps = [];\n    try {\n      const recentCompanyAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, assigned_to, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND application_type = 'selected_plans'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentCompanyApps = await executeQuery(recentCompanyAppsQuery);\n      \n      // Asegurarse de que application_type esté presente en todos los registros\n      recentCompanyApps = recentCompanyApps.map((app: any) => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes de la empresa ${companyId}:`, error);\n      // Datos de muestra en caso de error\n      recentCompanyApps = [\n        { id: '1', created_at: new Date().toISOString(), client_name: 'Cliente de Empresa', status: 'pending', amount: '15000', assigned_to: 'Asesor Asignado', application_type: 'selected_plans' }\n      ];\n    }\n\n    return {\n      ...baseStats,\n      totalApplications: totalCompanyApplications,\n      applicationsByStatus: companyApplicationsByStatus,\n      recentApplications: recentCompanyApps,\n      totalAdvisors,\n      totalClientsCompany,\n      avgApprovalTime,\n      pendingApplications: parseInt(baseStats.pendingApplications?.toString() || '0'),\n      applicationsByMonth: Array.isArray(baseStats.applicationsByMonth) \n        ? baseStats.applicationsByMonth \n        : Object.entries(baseStats.applicationsByMonth || {}).map(([month, count]) => ({\n            month,\n            count: Number(count)\n          }))\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas de la empresa ${companyId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas de aplicaciones pendientes de aprobación\n * @param userId ID del usuario (asesor o admin de empresa)\n * @param isCompanyAdmin Indica si el usuario es un admin de empresa\n */\nexport const getPendingApprovalStats = async (userId: string, isCompanyAdmin: boolean): Promise<any> => {\n  try {\n    let query = '';\n    \n    if (isCompanyAdmin) {\n      // Obtener ID de la compañía del admin\n      const companyQuery = `\n        SELECT company_id FROM ${TABLES.COMPANY_ADMINS} WHERE id = '${userId}'\n      `;\n      const companyResult = await executeQuery(companyQuery);\n      const companyId = companyResult[0]?.company_id;\n      \n      if (!companyId) {\n        throw new Error('No se encontró la compañía para este administrador');\n      }\n      \n      // Aplicaciones pendientes de aprobación por la compañía\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND approved_by_advisor = true\n        AND approved_by_company = false\n      `;\n    } else {\n      // Aplicaciones pendientes de aprobación por el asesor\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;\n    }\n    \n    const result = await executeQuery(query);\n    return {\n      pendingCount: parseInt(result[0]?.pending_count || '0')\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas de aprobaciones pendientes:', error);\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}