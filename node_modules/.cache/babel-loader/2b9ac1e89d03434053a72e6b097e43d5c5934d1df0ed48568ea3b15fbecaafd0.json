{"ast":null,"code":"import { supabase } from '../lib/supabaseClient';\nimport { ErrorType, createAppError, logError, safeAsync } from './errorHandling';\nimport { v4 as uuidv4 } from 'uuid';\nimport { getStorage } from '../lib/supabaseClient';\n/**\n * Maximum number of upload retry attempts\n */\nexport const MAX_UPLOAD_RETRIES = 3;\n\n/**\n * Validates if a file is a valid document for upload\n */\nexport const isValidDocument = file => {\n  // Allowed MIME types\n  const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/jpg', 'image/heic', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/msword', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.ms-excel'];\n\n  // Maximum file size (10MB)\n  const maxSize = 10 * 1024 * 1024;\n  return allowedTypes.includes(file.type) && file.size <= maxSize;\n};\n\n/**\n * Uploads a document to storage with automatic retries\n */\nexport const uploadDocumentToStorage = async (document, folder, attempt = 1) => {\n  const file = document.file;\n  if (!isValidDocument(file)) {\n    throw createAppError(ErrorType.VALIDATION, 'Invalid document format or size', {\n      fileName: file.name,\n      fileType: file.type,\n      fileSize: file.size\n    });\n  }\n  try {\n    // Generate unique file id and name\n    const fileId = uuidv4();\n    const fileExtension = file.name.split('.').pop();\n    const fileName = `${fileId}.${fileExtension}`;\n    const filePath = `${folder}/${fileName}`;\n\n    // Upload the file\n    const {\n      error: uploadError\n    } = await supabase.storage.from('documents').upload(filePath, file);\n    if (uploadError) {\n      throw createAppError(ErrorType.UPLOAD, `Error uploading document: ${uploadError.message}`, {\n        filePath,\n        attempt\n      }, uploadError);\n    }\n\n    // Get public URL for the uploaded file\n    const {\n      data: publicUrlData\n    } = supabase.storage.from('documents').getPublicUrl(filePath);\n\n    // Return document info\n    return {\n      id: fileId,\n      name: file.name,\n      size: file.size,\n      type: document.type,\n      url: publicUrlData.publicUrl,\n      description: document.description,\n      createdAt: new Date().toISOString()\n    };\n  } catch (error) {\n    // Retry logic for transient errors\n    if (attempt < MAX_UPLOAD_RETRIES) {\n      logError(error, 'documentUpload', {\n        message: `Retrying upload (${attempt + 1}/${MAX_UPLOAD_RETRIES})`,\n        fileName: file.name\n      });\n\n      // Exponential backoff delay\n      const delay = Math.pow(2, attempt) * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n\n      // Retry with incremented attempt count\n      return uploadDocumentToStorage(document, folder, attempt + 1);\n    }\n\n    // Max retries reached, rethrow error\n    throw error;\n  }\n};\n\n/**\n * Uploads multiple documents with reliable error handling\n */\nexport const uploadDocuments = async (documents, folder) => {\n  const uploadedDocs = [];\n  const failedDocs = [];\n\n  // Process each document\n  for (const document of documents) {\n    const [uploaded, error] = await safeAsync(uploadDocumentToStorage(document, folder), 'uploadDocuments');\n    if (uploaded) {\n      uploadedDocs.push(uploaded);\n    } else if (error) {\n      failedDocs.push({\n        document,\n        error\n      });\n    }\n  }\n  return {\n    uploadedDocs,\n    failedDocs\n  };\n};\n\n/**\n * Asegura que el bucket de almacenamiento exista antes de utilizarlo\n * @param bucketName Nombre del bucket a verificar\n * @returns True si el bucket existe o fue creado correctamente\n */\nexport const ensureClientBucketExists = async (bucketName = 'client-documents') => {\n  try {\n    console.log(`Verificando si el bucket ${bucketName} existe...`);\n    const storage = getStorage();\n\n    // Intentar listar buckets para verificar si existe\n    const {\n      data: buckets,\n      error: listError\n    } = await storage.listBuckets();\n    if (listError) {\n      console.error(`Error al listar buckets:`, listError);\n      throw createAppError(ErrorType.UPLOAD, `Error al acceder al almacenamiento: ${listError.message}`, {\n        error: listError\n      });\n    }\n\n    // Verificar si el bucket ya existe\n    const bucketExists = buckets === null || buckets === void 0 ? void 0 : buckets.some(bucket => bucket.name === bucketName);\n    if (bucketExists) {\n      console.log(`El bucket ${bucketName} ya existe.`);\n      return true;\n    }\n    console.log(`El bucket ${bucketName} no existe. Intentando crearlo...`);\n\n    // Crear el bucket si no existe\n    const {\n      data,\n      error: createError\n    } = await storage.createBucket(bucketName, {\n      public: false\n    });\n    if (createError) {\n      console.error(`Error al crear el bucket ${bucketName}:`, createError);\n      throw createAppError(ErrorType.UPLOAD, `Error al crear el bucket de almacenamiento: ${createError.message}`, {\n        bucketName,\n        error: createError\n      });\n    }\n    console.log(`Bucket ${bucketName} creado correctamente.`);\n\n    // Configurar políticas de acceso público para el bucket\n    const {\n      error: policyError\n    } = await storage.from(bucketName).createSignedUploadUrl('test.txt');\n    if (policyError && !policyError.message.includes('already exists')) {\n      console.warn(`Advertencia al configurar políticas del bucket: ${policyError.message}`);\n    }\n    return true;\n  } catch (error) {\n    console.error(`Error al verificar/crear bucket ${bucketName}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Uploads client documents to storage\n * @param clientId The client ID\n * @param documents Array of documents to upload\n * @param maxRetries Maximum number of retry attempts (default: 2)\n * @returns Array of successfully uploaded documents (without the original file object)\n */\nexport const uploadClientDocuments = async (clientId, documents, maxRetries = 2) => {\n  // Verify parameters\n  if (!clientId) {\n    throw new Error('Client ID is required for uploading documents');\n  }\n  if (!documents || !Array.isArray(documents) || documents.length === 0) {\n    return [];\n  }\n  try {\n    // Asegurar que el bucket existe antes de continuar\n    const bucketName = 'client-documents';\n    await ensureClientBucketExists(bucketName);\n    const storage = getStorage();\n    const uploadedDocs = [];\n    const failedDocs = [];\n\n    // Filter out documents without files\n    const validDocuments = documents.filter(doc => doc.file && doc.category && doc.name);\n    console.log(`Intentando subir ${validDocuments.length} documentos para el cliente ${clientId}`);\n    for (const doc of validDocuments) {\n      let fileUrl = '';\n      let success = false;\n      let attempts = 0;\n      let lastError = null;\n      while (!success && attempts <= maxRetries) {\n        attempts++;\n        try {\n          // Construct a unique file name to avoid collisions\n          const timestamp = new Date().getTime();\n          const fileName = `${timestamp}_${doc.file.name.replace(/\\s+/g, '_')}`;\n          const filePath = `${clientId}/${doc.category}/${fileName}`;\n          console.log(`Intento ${attempts}/${maxRetries + 1}: Subiendo documento \"${doc.name}\" a ${filePath}`);\n\n          // Upload the file\n          const {\n            data,\n            error\n          } = await storage.from(bucketName).upload(filePath, doc.file, {\n            cacheControl: '3600',\n            upsert: true // Cambiar a true para sobrescribir si existe\n          });\n          if (error) {\n            console.error(`Error al subir archivo (intento ${attempts}/${maxRetries + 1}):`, error);\n            lastError = error;\n            throw error;\n          }\n\n          // Get the public URL\n          const {\n            data: urlData\n          } = storage.from(bucketName).getPublicUrl(filePath);\n          fileUrl = urlData.publicUrl;\n          success = true;\n          console.log(`Documento \"${doc.name}\" subido exitosamente a ${filePath}`);\n        } catch (error) {\n          lastError = error;\n\n          // Si no es el último intento, esperar antes de reintentar\n          if (attempts <= maxRetries) {\n            const waitTime = Math.pow(2, attempts - 1) * 1000; // Backoff exponencial\n            console.log(`Esperando ${waitTime}ms antes de reintentar...`);\n            await new Promise(resolve => setTimeout(resolve, waitTime));\n          } else {\n            console.error(`Falló la subida después de ${attempts} intentos.`);\n            failedDocs.push({\n              name: doc.name || doc.file.name,\n              error: error\n            });\n            logError(ErrorType.UPLOAD, `Error al subir documento \"${doc.name || doc.file.name}\" después de ${maxRetries + 1} intentos`, {\n              documentName: doc.file.name,\n              clientId,\n              error,\n              category: doc.category\n            });\n          }\n        }\n      }\n      if (success) {\n        // Create document without the file property\n        const {\n          file,\n          ...docWithoutFile\n        } = doc;\n        uploadedDocs.push({\n          ...docWithoutFile,\n          url: fileUrl\n        });\n      }\n    }\n    if (failedDocs.length > 0) {\n      console.warn(`${failedDocs.length} documentos fallaron al subirse:`, failedDocs);\n    }\n    console.log(`Completado: ${uploadedDocs.length} documentos subidos exitosamente`);\n    return uploadedDocs;\n  } catch (error) {\n    console.error('Error general en uploadClientDocuments:', error);\n    throw createAppError(ErrorType.UPLOAD, error instanceof Error ? error.message : 'Error al subir documentos', {\n      clientId,\n      error\n    });\n  }\n};","map":{"version":3,"names":["supabase","ErrorType","createAppError","logError","safeAsync","v4","uuidv4","getStorage","MAX_UPLOAD_RETRIES","isValidDocument","file","allowedTypes","maxSize","includes","type","size","uploadDocumentToStorage","document","folder","attempt","VALIDATION","fileName","name","fileType","fileSize","fileId","fileExtension","split","pop","filePath","error","uploadError","storage","from","upload","UPLOAD","message","data","publicUrlData","getPublicUrl","id","url","publicUrl","description","createdAt","Date","toISOString","delay","Math","pow","Promise","resolve","setTimeout","uploadDocuments","documents","uploadedDocs","failedDocs","uploaded","push","ensureClientBucketExists","bucketName","console","log","buckets","listError","listBuckets","bucketExists","some","bucket","createError","createBucket","public","policyError","createSignedUploadUrl","warn","uploadClientDocuments","clientId","maxRetries","Error","Array","isArray","length","validDocuments","filter","doc","category","fileUrl","success","attempts","lastError","timestamp","getTime","replace","cacheControl","upsert","urlData","waitTime","documentName","docWithoutFile"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/documentUpload.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { ErrorType, createAppError, logError, safeAsync } from './errorHandling';\nimport { v4 as uuidv4 } from 'uuid';\nimport { getStorage } from '../lib/supabaseClient';\nimport { ClientDocument } from '../types/client';\n\nexport interface UploadDocument {\n  file: File;\n  type: string;\n  description?: string;\n}\n\nexport interface UploadedDocument {\n  id: string;\n  name: string;\n  size: number;\n  type: string;\n  url: string;\n  description?: string;\n  createdAt: string;\n}\n\n/**\n * Maximum number of upload retry attempts\n */\nexport const MAX_UPLOAD_RETRIES = 3;\n\n/**\n * Validates if a file is a valid document for upload\n */\nexport const isValidDocument = (file: File): boolean => {\n  // Allowed MIME types\n  const allowedTypes = [\n    'application/pdf',\n    'image/jpeg',\n    'image/png',\n    'image/jpg',\n    'image/heic',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n    'application/vnd.ms-excel'\n  ];\n\n  // Maximum file size (10MB)\n  const maxSize = 10 * 1024 * 1024;\n\n  return allowedTypes.includes(file.type) && file.size <= maxSize;\n};\n\n/**\n * Uploads a document to storage with automatic retries\n */\nexport const uploadDocumentToStorage = async (\n  document: UploadDocument,\n  folder: string,\n  attempt = 1\n): Promise<UploadedDocument> => {\n  const file = document.file;\n  \n  if (!isValidDocument(file)) {\n    throw createAppError(\n      ErrorType.VALIDATION,\n      'Invalid document format or size',\n      { \n        fileName: file.name, \n        fileType: file.type, \n        fileSize: file.size \n      }\n    );\n  }\n  \n  try {\n    // Generate unique file id and name\n    const fileId = uuidv4();\n    const fileExtension = file.name.split('.').pop();\n    const fileName = `${fileId}.${fileExtension}`;\n    const filePath = `${folder}/${fileName}`;\n    \n    // Upload the file\n    const { error: uploadError } = await supabase.storage\n      .from('documents')\n      .upload(filePath, file);\n    \n    if (uploadError) {\n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error uploading document: ${uploadError.message}`,\n        { filePath, attempt },\n        uploadError\n      );\n    }\n    \n    // Get public URL for the uploaded file\n    const { data: publicUrlData } = supabase.storage\n      .from('documents')\n      .getPublicUrl(filePath);\n    \n    // Return document info\n    return {\n      id: fileId,\n      name: file.name,\n      size: file.size,\n      type: document.type,\n      url: publicUrlData.publicUrl,\n      description: document.description,\n      createdAt: new Date().toISOString()\n    };\n  } catch (error) {\n    // Retry logic for transient errors\n    if (attempt < MAX_UPLOAD_RETRIES) {\n      logError(error, 'documentUpload', { \n        message: `Retrying upload (${attempt + 1}/${MAX_UPLOAD_RETRIES})`,\n        fileName: file.name\n      });\n      \n      // Exponential backoff delay\n      const delay = Math.pow(2, attempt) * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n      \n      // Retry with incremented attempt count\n      return uploadDocumentToStorage(document, folder, attempt + 1);\n    }\n    \n    // Max retries reached, rethrow error\n    throw error;\n  }\n};\n\n/**\n * Uploads multiple documents with reliable error handling\n */\nexport const uploadDocuments = async (\n  documents: UploadDocument[],\n  folder: string\n): Promise<{\n  uploadedDocs: UploadedDocument[];\n  failedDocs: Array<{ document: UploadDocument; error: any }>;\n}> => {\n  const uploadedDocs: UploadedDocument[] = [];\n  const failedDocs: Array<{ document: UploadDocument; error: any }> = [];\n  \n  // Process each document\n  for (const document of documents) {\n    const [uploaded, error] = await safeAsync(\n      uploadDocumentToStorage(document, folder),\n      'uploadDocuments'\n    );\n    \n    if (uploaded) {\n      uploadedDocs.push(uploaded);\n    } else if (error) {\n      failedDocs.push({ \n        document, \n        error \n      });\n    }\n  }\n  \n  return { uploadedDocs, failedDocs };\n};\n\n/**\n * Asegura que el bucket de almacenamiento exista antes de utilizarlo\n * @param bucketName Nombre del bucket a verificar\n * @returns True si el bucket existe o fue creado correctamente\n */\nexport const ensureClientBucketExists = async (bucketName: string = 'client-documents'): Promise<boolean> => {\n  try {\n    console.log(`Verificando si el bucket ${bucketName} existe...`);\n    const storage = getStorage();\n    \n    // Intentar listar buckets para verificar si existe\n    const { data: buckets, error: listError } = await storage.listBuckets();\n    \n    if (listError) {\n      console.error(`Error al listar buckets:`, listError);\n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error al acceder al almacenamiento: ${listError.message}`,\n        { error: listError }\n      );\n    }\n    \n    // Verificar si el bucket ya existe\n    const bucketExists = buckets?.some(bucket => bucket.name === bucketName);\n    \n    if (bucketExists) {\n      console.log(`El bucket ${bucketName} ya existe.`);\n      return true;\n    }\n    \n    console.log(`El bucket ${bucketName} no existe. Intentando crearlo...`);\n    \n    // Crear el bucket si no existe\n    const { data, error: createError } = await storage.createBucket(bucketName, {\n      public: false\n    });\n    \n    if (createError) {\n      console.error(`Error al crear el bucket ${bucketName}:`, createError);\n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error al crear el bucket de almacenamiento: ${createError.message}`,\n        { bucketName, error: createError }\n      );\n    }\n    \n    console.log(`Bucket ${bucketName} creado correctamente.`);\n    \n    // Configurar políticas de acceso público para el bucket\n    const { error: policyError } = await storage.from(bucketName).createSignedUploadUrl('test.txt');\n    if (policyError && !policyError.message.includes('already exists')) {\n      console.warn(`Advertencia al configurar políticas del bucket: ${policyError.message}`);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error(`Error al verificar/crear bucket ${bucketName}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Uploads client documents to storage\n * @param clientId The client ID\n * @param documents Array of documents to upload\n * @param maxRetries Maximum number of retry attempts (default: 2)\n * @returns Array of successfully uploaded documents (without the original file object)\n */\nexport const uploadClientDocuments = async (\n  clientId: string,\n  documents: ClientDocument[],\n  maxRetries = 2\n): Promise<Omit<ClientDocument & { url: string }, 'file'>[]> => {\n  // Verify parameters\n  if (!clientId) {\n    throw new Error('Client ID is required for uploading documents');\n  }\n\n  if (!documents || !Array.isArray(documents) || documents.length === 0) {\n    return [];\n  }\n\n  try {\n    // Asegurar que el bucket existe antes de continuar\n    const bucketName = 'client-documents';\n    await ensureClientBucketExists(bucketName);\n    \n    const storage = getStorage();\n    const uploadedDocs: Array<Omit<ClientDocument & { url: string }, 'file'>> = [];\n    const failedDocs: Array<{name: string, error: any}> = [];\n\n    // Filter out documents without files\n    const validDocuments = documents.filter(doc => doc.file && doc.category && doc.name);\n    console.log(`Intentando subir ${validDocuments.length} documentos para el cliente ${clientId}`);\n\n    for (const doc of validDocuments) {\n      let fileUrl = '';\n      let success = false;\n      let attempts = 0;\n      let lastError = null;\n\n      while (!success && attempts <= maxRetries) {\n        attempts++;\n        try {\n          // Construct a unique file name to avoid collisions\n          const timestamp = new Date().getTime();\n          const fileName = `${timestamp}_${doc.file.name.replace(/\\s+/g, '_')}`;\n          const filePath = `${clientId}/${doc.category}/${fileName}`;\n\n          console.log(`Intento ${attempts}/${maxRetries+1}: Subiendo documento \"${doc.name}\" a ${filePath}`);\n\n          // Upload the file\n          const { data, error } = await storage\n            .from(bucketName)\n            .upload(filePath, doc.file, {\n              cacheControl: '3600',\n              upsert: true, // Cambiar a true para sobrescribir si existe\n            });\n\n          if (error) {\n            console.error(`Error al subir archivo (intento ${attempts}/${maxRetries+1}):`, error);\n            lastError = error;\n            throw error;\n          }\n\n          // Get the public URL\n          const { data: urlData } = storage\n            .from(bucketName)\n            .getPublicUrl(filePath);\n\n          fileUrl = urlData.publicUrl;\n          success = true;\n          console.log(`Documento \"${doc.name}\" subido exitosamente a ${filePath}`);\n        } catch (error) {\n          lastError = error;\n          \n          // Si no es el último intento, esperar antes de reintentar\n          if (attempts <= maxRetries) {\n            const waitTime = Math.pow(2, attempts-1) * 1000; // Backoff exponencial\n            console.log(`Esperando ${waitTime}ms antes de reintentar...`);\n            await new Promise(resolve => setTimeout(resolve, waitTime));\n          } else {\n            console.error(`Falló la subida después de ${attempts} intentos.`);\n            failedDocs.push({\n              name: doc.name || doc.file.name,\n              error: error\n            });\n            \n            logError(\n              ErrorType.UPLOAD,\n              `Error al subir documento \"${doc.name || doc.file.name}\" después de ${maxRetries+1} intentos`,\n              { documentName: doc.file.name, clientId, error, category: doc.category }\n            );\n          }\n        }\n      }\n\n      if (success) {\n        // Create document without the file property\n        const { file, ...docWithoutFile } = doc;\n        uploadedDocs.push({\n          ...docWithoutFile,\n          url: fileUrl\n        });\n      }\n    }\n\n    if (failedDocs.length > 0) {\n      console.warn(`${failedDocs.length} documentos fallaron al subirse:`, failedDocs);\n    }\n    \n    console.log(`Completado: ${uploadedDocs.length} documentos subidos exitosamente`);\n    return uploadedDocs;\n  } catch (error) {\n    console.error('Error general en uploadClientDocuments:', error);\n    throw createAppError(\n      ErrorType.UPLOAD,\n      error instanceof Error ? error.message : 'Error al subir documentos',\n      { clientId, error }\n    );\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}