{"ast":null,"code":"import{TABLES}from'../utils/constants/tables';import{APPLICATION_STATUS}from'../utils/constants/statuses';// Verify if APPLICATION_HISTORY table is defined in TABLES\nlet APPLICATION_HISTORY_TABLE=TABLES.APPLICATION_HISTORY;if(!APPLICATION_HISTORY_TABLE){// If not defined, create a fallback\nAPPLICATION_HISTORY_TABLE='application_history';}// Define the type of application statuses\n// Define application interface\n// Función para ejecutar consultas SQL a través del servidor MCP\nconst executeQuery=async query=>{try{const response=await fetch('http://localhost:3100/query',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({query})});const result=await response.json();if(result.error){console.error('Error en la consulta SQL:',result.error);throw new Error(result.error);}return result.data;}catch(error){console.error('Error ejecutando la consulta:',error);throw error;}};// Get all applications with filters\nexport const getApplications=async(filters,entityFilter)=>{let query=`SELECT * FROM ${TABLES.APPLICATIONS} WHERE 1=1`;// Aplicar filtro por entidad (asesor o empresa)\nif(entityFilter){if(entityFilter.advisor_id){query+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){query+=` AND company_id = '${entityFilter.company_id}'`;}}// Aplicar otros filtros\nif(filters){// Filter by status\nif(filters.status&&filters.status!=='all'){query+=` AND status = '${filters.status}'`;}// Filter by application type\nif(filters.application_type&&filters.application_type!=='all'){query+=` AND application_type = '${filters.application_type}'`;}// Filter by advisor\nif(filters.advisor_id){query+=` AND assigned_to = '${filters.advisor_id}'`;}// Filter by company\nif(filters.company_id){query+=` AND company_id = '${filters.company_id}'`;}// Filter by date range\nif(filters.dateFrom){query+=` AND created_at >= '${filters.dateFrom}'`;}if(filters.dateTo){query+=` AND created_at <= '${filters.dateTo}'`;}// Filter by amount range\nif(filters.amountMin!==undefined){query+=` AND amount >= ${filters.amountMin}`;}if(filters.amountMax!==undefined){query+=` AND amount <= ${filters.amountMax}`;}// Search by name, email or phone (ajustado a los campos reales)\nif(filters.searchQuery){query+=` AND (\n        client_name ILIKE '%${filters.searchQuery}%' OR \n        client_email ILIKE '%${filters.searchQuery}%'\n      )`;}}// Ordenar por fecha de creación más reciente\nquery+=` ORDER BY created_at DESC`;try{const data=await executeQuery(query);// Mapear los campos de la BD a nuestra interfaz\nreturn data.map(app=>({id:app.id,client_id:app.source_id||\"\",company_id:app.company_id||\"\",assigned_to:app.assigned_to||\"\",product_type:app.application_type||\"\",requested_amount:parseFloat(app.amount)||0,status:mapStatusFromDB(app.status),created_at:app.created_at,updated_at:app.updated_at,client_name:app.client_name,client_email:app.client_email,company_name:app.company_name,advisor_name:\"\",// Este campo no está en la BD\napproved_by_advisor:app.approved_by_advisor||false,approved_by_company:app.approved_by_company||false,approval_date_advisor:app.approval_date_advisor,approval_date_company:app.approval_date_company,// Mapeo directo de campos adicionales de la BD\nclient_phone:app.client_phone,client_address:app.client_address,dni:app.dni,amount:parseFloat(app.amount)||0,term:app.term?parseInt(app.term):undefined,interest_rate:app.interest_rate?parseFloat(app.interest_rate):undefined,monthly_payment:app.monthly_payment?parseFloat(app.monthly_payment):undefined,application_type:app.application_type}));}catch(error){console.error('Error fetching applications:',error);throw error;}};// Función auxiliar para mapear estados de la BD a nuestro enum\nconst mapStatusFromDB=dbStatus=>{// Primero verificamos si coincide con algún enum directamente\nconst directMapping=Object.values(APPLICATION_STATUS).find(status=>status.toLowerCase()===dbStatus.toLowerCase());if(directMapping){return directMapping;}// Si no hay coincidencia directa, usamos un mapeo manual\nconst statusMap={'Solicitud':APPLICATION_STATUS.SOLICITUD,'Pendiente':APPLICATION_STATUS.PENDING,'En Revisión':APPLICATION_STATUS.IN_REVIEW,'Revisión':APPLICATION_STATUS.IN_REVIEW,'Aprobado':APPLICATION_STATUS.APPROVED,'Rechazado':APPLICATION_STATUS.REJECTED,'Por Dispersar':APPLICATION_STATUS.POR_DISPERSAR,'Completado':APPLICATION_STATUS.COMPLETED,'Cancelado':APPLICATION_STATUS.CANCELLED,'Expirado':APPLICATION_STATUS.EXPIRED};console.log(`Mapeando estado desde BD: \"${dbStatus}\" -> \"${statusMap[dbStatus]||APPLICATION_STATUS.PENDING}\"`);return statusMap[dbStatus]||APPLICATION_STATUS.PENDING;};// Get a single application by ID\nexport const getApplicationById=async(id,entityFilter)=>{let query=`SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;// Aplicar filtro por entidad si es necesario\nif(entityFilter){if(entityFilter.advisor_id){query+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){query+=` AND company_id = '${entityFilter.company_id}'`;}}try{const data=await executeQuery(query);if(data&&data.length>0){return data[0];}throw new Error('Application not found');}catch(error){console.error(`Error fetching application with ID ${id}:`,error);throw error;}};// Create a new application\nexport const createApplication=async application=>{const fields=Object.keys(application).join(', ');const values=Object.values(application).map(val=>typeof val==='string'?`'${val}'`:val).join(', ');const query=`\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;try{const data=await executeQuery(query);return data[0];}catch(error){console.error('Error creating application:',error);throw error;}};// Update an existing application\nexport const updateApplication=async(id,updates,entityFilter)=>{const setClause=Object.entries(updates).map(_ref=>{let[key,value]=_ref;return`${key} = ${typeof value==='string'?`'${value}'`:value}`;}).join(', ');let query=`\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;// Aplicar filtro por entidad si es necesario\nif(entityFilter){if(entityFilter.advisor_id){query+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){query+=` AND company_id = '${entityFilter.company_id}'`;}}query+=' RETURNING *';try{const data=await executeQuery(query);if(data&&data.length>0){return data[0];}throw new Error('Application not found or you do not have permission to update it');}catch(error){console.error(`Error updating application with ID ${id}:`,error);throw error;}};// Update application status and add to history\nexport const updateApplicationStatus=async(id,status,comment,user_id,entityFilter)=>{// 1. Obtener estado actual de la aplicación\nlet currentQuery=`\n    SELECT status FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;// Aplicar filtro por entidad si es necesario\nif(entityFilter){if(entityFilter.advisor_id){currentQuery+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){currentQuery+=` AND company_id = '${entityFilter.company_id}'`;}}try{// Obtener el estado actual\nconst currentState=await executeQuery(currentQuery);if(!currentState||currentState.length===0){throw new Error('Application not found or you do not have permission to update it');}const currentStatus=currentState[0].status;// 2. Actualizar el estado de la aplicación\nlet updateQuery=`\n      UPDATE ${TABLES.APPLICATIONS}\n      SET status = '${status}',\n          status_previous = '${currentStatus}'\n    `;// Si el nuevo estado es \"completed\", actualizar la fecha de dispersión\nif(status==='completed'){updateQuery+=`, dispersal_date = NOW()`;}updateQuery+=` WHERE id = '${id}'`;// Aplicar filtro por entidad si es necesario\nif(entityFilter){if(entityFilter.advisor_id){updateQuery+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){updateQuery+=` AND company_id = '${entityFilter.company_id}'`;}}updateQuery+=' RETURNING *';// Ejecutar la actualización\nconst updatedApp=await executeQuery(updateQuery);if(!updatedApp||updatedApp.length===0){throw new Error('Application not found or you do not have permission to update it');}// 3. Añadir al historial\nconst historyComment=currentStatus!==status?`${comment} (Cambio de estado: ${currentStatus} → ${status})`:comment;const historyQuery=`\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', '${status}', '${historyComment}', '${user_id}')\n      RETURNING *\n    `;await executeQuery(historyQuery);console.log(`Estado de aplicación actualizado: ${currentStatus} → ${status}`);return updatedApp[0];}catch(error){console.error(`Error updating status of application ${id}:`,error);throw error;}};// Aprobar solicitud por asesor\nexport const approveByAdvisor=async(id,comment,advisor_id,entityFilter)=>{// Verificar que el usuario es realmente un asesor\nif(!(entityFilter!==null&&entityFilter!==void 0&&entityFilter.advisor_id)){throw new Error('Solo los asesores pueden realizar esta acción');}// Actualizar la solicitud\nlet updateQuery=`\n    UPDATE ${TABLES.APPLICATIONS}\n    SET approved_by_advisor = true, \n        approval_date_advisor = NOW()\n    WHERE id = '${id}' AND assigned_to = '${advisor_id}'\n    RETURNING *\n  `;try{// Ejecutar la actualización\nconst updatedApp=await executeQuery(updateQuery);if(!updatedApp||updatedApp.length===0){throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');}// Añadir al historial\nconst historyQuery=`\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', 'approved_by_advisor', '${comment}', '${advisor_id}')\n      RETURNING *\n    `;await executeQuery(historyQuery);// Verificar si ambas aprobaciones están completas, para actualizar el estado principal\nconst app=updatedApp[0];if(app.approved_by_advisor&&app.approved_by_company&&app.status!=='approved'){console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");// Si ambos han aprobado, actualizar el estado a aprobado\nreturn await updateApplicationStatus(id,'approved','Aprobación completa: Asesor y Empresa han aprobado esta solicitud',advisor_id,entityFilter);}return app;}catch(error){console.error(`Error aprobando solicitud ${id} por asesor:`,error);throw error;}};// Aprobar solicitud por empresa\nexport const approveByCompany=async(id,comment,company_admin_id,company_id,entityFilter)=>{// Verificar que el usuario es realmente un administrador de la empresa correcta\nif(!(entityFilter!==null&&entityFilter!==void 0&&entityFilter.company_id)||entityFilter.company_id!==company_id){throw new Error('Solo los administradores de la empresa pueden realizar esta acción');}// Actualizar la solicitud\nlet updateQuery=`\n    UPDATE ${TABLES.APPLICATIONS}\n    SET approved_by_company = true, \n        approval_date_company = NOW()\n    WHERE id = '${id}' AND company_id = '${company_id}'\n    RETURNING *\n  `;try{// Ejecutar la actualización\nconst updatedApp=await executeQuery(updateQuery);if(!updatedApp||updatedApp.length===0){throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');}// Añadir al historial\nconst historyQuery=`\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', 'approved_by_company', '${comment}', '${company_admin_id}')\n      RETURNING *\n    `;await executeQuery(historyQuery);// Verificar si ambas aprobaciones están completas, para actualizar el estado principal\nconst app=updatedApp[0];if(app.approved_by_advisor&&app.approved_by_company&&app.status!=='approved'){console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");// Si ambos han aprobado, actualizar el estado a aprobado\nreturn await updateApplicationStatus(id,'approved','Aprobación completa: Asesor y Empresa han aprobado esta solicitud',company_admin_id,entityFilter);}return app;}catch(error){console.error(`Error aprobando solicitud ${id} por empresa:`,error);throw error;}};// Obtener estado de aprobación de una solicitud\nexport const getApprovalStatus=async(id,entityFilter)=>{let query=`\n    SELECT \n      approved_by_advisor, \n      approved_by_company, \n      approval_date_advisor, \n      approval_date_company\n    FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;// Aplicar filtro por entidad si es necesario\nif(entityFilter){if(entityFilter.advisor_id){query+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){query+=` AND company_id = '${entityFilter.company_id}'`;}}try{const data=await executeQuery(query);if(data&&data.length>0){return{approvedByAdvisor:data[0].approved_by_advisor||false,approvedByCompany:data[0].approved_by_company||false,approvalDateAdvisor:data[0].approval_date_advisor,approvalDateCompany:data[0].approval_date_company};}throw new Error('Solicitud no encontrada');}catch(error){console.error(`Error obteniendo estado de aprobación para solicitud ${id}:`,error);throw error;}};// Delete an application\nexport const deleteApplication=async(id,entityFilter)=>{let query=`DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;// Aplicar filtro por entidad si es necesario\nif(entityFilter){if(entityFilter.advisor_id){query+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){query+=` AND company_id = '${entityFilter.company_id}'`;}}try{await executeQuery(query);return true;}catch(error){console.error(`Error deleting application with ID ${id}:`,error);throw error;}};// Get application history\nexport const getApplicationHistory=async(applicationId,entityFilter)=>{// Verificar primero si el usuario tiene permiso para ver esta aplicación\nif(entityFilter){let appQuery=`\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;if(entityFilter.advisor_id){appQuery+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){appQuery+=` AND company_id = '${entityFilter.company_id}'`;}const app=await executeQuery(appQuery);if(!app||app.length===0){throw new Error('Application not found or you do not have permission to view it');}}const query=`\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${APPLICATION_HISTORY_TABLE} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;try{return await executeQuery(query);}catch(error){console.error(`Error fetching history for application ${applicationId}:`,error);throw error;}};// Add a comment to an application\nexport const addComment=async(applicationId,userId,text,entityFilter)=>{// Verificar primero si el usuario tiene permiso para comentar esta aplicación\nif(entityFilter){let appQuery=`\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;if(entityFilter.advisor_id){appQuery+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){appQuery+=` AND company_id = '${entityFilter.company_id}'`;}const app=await executeQuery(appQuery);if(!app||app.length===0){throw new Error('Application not found or you do not have permission to comment on it');}}const query=`\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;try{const data=await executeQuery(query);return data[0];}catch(error){console.error(`Error adding comment to application ${applicationId}:`,error);throw error;}};// Get comments for an application\nexport const getComments=async(applicationId,entityFilter)=>{// Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\nif(entityFilter){let appQuery=`\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;if(entityFilter.advisor_id){appQuery+=` AND assigned_to = '${entityFilter.advisor_id}'`;}if(entityFilter.company_id){appQuery+=` AND company_id = '${entityFilter.company_id}'`;}const app=await executeQuery(appQuery);if(!app||app.length===0){throw new Error('Application not found or you do not have permission to view its comments');}}const query=`\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;try{return await executeQuery(query);}catch(error){console.error(`Error fetching comments for application ${applicationId}:`,error);throw error;}};","map":{"version":3,"names":["TABLES","APPLICATION_STATUS","APPLICATION_HISTORY_TABLE","APPLICATION_HISTORY","executeQuery","query","response","fetch","method","headers","body","JSON","stringify","result","json","error","console","Error","data","getApplications","filters","entityFilter","APPLICATIONS","advisor_id","company_id","status","application_type","dateFrom","dateTo","amountMin","undefined","amountMax","searchQuery","map","app","id","client_id","source_id","assigned_to","product_type","requested_amount","parseFloat","amount","mapStatusFromDB","created_at","updated_at","client_name","client_email","company_name","advisor_name","approved_by_advisor","approved_by_company","approval_date_advisor","approval_date_company","client_phone","client_address","dni","term","parseInt","interest_rate","monthly_payment","dbStatus","directMapping","Object","values","find","toLowerCase","statusMap","SOLICITUD","PENDING","IN_REVIEW","APPROVED","REJECTED","POR_DISPERSAR","COMPLETED","CANCELLED","EXPIRED","log","getApplicationById","length","createApplication","application","fields","keys","join","val","updateApplication","updates","setClause","entries","_ref","key","value","updateApplicationStatus","comment","user_id","currentQuery","currentState","currentStatus","updateQuery","updatedApp","historyComment","historyQuery","approveByAdvisor","approveByCompany","company_admin_id","getApprovalStatus","approvedByAdvisor","approvedByCompany","approvalDateAdvisor","approvalDateCompany","deleteApplication","getApplicationHistory","applicationId","appQuery","addComment","userId","text","COMMENTS","getComments"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/applicationService.ts"],"sourcesContent":["import { TABLES } from '../utils/constants/tables';\nimport { APPLICATION_STATUS } from '../utils/constants/statuses';\n\n// Verify if APPLICATION_HISTORY table is defined in TABLES\nlet APPLICATION_HISTORY_TABLE = TABLES.APPLICATION_HISTORY;\nif (!APPLICATION_HISTORY_TABLE) {\n  // If not defined, create a fallback\n  APPLICATION_HISTORY_TABLE = 'application_history';\n}\n\n// Define the type of application statuses\nexport type ApplicationStatus = 'pending' | 'in_review' | 'approved' | 'rejected' | 'cancelled' | 'expired' | 'completed' | 'solicitud' | 'new' | 'por_dispersar';\n\n// Define application interface\nexport interface Application {\n  id: string;\n  client_id: string;\n  company_id: string;\n  assigned_to: string;\n  product_type: string;\n  requested_amount: number;\n  status: ApplicationStatus;\n  status_previous?: string;\n  created_at: string;\n  updated_at: string;\n  client_name?: string;\n  client_email?: string;\n  company_name?: string;\n  advisor_name?: string;\n  approved_by_advisor: boolean;\n  approved_by_company: boolean;\n  approval_date_advisor?: string;\n  approval_date_company?: string;\n  dispersal_date?: string;\n  \n  // Campos adicionales que necesitan los formularios\n  client_phone?: string;\n  client_address?: string;\n  dni?: string;\n  amount?: number;\n  term?: number;\n  interest_rate?: number;\n  monthly_payment?: number;\n  application_type?: string;\n}\n\nexport interface ApplicationFilter {\n  status?: string;\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n  application_type?: string;\n  amountMin?: number;\n  amountMax?: number;\n}\n\n// Función para ejecutar consultas SQL a través del servidor MCP\nconst executeQuery = async (query: string) => {\n  try {\n    const response = await fetch('http://localhost:3100/query', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ query }),\n    });\n    \n    const result = await response.json();\n    \n    if (result.error) {\n      console.error('Error en la consulta SQL:', result.error);\n      throw new Error(result.error);\n    }\n    \n    return result.data;\n  } catch (error) {\n    console.error('Error ejecutando la consulta:', error);\n    throw error;\n  }\n};\n\n// Get all applications with filters\nexport const getApplications = async (filters?: ApplicationFilter, entityFilter?: Record<string, any> | null) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE 1=1`;\n  \n  // Aplicar filtro por entidad (asesor o empresa)\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n\n  // Aplicar otros filtros\n  if (filters) {\n    // Filter by status\n    if (filters.status && filters.status !== 'all') {\n      query += ` AND status = '${filters.status}'`;\n    }\n\n    // Filter by application type\n    if (filters.application_type && filters.application_type !== 'all') {\n      query += ` AND application_type = '${filters.application_type}'`;\n    }\n\n    // Filter by advisor\n    if (filters.advisor_id) {\n      query += ` AND assigned_to = '${filters.advisor_id}'`;\n    }\n\n    // Filter by company\n    if (filters.company_id) {\n      query += ` AND company_id = '${filters.company_id}'`;\n    }\n\n    // Filter by date range\n    if (filters.dateFrom) {\n      query += ` AND created_at >= '${filters.dateFrom}'`;\n    }\n\n    if (filters.dateTo) {\n      query += ` AND created_at <= '${filters.dateTo}'`;\n    }\n\n    // Filter by amount range\n    if (filters.amountMin !== undefined) {\n      query += ` AND amount >= ${filters.amountMin}`;\n    }\n\n    if (filters.amountMax !== undefined) {\n      query += ` AND amount <= ${filters.amountMax}`;\n    }\n\n    // Search by name, email or phone (ajustado a los campos reales)\n    if (filters.searchQuery) {\n      query += ` AND (\n        client_name ILIKE '%${filters.searchQuery}%' OR \n        client_email ILIKE '%${filters.searchQuery}%'\n      )`;\n    }\n  }\n\n  // Ordenar por fecha de creación más reciente\n  query += ` ORDER BY created_at DESC`;\n\n  try {\n    const data = await executeQuery(query);\n    \n    // Mapear los campos de la BD a nuestra interfaz\n    return data.map((app: any) => ({\n      id: app.id,\n      client_id: app.source_id || \"\",\n      company_id: app.company_id || \"\",\n      assigned_to: app.assigned_to || \"\",\n      product_type: app.application_type || \"\",\n      requested_amount: parseFloat(app.amount) || 0,\n      status: mapStatusFromDB(app.status),\n      created_at: app.created_at,\n      updated_at: app.updated_at,\n      client_name: app.client_name,\n      client_email: app.client_email,\n      company_name: app.company_name,\n      advisor_name: \"\", // Este campo no está en la BD\n      approved_by_advisor: app.approved_by_advisor || false,\n      approved_by_company: app.approved_by_company || false,\n      approval_date_advisor: app.approval_date_advisor,\n      approval_date_company: app.approval_date_company,\n      \n      // Mapeo directo de campos adicionales de la BD\n      client_phone: app.client_phone,\n      client_address: app.client_address,\n      dni: app.dni,\n      amount: parseFloat(app.amount) || 0,\n      term: app.term ? parseInt(app.term) : undefined,\n      interest_rate: app.interest_rate ? parseFloat(app.interest_rate) : undefined,\n      monthly_payment: app.monthly_payment ? parseFloat(app.monthly_payment) : undefined,\n      application_type: app.application_type\n    })) as Application[];\n  } catch (error) {\n    console.error('Error fetching applications:', error);\n    throw error;\n  }\n};\n\n// Función auxiliar para mapear estados de la BD a nuestro enum\nconst mapStatusFromDB = (dbStatus: string): ApplicationStatus => {\n  // Primero verificamos si coincide con algún enum directamente\n  const directMapping = Object.values(APPLICATION_STATUS).find(status => \n    status.toLowerCase() === dbStatus.toLowerCase()\n  );\n  \n  if (directMapping) {\n    return directMapping as ApplicationStatus;\n  }\n  \n  // Si no hay coincidencia directa, usamos un mapeo manual\n  const statusMap: Record<string, ApplicationStatus> = {\n    'Solicitud': APPLICATION_STATUS.SOLICITUD,\n    'Pendiente': APPLICATION_STATUS.PENDING,\n    'En Revisión': APPLICATION_STATUS.IN_REVIEW,\n    'Revisión': APPLICATION_STATUS.IN_REVIEW,\n    'Aprobado': APPLICATION_STATUS.APPROVED,\n    'Rechazado': APPLICATION_STATUS.REJECTED,\n    'Por Dispersar': APPLICATION_STATUS.POR_DISPERSAR,\n    'Completado': APPLICATION_STATUS.COMPLETED,\n    'Cancelado': APPLICATION_STATUS.CANCELLED,\n    'Expirado': APPLICATION_STATUS.EXPIRED\n  };\n  \n  console.log(`Mapeando estado desde BD: \"${dbStatus}\" -> \"${statusMap[dbStatus] || APPLICATION_STATUS.PENDING}\"`);\n  return statusMap[dbStatus] || APPLICATION_STATUS.PENDING;\n};\n\n// Get a single application by ID\nexport const getApplicationById = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found');\n  } catch (error) {\n    console.error(`Error fetching application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Create a new application\nexport const createApplication = async (application: Omit<Application, 'id' | 'created_at' | 'updated_at'>) => {\n  const fields = Object.keys(application).join(', ');\n  const values = Object.values(application)\n    .map(val => (typeof val === 'string' ? `'${val}'` : val))\n    .join(', ');\n  \n  const query = `\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0] as Application;\n  } catch (error) {\n    console.error('Error creating application:', error);\n    throw error;\n  }\n};\n\n// Update an existing application\nexport const updateApplication = async (id: string, updates: Partial<Application>, entityFilter?: Record<string, any> | null) => {\n  const setClause = Object.entries(updates)\n    .map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`)\n    .join(', ');\n  \n  let query = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  query += ' RETURNING *';\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found or you do not have permission to update it');\n  } catch (error) {\n    console.error(`Error updating application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Update application status and add to history\nexport const updateApplicationStatus = async (\n  id: string, \n  status: Application['status'], \n  comment: string, \n  user_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // 1. Obtener estado actual de la aplicación\n  let currentQuery = `\n    SELECT status FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      currentQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      currentQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    // Obtener el estado actual\n    const currentState = await executeQuery(currentQuery);\n    if (!currentState || currentState.length === 0) {\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    const currentStatus = currentState[0].status;\n    \n    // 2. Actualizar el estado de la aplicación\n    let updateQuery = `\n      UPDATE ${TABLES.APPLICATIONS}\n      SET status = '${status}',\n          status_previous = '${currentStatus}'\n    `;\n    \n    // Si el nuevo estado es \"completed\", actualizar la fecha de dispersión\n    if (status === 'completed') {\n      updateQuery += `, dispersal_date = NOW()`;\n    }\n    \n    updateQuery += ` WHERE id = '${id}'`;\n    \n    // Aplicar filtro por entidad si es necesario\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        updateQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n      }\n      if (entityFilter.company_id) {\n        updateQuery += ` AND company_id = '${entityFilter.company_id}'`;\n      }\n    }\n    \n    updateQuery += ' RETURNING *';\n    \n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    // 3. Añadir al historial\n    const historyComment = currentStatus !== status \n      ? `${comment} (Cambio de estado: ${currentStatus} → ${status})`\n      : comment;\n      \n    const historyQuery = `\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', '${status}', '${historyComment}', '${user_id}')\n      RETURNING *\n    `;\n    \n    await executeQuery(historyQuery);\n    \n    console.log(`Estado de aplicación actualizado: ${currentStatus} → ${status}`);\n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`Error updating status of application ${id}:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por asesor\nexport const approveByAdvisor = async (\n  id: string,\n  comment: string,\n  advisor_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un asesor\n  if (!entityFilter?.advisor_id) {\n    throw new Error('Solo los asesores pueden realizar esta acción');\n  }\n  \n  // Actualizar la solicitud\n  let updateQuery = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET approved_by_advisor = true, \n        approval_date_advisor = NOW()\n    WHERE id = '${id}' AND assigned_to = '${advisor_id}'\n    RETURNING *\n  `;\n  \n  try {\n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    // Añadir al historial\n    const historyQuery = `\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', 'approved_by_advisor', '${comment}', '${advisor_id}')\n      RETURNING *\n    `;\n    \n    await executeQuery(historyQuery);\n    \n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0] as Application;\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'approved') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");\n      \n      // Si ambos han aprobado, actualizar el estado a aprobado\n      return await updateApplicationStatus(\n        id, \n        'approved', \n        'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', \n        advisor_id,\n        entityFilter\n      );\n    }\n    \n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por empresa\nexport const approveByCompany = async (\n  id: string,\n  comment: string,\n  company_admin_id: string,\n  company_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!entityFilter?.company_id || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  \n  // Actualizar la solicitud\n  let updateQuery = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET approved_by_company = true, \n        approval_date_company = NOW()\n    WHERE id = '${id}' AND company_id = '${company_id}'\n    RETURNING *\n  `;\n  \n  try {\n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    // Añadir al historial\n    const historyQuery = `\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', 'approved_by_company', '${comment}', '${company_admin_id}')\n      RETURNING *\n    `;\n    \n    await executeQuery(historyQuery);\n    \n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0] as Application;\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'approved') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");\n      \n      // Si ambos han aprobado, actualizar el estado a aprobado\n      return await updateApplicationStatus(\n        id, \n        'approved', \n        'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', \n        company_admin_id,\n        entityFilter\n      );\n    }\n    \n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Obtener estado de aprobación de una solicitud\nexport const getApprovalStatus = async (\n  id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  let query = `\n    SELECT \n      approved_by_advisor, \n      approved_by_company, \n      approval_date_advisor, \n      approval_date_company\n    FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return {\n        approvedByAdvisor: data[0].approved_by_advisor || false,\n        approvedByCompany: data[0].approved_by_company || false,\n        approvalDateAdvisor: data[0].approval_date_advisor,\n        approvalDateCompany: data[0].approval_date_company\n      };\n    }\n    throw new Error('Solicitud no encontrada');\n  } catch (error) {\n    console.error(`Error obteniendo estado de aprobación para solicitud ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete an application\nexport const deleteApplication = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    await executeQuery(query);\n    return true;\n  } catch (error) {\n    console.error(`Error deleting application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Get application history\nexport const getApplicationHistory = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view it');\n    }\n  }\n  \n  const query = `\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${APPLICATION_HISTORY_TABLE} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching history for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Add a comment to an application\nexport const addComment = async (applicationId: string, userId: string, text: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para comentar esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to comment on it');\n    }\n  }\n  \n  const query = `\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error(`Error adding comment to application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Get comments for an application\nexport const getComments = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view its comments');\n    }\n  }\n  \n  const query = `\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching comments for application ${applicationId}:`, error);\n    throw error;\n  }\n}; "],"mappings":"AAAA,OAASA,MAAM,KAAQ,2BAA2B,CAClD,OAASC,kBAAkB,KAAQ,6BAA6B,CAEhE;AACA,GAAI,CAAAC,yBAAyB,CAAGF,MAAM,CAACG,mBAAmB,CAC1D,GAAI,CAACD,yBAAyB,CAAE,CAC9B;AACAA,yBAAyB,CAAG,qBAAqB,CACnD,CAEA;AAGA;AA6CA;AACA,KAAM,CAAAE,YAAY,CAAG,KAAO,CAAAC,KAAa,EAAK,CAC5C,GAAI,CACF,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAC,KAAK,CAAC,6BAA6B,CAAE,CAC1DC,MAAM,CAAE,MAAM,CACdC,OAAO,CAAE,CACP,cAAc,CAAE,kBAClB,CAAC,CACDC,IAAI,CAAEC,IAAI,CAACC,SAAS,CAAC,CAAEP,KAAM,CAAC,CAChC,CAAC,CAAC,CAEF,KAAM,CAAAQ,MAAM,CAAG,KAAM,CAAAP,QAAQ,CAACQ,IAAI,CAAC,CAAC,CAEpC,GAAID,MAAM,CAACE,KAAK,CAAE,CAChBC,OAAO,CAACD,KAAK,CAAC,2BAA2B,CAAEF,MAAM,CAACE,KAAK,CAAC,CACxD,KAAM,IAAI,CAAAE,KAAK,CAACJ,MAAM,CAACE,KAAK,CAAC,CAC/B,CAEA,MAAO,CAAAF,MAAM,CAACK,IAAI,CACpB,CAAE,MAAOH,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,CAAEA,KAAK,CAAC,CACrD,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAI,eAAe,CAAG,KAAAA,CAAOC,OAA2B,CAAEC,YAAyC,GAAK,CAC/G,GAAI,CAAAhB,KAAK,CAAG,iBAAiBL,MAAM,CAACsB,YAAY,YAAY,CAE5D;AACA,GAAID,YAAY,CAAE,CAChB,GAAIA,YAAY,CAACE,UAAU,CAAE,CAC3BlB,KAAK,EAAI,uBAAuBgB,YAAY,CAACE,UAAU,GAAG,CAC5D,CACA,GAAIF,YAAY,CAACG,UAAU,CAAE,CAC3BnB,KAAK,EAAI,sBAAsBgB,YAAY,CAACG,UAAU,GAAG,CAC3D,CACF,CAEA;AACA,GAAIJ,OAAO,CAAE,CACX;AACA,GAAIA,OAAO,CAACK,MAAM,EAAIL,OAAO,CAACK,MAAM,GAAK,KAAK,CAAE,CAC9CpB,KAAK,EAAI,kBAAkBe,OAAO,CAACK,MAAM,GAAG,CAC9C,CAEA;AACA,GAAIL,OAAO,CAACM,gBAAgB,EAAIN,OAAO,CAACM,gBAAgB,GAAK,KAAK,CAAE,CAClErB,KAAK,EAAI,4BAA4Be,OAAO,CAACM,gBAAgB,GAAG,CAClE,CAEA;AACA,GAAIN,OAAO,CAACG,UAAU,CAAE,CACtBlB,KAAK,EAAI,uBAAuBe,OAAO,CAACG,UAAU,GAAG,CACvD,CAEA;AACA,GAAIH,OAAO,CAACI,UAAU,CAAE,CACtBnB,KAAK,EAAI,sBAAsBe,OAAO,CAACI,UAAU,GAAG,CACtD,CAEA;AACA,GAAIJ,OAAO,CAACO,QAAQ,CAAE,CACpBtB,KAAK,EAAI,uBAAuBe,OAAO,CAACO,QAAQ,GAAG,CACrD,CAEA,GAAIP,OAAO,CAACQ,MAAM,CAAE,CAClBvB,KAAK,EAAI,uBAAuBe,OAAO,CAACQ,MAAM,GAAG,CACnD,CAEA;AACA,GAAIR,OAAO,CAACS,SAAS,GAAKC,SAAS,CAAE,CACnCzB,KAAK,EAAI,kBAAkBe,OAAO,CAACS,SAAS,EAAE,CAChD,CAEA,GAAIT,OAAO,CAACW,SAAS,GAAKD,SAAS,CAAE,CACnCzB,KAAK,EAAI,kBAAkBe,OAAO,CAACW,SAAS,EAAE,CAChD,CAEA;AACA,GAAIX,OAAO,CAACY,WAAW,CAAE,CACvB3B,KAAK,EAAI;AACf,8BAA8Be,OAAO,CAACY,WAAW;AACjD,+BAA+BZ,OAAO,CAACY,WAAW;AAClD,QAAQ,CACJ,CACF,CAEA;AACA3B,KAAK,EAAI,2BAA2B,CAEpC,GAAI,CACF,KAAM,CAAAa,IAAI,CAAG,KAAM,CAAAd,YAAY,CAACC,KAAK,CAAC,CAEtC;AACA,MAAO,CAAAa,IAAI,CAACe,GAAG,CAAEC,GAAQ,GAAM,CAC7BC,EAAE,CAAED,GAAG,CAACC,EAAE,CACVC,SAAS,CAAEF,GAAG,CAACG,SAAS,EAAI,EAAE,CAC9Bb,UAAU,CAAEU,GAAG,CAACV,UAAU,EAAI,EAAE,CAChCc,WAAW,CAAEJ,GAAG,CAACI,WAAW,EAAI,EAAE,CAClCC,YAAY,CAAEL,GAAG,CAACR,gBAAgB,EAAI,EAAE,CACxCc,gBAAgB,CAAEC,UAAU,CAACP,GAAG,CAACQ,MAAM,CAAC,EAAI,CAAC,CAC7CjB,MAAM,CAAEkB,eAAe,CAACT,GAAG,CAACT,MAAM,CAAC,CACnCmB,UAAU,CAAEV,GAAG,CAACU,UAAU,CAC1BC,UAAU,CAAEX,GAAG,CAACW,UAAU,CAC1BC,WAAW,CAAEZ,GAAG,CAACY,WAAW,CAC5BC,YAAY,CAAEb,GAAG,CAACa,YAAY,CAC9BC,YAAY,CAAEd,GAAG,CAACc,YAAY,CAC9BC,YAAY,CAAE,EAAE,CAAE;AAClBC,mBAAmB,CAAEhB,GAAG,CAACgB,mBAAmB,EAAI,KAAK,CACrDC,mBAAmB,CAAEjB,GAAG,CAACiB,mBAAmB,EAAI,KAAK,CACrDC,qBAAqB,CAAElB,GAAG,CAACkB,qBAAqB,CAChDC,qBAAqB,CAAEnB,GAAG,CAACmB,qBAAqB,CAEhD;AACAC,YAAY,CAAEpB,GAAG,CAACoB,YAAY,CAC9BC,cAAc,CAAErB,GAAG,CAACqB,cAAc,CAClCC,GAAG,CAAEtB,GAAG,CAACsB,GAAG,CACZd,MAAM,CAAED,UAAU,CAACP,GAAG,CAACQ,MAAM,CAAC,EAAI,CAAC,CACnCe,IAAI,CAAEvB,GAAG,CAACuB,IAAI,CAAGC,QAAQ,CAACxB,GAAG,CAACuB,IAAI,CAAC,CAAG3B,SAAS,CAC/C6B,aAAa,CAAEzB,GAAG,CAACyB,aAAa,CAAGlB,UAAU,CAACP,GAAG,CAACyB,aAAa,CAAC,CAAG7B,SAAS,CAC5E8B,eAAe,CAAE1B,GAAG,CAAC0B,eAAe,CAAGnB,UAAU,CAACP,GAAG,CAAC0B,eAAe,CAAC,CAAG9B,SAAS,CAClFJ,gBAAgB,CAAEQ,GAAG,CAACR,gBACxB,CAAC,CAAC,CAAC,CACL,CAAE,MAAOX,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,8BAA8B,CAAEA,KAAK,CAAC,CACpD,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACA,KAAM,CAAA4B,eAAe,CAAIkB,QAAgB,EAAwB,CAC/D;AACA,KAAM,CAAAC,aAAa,CAAGC,MAAM,CAACC,MAAM,CAAC/D,kBAAkB,CAAC,CAACgE,IAAI,CAACxC,MAAM,EACjEA,MAAM,CAACyC,WAAW,CAAC,CAAC,GAAKL,QAAQ,CAACK,WAAW,CAAC,CAChD,CAAC,CAED,GAAIJ,aAAa,CAAE,CACjB,MAAO,CAAAA,aAAa,CACtB,CAEA;AACA,KAAM,CAAAK,SAA4C,CAAG,CACnD,WAAW,CAAElE,kBAAkB,CAACmE,SAAS,CACzC,WAAW,CAAEnE,kBAAkB,CAACoE,OAAO,CACvC,aAAa,CAAEpE,kBAAkB,CAACqE,SAAS,CAC3C,UAAU,CAAErE,kBAAkB,CAACqE,SAAS,CACxC,UAAU,CAAErE,kBAAkB,CAACsE,QAAQ,CACvC,WAAW,CAAEtE,kBAAkB,CAACuE,QAAQ,CACxC,eAAe,CAAEvE,kBAAkB,CAACwE,aAAa,CACjD,YAAY,CAAExE,kBAAkB,CAACyE,SAAS,CAC1C,WAAW,CAAEzE,kBAAkB,CAAC0E,SAAS,CACzC,UAAU,CAAE1E,kBAAkB,CAAC2E,OACjC,CAAC,CAED5D,OAAO,CAAC6D,GAAG,CAAC,8BAA8BhB,QAAQ,SAASM,SAAS,CAACN,QAAQ,CAAC,EAAI5D,kBAAkB,CAACoE,OAAO,GAAG,CAAC,CAChH,MAAO,CAAAF,SAAS,CAACN,QAAQ,CAAC,EAAI5D,kBAAkB,CAACoE,OAAO,CAC1D,CAAC,CAED;AACA,MAAO,MAAM,CAAAS,kBAAkB,CAAG,KAAAA,CAAO3C,EAAU,CAAEd,YAAyC,GAAK,CACjG,GAAI,CAAAhB,KAAK,CAAG,iBAAiBL,MAAM,CAACsB,YAAY,gBAAgBa,EAAE,GAAG,CAErE;AACA,GAAId,YAAY,CAAE,CAChB,GAAIA,YAAY,CAACE,UAAU,CAAE,CAC3BlB,KAAK,EAAI,uBAAuBgB,YAAY,CAACE,UAAU,GAAG,CAC5D,CACA,GAAIF,YAAY,CAACG,UAAU,CAAE,CAC3BnB,KAAK,EAAI,sBAAsBgB,YAAY,CAACG,UAAU,GAAG,CAC3D,CACF,CAEA,GAAI,CACF,KAAM,CAAAN,IAAI,CAAG,KAAM,CAAAd,YAAY,CAACC,KAAK,CAAC,CACtC,GAAIa,IAAI,EAAIA,IAAI,CAAC6D,MAAM,CAAG,CAAC,CAAE,CAC3B,MAAO,CAAA7D,IAAI,CAAC,CAAC,CAAC,CAChB,CACA,KAAM,IAAI,CAAAD,KAAK,CAAC,uBAAuB,CAAC,CAC1C,CAAE,MAAOF,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,sCAAsCoB,EAAE,GAAG,CAAEpB,KAAK,CAAC,CACjE,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAiE,iBAAiB,CAAG,KAAO,CAAAC,WAAkE,EAAK,CAC7G,KAAM,CAAAC,MAAM,CAAGnB,MAAM,CAACoB,IAAI,CAACF,WAAW,CAAC,CAACG,IAAI,CAAC,IAAI,CAAC,CAClD,KAAM,CAAApB,MAAM,CAAGD,MAAM,CAACC,MAAM,CAACiB,WAAW,CAAC,CACtChD,GAAG,CAACoD,GAAG,EAAK,MAAO,CAAAA,GAAG,GAAK,QAAQ,CAAG,IAAIA,GAAG,GAAG,CAAGA,GAAI,CAAC,CACxDD,IAAI,CAAC,IAAI,CAAC,CAEb,KAAM,CAAA/E,KAAK,CAAG;AAChB,kBAAkBL,MAAM,CAACsB,YAAY,KAAK4D,MAAM;AAChD,cAAclB,MAAM;AACpB;AACA,GAAG,CAED,GAAI,CACF,KAAM,CAAA9C,IAAI,CAAG,KAAM,CAAAd,YAAY,CAACC,KAAK,CAAC,CACtC,MAAO,CAAAa,IAAI,CAAC,CAAC,CAAC,CAChB,CAAE,MAAOH,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,6BAA6B,CAAEA,KAAK,CAAC,CACnD,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAuE,iBAAiB,CAAG,KAAAA,CAAOnD,EAAU,CAAEoD,OAA6B,CAAElE,YAAyC,GAAK,CAC/H,KAAM,CAAAmE,SAAS,CAAGzB,MAAM,CAAC0B,OAAO,CAACF,OAAO,CAAC,CACtCtD,GAAG,CAACyD,IAAA,MAAC,CAACC,GAAG,CAAEC,KAAK,CAAC,CAAAF,IAAA,OAAK,GAAGC,GAAG,MAAM,MAAO,CAAAC,KAAK,GAAK,QAAQ,CAAG,IAAIA,KAAK,GAAG,CAAGA,KAAK,EAAE,GAAC,CACrFR,IAAI,CAAC,IAAI,CAAC,CAEb,GAAI,CAAA/E,KAAK,CAAG;AACd,aAAaL,MAAM,CAACsB,YAAY;AAChC,UAAUkE,SAAS;AACnB,kBAAkBrD,EAAE;AACpB,GAAG,CAED;AACA,GAAId,YAAY,CAAE,CAChB,GAAIA,YAAY,CAACE,UAAU,CAAE,CAC3BlB,KAAK,EAAI,uBAAuBgB,YAAY,CAACE,UAAU,GAAG,CAC5D,CACA,GAAIF,YAAY,CAACG,UAAU,CAAE,CAC3BnB,KAAK,EAAI,sBAAsBgB,YAAY,CAACG,UAAU,GAAG,CAC3D,CACF,CAEAnB,KAAK,EAAI,cAAc,CAEvB,GAAI,CACF,KAAM,CAAAa,IAAI,CAAG,KAAM,CAAAd,YAAY,CAACC,KAAK,CAAC,CACtC,GAAIa,IAAI,EAAIA,IAAI,CAAC6D,MAAM,CAAG,CAAC,CAAE,CAC3B,MAAO,CAAA7D,IAAI,CAAC,CAAC,CAAC,CAChB,CACA,KAAM,IAAI,CAAAD,KAAK,CAAC,kEAAkE,CAAC,CACrF,CAAE,MAAOF,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,sCAAsCoB,EAAE,GAAG,CAAEpB,KAAK,CAAC,CACjE,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAA8E,uBAAuB,CAAG,KAAAA,CACrC1D,EAAU,CACVV,MAA6B,CAC7BqE,OAAe,CACfC,OAAe,CACf1E,YAAyC,GACtC,CACH;AACA,GAAI,CAAA2E,YAAY,CAAG;AACrB,yBAAyBhG,MAAM,CAACsB,YAAY;AAC5C,kBAAkBa,EAAE;AACpB,GAAG,CAED;AACA,GAAId,YAAY,CAAE,CAChB,GAAIA,YAAY,CAACE,UAAU,CAAE,CAC3ByE,YAAY,EAAI,uBAAuB3E,YAAY,CAACE,UAAU,GAAG,CACnE,CACA,GAAIF,YAAY,CAACG,UAAU,CAAE,CAC3BwE,YAAY,EAAI,sBAAsB3E,YAAY,CAACG,UAAU,GAAG,CAClE,CACF,CAEA,GAAI,CACF;AACA,KAAM,CAAAyE,YAAY,CAAG,KAAM,CAAA7F,YAAY,CAAC4F,YAAY,CAAC,CACrD,GAAI,CAACC,YAAY,EAAIA,YAAY,CAAClB,MAAM,GAAK,CAAC,CAAE,CAC9C,KAAM,IAAI,CAAA9D,KAAK,CAAC,kEAAkE,CAAC,CACrF,CAEA,KAAM,CAAAiF,aAAa,CAAGD,YAAY,CAAC,CAAC,CAAC,CAACxE,MAAM,CAE5C;AACA,GAAI,CAAA0E,WAAW,CAAG;AACtB,eAAenG,MAAM,CAACsB,YAAY;AAClC,sBAAsBG,MAAM;AAC5B,+BAA+ByE,aAAa;AAC5C,KAAK,CAED;AACA,GAAIzE,MAAM,GAAK,WAAW,CAAE,CAC1B0E,WAAW,EAAI,0BAA0B,CAC3C,CAEAA,WAAW,EAAI,gBAAgBhE,EAAE,GAAG,CAEpC;AACA,GAAId,YAAY,CAAE,CAChB,GAAIA,YAAY,CAACE,UAAU,CAAE,CAC3B4E,WAAW,EAAI,uBAAuB9E,YAAY,CAACE,UAAU,GAAG,CAClE,CACA,GAAIF,YAAY,CAACG,UAAU,CAAE,CAC3B2E,WAAW,EAAI,sBAAsB9E,YAAY,CAACG,UAAU,GAAG,CACjE,CACF,CAEA2E,WAAW,EAAI,cAAc,CAE7B;AACA,KAAM,CAAAC,UAAU,CAAG,KAAM,CAAAhG,YAAY,CAAC+F,WAAW,CAAC,CAClD,GAAI,CAACC,UAAU,EAAIA,UAAU,CAACrB,MAAM,GAAK,CAAC,CAAE,CAC1C,KAAM,IAAI,CAAA9D,KAAK,CAAC,kEAAkE,CAAC,CACrF,CAEA;AACA,KAAM,CAAAoF,cAAc,CAAGH,aAAa,GAAKzE,MAAM,CAC3C,GAAGqE,OAAO,uBAAuBI,aAAa,MAAMzE,MAAM,GAAG,CAC7DqE,OAAO,CAEX,KAAM,CAAAQ,YAAY,CAAG;AACzB,oBAAoBpG,yBAAyB;AAC7C,iBAAiBiC,EAAE,OAAOV,MAAM,OAAO4E,cAAc,OAAON,OAAO;AACnE;AACA,KAAK,CAED,KAAM,CAAA3F,YAAY,CAACkG,YAAY,CAAC,CAEhCtF,OAAO,CAAC6D,GAAG,CAAC,qCAAqCqB,aAAa,MAAMzE,MAAM,EAAE,CAAC,CAC7E,MAAO,CAAA2E,UAAU,CAAC,CAAC,CAAC,CACtB,CAAE,MAAOrF,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,wCAAwCoB,EAAE,GAAG,CAAEpB,KAAK,CAAC,CACnE,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAwF,gBAAgB,CAAG,KAAAA,CAC9BpE,EAAU,CACV2D,OAAe,CACfvE,UAAkB,CAClBF,YAAyC,GACtC,CACH;AACA,GAAI,EAACA,YAAY,SAAZA,YAAY,WAAZA,YAAY,CAAEE,UAAU,EAAE,CAC7B,KAAM,IAAI,CAAAN,KAAK,CAAC,+CAA+C,CAAC,CAClE,CAEA;AACA,GAAI,CAAAkF,WAAW,CAAG;AACpB,aAAanG,MAAM,CAACsB,YAAY;AAChC;AACA;AACA,kBAAkBa,EAAE,wBAAwBZ,UAAU;AACtD;AACA,GAAG,CAED,GAAI,CACF;AACA,KAAM,CAAA6E,UAAU,CAAG,KAAM,CAAAhG,YAAY,CAAC+F,WAAW,CAAC,CAClD,GAAI,CAACC,UAAU,EAAIA,UAAU,CAACrB,MAAM,GAAK,CAAC,CAAE,CAC1C,KAAM,IAAI,CAAA9D,KAAK,CAAC,6DAA6D,CAAC,CAChF,CAEA;AACA,KAAM,CAAAqF,YAAY,CAAG;AACzB,oBAAoBpG,yBAAyB;AAC7C,iBAAiBiC,EAAE,8BAA8B2D,OAAO,OAAOvE,UAAU;AACzE;AACA,KAAK,CAED,KAAM,CAAAnB,YAAY,CAACkG,YAAY,CAAC,CAEhC;AACA,KAAM,CAAApE,GAAG,CAAGkE,UAAU,CAAC,CAAC,CAAgB,CACxC,GAAIlE,GAAG,CAACgB,mBAAmB,EAAIhB,GAAG,CAACiB,mBAAmB,EAAIjB,GAAG,CAACT,MAAM,GAAK,UAAU,CAAE,CACnFT,OAAO,CAAC6D,GAAG,CAAC,4EAA4E,CAAC,CAEzF;AACA,MAAO,MAAM,CAAAgB,uBAAuB,CAClC1D,EAAE,CACF,UAAU,CACV,mEAAmE,CACnEZ,UAAU,CACVF,YACF,CAAC,CACH,CAEA,MAAO,CAAAa,GAAG,CACZ,CAAE,MAAOnB,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,6BAA6BoB,EAAE,cAAc,CAAEpB,KAAK,CAAC,CACnE,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAyF,gBAAgB,CAAG,KAAAA,CAC9BrE,EAAU,CACV2D,OAAe,CACfW,gBAAwB,CACxBjF,UAAkB,CAClBH,YAAyC,GACtC,CACH;AACA,GAAI,EAACA,YAAY,SAAZA,YAAY,WAAZA,YAAY,CAAEG,UAAU,GAAIH,YAAY,CAACG,UAAU,GAAKA,UAAU,CAAE,CACvE,KAAM,IAAI,CAAAP,KAAK,CAAC,oEAAoE,CAAC,CACvF,CAEA;AACA,GAAI,CAAAkF,WAAW,CAAG;AACpB,aAAanG,MAAM,CAACsB,YAAY;AAChC;AACA;AACA,kBAAkBa,EAAE,uBAAuBX,UAAU;AACrD;AACA,GAAG,CAED,GAAI,CACF;AACA,KAAM,CAAA4E,UAAU,CAAG,KAAM,CAAAhG,YAAY,CAAC+F,WAAW,CAAC,CAClD,GAAI,CAACC,UAAU,EAAIA,UAAU,CAACrB,MAAM,GAAK,CAAC,CAAE,CAC1C,KAAM,IAAI,CAAA9D,KAAK,CAAC,6DAA6D,CAAC,CAChF,CAEA;AACA,KAAM,CAAAqF,YAAY,CAAG;AACzB,oBAAoBpG,yBAAyB;AAC7C,iBAAiBiC,EAAE,8BAA8B2D,OAAO,OAAOW,gBAAgB;AAC/E;AACA,KAAK,CAED,KAAM,CAAArG,YAAY,CAACkG,YAAY,CAAC,CAEhC;AACA,KAAM,CAAApE,GAAG,CAAGkE,UAAU,CAAC,CAAC,CAAgB,CACxC,GAAIlE,GAAG,CAACgB,mBAAmB,EAAIhB,GAAG,CAACiB,mBAAmB,EAAIjB,GAAG,CAACT,MAAM,GAAK,UAAU,CAAE,CACnFT,OAAO,CAAC6D,GAAG,CAAC,4EAA4E,CAAC,CAEzF;AACA,MAAO,MAAM,CAAAgB,uBAAuB,CAClC1D,EAAE,CACF,UAAU,CACV,mEAAmE,CACnEsE,gBAAgB,CAChBpF,YACF,CAAC,CACH,CAEA,MAAO,CAAAa,GAAG,CACZ,CAAE,MAAOnB,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,6BAA6BoB,EAAE,eAAe,CAAEpB,KAAK,CAAC,CACpE,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAA2F,iBAAiB,CAAG,KAAAA,CAC/BvE,EAAU,CACVd,YAAyC,GACtC,CACH,GAAI,CAAAhB,KAAK,CAAG;AACd;AACA;AACA;AACA;AACA;AACA,WAAWL,MAAM,CAACsB,YAAY;AAC9B,kBAAkBa,EAAE;AACpB,GAAG,CAED;AACA,GAAId,YAAY,CAAE,CAChB,GAAIA,YAAY,CAACE,UAAU,CAAE,CAC3BlB,KAAK,EAAI,uBAAuBgB,YAAY,CAACE,UAAU,GAAG,CAC5D,CACA,GAAIF,YAAY,CAACG,UAAU,CAAE,CAC3BnB,KAAK,EAAI,sBAAsBgB,YAAY,CAACG,UAAU,GAAG,CAC3D,CACF,CAEA,GAAI,CACF,KAAM,CAAAN,IAAI,CAAG,KAAM,CAAAd,YAAY,CAACC,KAAK,CAAC,CACtC,GAAIa,IAAI,EAAIA,IAAI,CAAC6D,MAAM,CAAG,CAAC,CAAE,CAC3B,MAAO,CACL4B,iBAAiB,CAAEzF,IAAI,CAAC,CAAC,CAAC,CAACgC,mBAAmB,EAAI,KAAK,CACvD0D,iBAAiB,CAAE1F,IAAI,CAAC,CAAC,CAAC,CAACiC,mBAAmB,EAAI,KAAK,CACvD0D,mBAAmB,CAAE3F,IAAI,CAAC,CAAC,CAAC,CAACkC,qBAAqB,CAClD0D,mBAAmB,CAAE5F,IAAI,CAAC,CAAC,CAAC,CAACmC,qBAC/B,CAAC,CACH,CACA,KAAM,IAAI,CAAApC,KAAK,CAAC,yBAAyB,CAAC,CAC5C,CAAE,MAAOF,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,wDAAwDoB,EAAE,GAAG,CAAEpB,KAAK,CAAC,CACnF,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAgG,iBAAiB,CAAG,KAAAA,CAAO5E,EAAU,CAAEd,YAAyC,GAAK,CAChG,GAAI,CAAAhB,KAAK,CAAG,eAAeL,MAAM,CAACsB,YAAY,gBAAgBa,EAAE,GAAG,CAEnE;AACA,GAAId,YAAY,CAAE,CAChB,GAAIA,YAAY,CAACE,UAAU,CAAE,CAC3BlB,KAAK,EAAI,uBAAuBgB,YAAY,CAACE,UAAU,GAAG,CAC5D,CACA,GAAIF,YAAY,CAACG,UAAU,CAAE,CAC3BnB,KAAK,EAAI,sBAAsBgB,YAAY,CAACG,UAAU,GAAG,CAC3D,CACF,CAEA,GAAI,CACF,KAAM,CAAApB,YAAY,CAACC,KAAK,CAAC,CACzB,MAAO,KAAI,CACb,CAAE,MAAOU,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,sCAAsCoB,EAAE,GAAG,CAAEpB,KAAK,CAAC,CACjE,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAiG,qBAAqB,CAAG,KAAAA,CAAOC,aAAqB,CAAE5F,YAAyC,GAAK,CAC/G;AACA,GAAIA,YAAY,CAAE,CAChB,GAAI,CAAA6F,QAAQ,CAAG;AACnB,uBAAuBlH,MAAM,CAACsB,YAAY;AAC1C,oBAAoB2F,aAAa;AACjC,KAAK,CAED,GAAI5F,YAAY,CAACE,UAAU,CAAE,CAC3B2F,QAAQ,EAAI,uBAAuB7F,YAAY,CAACE,UAAU,GAAG,CAC/D,CACA,GAAIF,YAAY,CAACG,UAAU,CAAE,CAC3B0F,QAAQ,EAAI,sBAAsB7F,YAAY,CAACG,UAAU,GAAG,CAC9D,CAEA,KAAM,CAAAU,GAAG,CAAG,KAAM,CAAA9B,YAAY,CAAC8G,QAAQ,CAAC,CACxC,GAAI,CAAChF,GAAG,EAAIA,GAAG,CAAC6C,MAAM,GAAK,CAAC,CAAE,CAC5B,KAAM,IAAI,CAAA9D,KAAK,CAAC,gEAAgE,CAAC,CACnF,CACF,CAEA,KAAM,CAAAZ,KAAK,CAAG;AAChB;AACA,WAAWH,yBAAyB;AACpC;AACA,gCAAgC+G,aAAa;AAC7C;AACA,GAAG,CAED,GAAI,CACF,MAAO,MAAM,CAAA7G,YAAY,CAACC,KAAK,CAAC,CAClC,CAAE,MAAOU,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,0CAA0CkG,aAAa,GAAG,CAAElG,KAAK,CAAC,CAChF,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAoG,UAAU,CAAG,KAAAA,CAAOF,aAAqB,CAAEG,MAAc,CAAEC,IAAY,CAAEhG,YAAyC,GAAK,CAClI;AACA,GAAIA,YAAY,CAAE,CAChB,GAAI,CAAA6F,QAAQ,CAAG;AACnB,uBAAuBlH,MAAM,CAACsB,YAAY;AAC1C,oBAAoB2F,aAAa;AACjC,KAAK,CAED,GAAI5F,YAAY,CAACE,UAAU,CAAE,CAC3B2F,QAAQ,EAAI,uBAAuB7F,YAAY,CAACE,UAAU,GAAG,CAC/D,CACA,GAAIF,YAAY,CAACG,UAAU,CAAE,CAC3B0F,QAAQ,EAAI,sBAAsB7F,YAAY,CAACG,UAAU,GAAG,CAC9D,CAEA,KAAM,CAAAU,GAAG,CAAG,KAAM,CAAA9B,YAAY,CAAC8G,QAAQ,CAAC,CACxC,GAAI,CAAChF,GAAG,EAAIA,GAAG,CAAC6C,MAAM,GAAK,CAAC,CAAE,CAC5B,KAAM,IAAI,CAAA9D,KAAK,CAAC,sEAAsE,CAAC,CACzF,CACF,CAEA,KAAM,CAAAZ,KAAK,CAAG;AAChB,kBAAkBL,MAAM,CAACsH,QAAQ;AACjC,eAAeL,aAAa,OAAOG,MAAM,OAAOC,IAAI;AACpD;AACA,GAAG,CAED,GAAI,CACF,KAAM,CAAAnG,IAAI,CAAG,KAAM,CAAAd,YAAY,CAACC,KAAK,CAAC,CACtC,MAAO,CAAAa,IAAI,CAAC,CAAC,CAAC,CAChB,CAAE,MAAOH,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,uCAAuCkG,aAAa,GAAG,CAAElG,KAAK,CAAC,CAC7E,KAAM,CAAAA,KAAK,CACb,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAwG,WAAW,CAAG,KAAAA,CAAON,aAAqB,CAAE5F,YAAyC,GAAK,CACrG;AACA,GAAIA,YAAY,CAAE,CAChB,GAAI,CAAA6F,QAAQ,CAAG;AACnB,uBAAuBlH,MAAM,CAACsB,YAAY;AAC1C,oBAAoB2F,aAAa;AACjC,KAAK,CAED,GAAI5F,YAAY,CAACE,UAAU,CAAE,CAC3B2F,QAAQ,EAAI,uBAAuB7F,YAAY,CAACE,UAAU,GAAG,CAC/D,CACA,GAAIF,YAAY,CAACG,UAAU,CAAE,CAC3B0F,QAAQ,EAAI,sBAAsB7F,YAAY,CAACG,UAAU,GAAG,CAC9D,CAEA,KAAM,CAAAU,GAAG,CAAG,KAAM,CAAA9B,YAAY,CAAC8G,QAAQ,CAAC,CACxC,GAAI,CAAChF,GAAG,EAAIA,GAAG,CAAC6C,MAAM,GAAK,CAAC,CAAE,CAC5B,KAAM,IAAI,CAAA9D,KAAK,CAAC,0EAA0E,CAAC,CAC7F,CACF,CAEA,KAAM,CAAAZ,KAAK,CAAG;AAChB;AACA,WAAWL,MAAM,CAACsH,QAAQ;AAC1B;AACA,gCAAgCL,aAAa;AAC7C;AACA,GAAG,CAED,GAAI,CACF,MAAO,MAAM,CAAA7G,YAAY,CAACC,KAAK,CAAC,CAClC,CAAE,MAAOU,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAAC,2CAA2CkG,aAAa,GAAG,CAAElG,KAAK,CAAC,CACjF,KAAM,CAAAA,KAAK,CACb,CACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}