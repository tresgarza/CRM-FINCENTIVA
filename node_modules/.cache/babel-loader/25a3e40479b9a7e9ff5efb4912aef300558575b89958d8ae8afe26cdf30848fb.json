{"ast":null,"code":"import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async () => {\n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const {\n      data,\n      error\n    } = await supabase.storage.from(STORAGE_BUCKET).list();\n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || errorMessage.includes('does not exist') || errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async applicationId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('application_id', applicationId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async clientId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('client_id', clientId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async id => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('id', id).single();\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Upload a document\nexport const uploadDocument = async upload => {\n  const {\n    file,\n    application_id,\n    client_id,\n    userId,\n    documentName,\n    description,\n    category\n  } = upload;\n  try {\n    // Make sure the storage bucket exists\n    await ensureStorageBucketExists();\n    if (!file) {\n      console.error('Upload failed: No file provided');\n      throw new Error(\"El archivo es requerido para la carga\");\n    }\n    if (!application_id && !client_id) {\n      console.error('Upload failed: No application_id or client_id provided');\n      throw new Error(\"Se debe proporcionar un ID de solicitud o ID de cliente\");\n    }\n\n    // Check file size (max 10MB)\n    if (file.size > 10 * 1024 * 1024) {\n      console.error('Upload failed: File too large', file.size);\n      throw new Error(\"El archivo es demasiado grande (máximo 10MB)\");\n    }\n\n    // Generate a unique file path\n    const timestamp = new Date().getTime();\n    const fileName = file.name.replace(/[^a-zA-Z0-9.]/g, '_'); // Sanitize filename\n    const fileExtension = fileName.split('.').pop() || 'unknown';\n    const prefix = application_id ? `applications/${application_id}` : `clients/${client_id}`;\n    const filePath = `${prefix}/${timestamp}_${fileName}`;\n    console.log(`Uploading document: ${documentName} to path: ${filePath}`);\n\n    // Attempt file upload with retry logic (max 3 attempts)\n    let storageError = null;\n    let uploadResult = null;\n    for (let attempt = 0; attempt < 3; attempt++) {\n      try {\n        const {\n          data,\n          error\n        } = await supabase.storage.from(STORAGE_BUCKET).upload(filePath, file, {\n          cacheControl: '3600',\n          upsert: attempt > 0 // On retry, allow overwrite\n        });\n        if (error) {\n          console.error(`Upload attempt ${attempt + 1} failed:`, error);\n          storageError = error;\n\n          // Manejo específico de errores de permisos\n          if (error.message && error.message.includes(\"violates row-level security policy\")) {\n            console.error(\"RLS policy violation detected. User lacks permissions to upload.\");\n            throw new Error(\"No tienes permisos suficientes para subir archivos. Por favor contacta al administrador.\");\n          }\n        } else {\n          uploadResult = data;\n          storageError = null;\n          break; // Success, exit retry loop\n        }\n      } catch (err) {\n        console.error(`Unexpected error on upload attempt ${attempt + 1}:`, err);\n        storageError = err;\n      }\n\n      // Wait before retry with exponential backoff\n      if (attempt < 2) {\n        await new Promise(r => setTimeout(r, 1000 * Math.pow(2, attempt)));\n      }\n    }\n    if (storageError) {\n      console.error('All upload attempts failed:', storageError);\n      // Use a type-safe approach to access error message\n      const errorMessage = storageError instanceof Error ? storageError.message : typeof storageError === 'object' && storageError !== null && 'message' in storageError ? String(storageError.message) : 'Error desconocido';\n\n      // Mensaje más específico para errores de políticas RLS\n      if (errorMessage.includes(\"violates row-level security policy\")) {\n        throw new Error(`Error de permisos: No tienes acceso para subir archivos. Por favor contacta al administrador para configurar las políticas de seguridad en Supabase.`);\n      }\n      throw new Error(`Error al subir el archivo: ${errorMessage}`);\n    }\n\n    // Después de una carga exitosa, crear el registro en la base de datos\n    try {\n      var _documentData$;\n      // Create document record in database\n      const documentRecord = {\n        file_name: documentName || fileName,\n        file_path: filePath,\n        file_type: file.type || `application/${fileExtension}`,\n        file_size: file.size,\n        uploaded_by_user_id: userId,\n        category\n      };\n      if (application_id) {\n        Object.assign(documentRecord, {\n          application_id\n        });\n      }\n      if (client_id) {\n        Object.assign(documentRecord, {\n          client_id\n        });\n      }\n      if (description) {\n        Object.assign(documentRecord, {\n          description\n        });\n      }\n      console.log('Creating document record in database');\n      const {\n        data: documentData,\n        error: documentError\n      } = await supabase.from(DOCUMENTS_TABLE).insert([documentRecord]).select();\n      if (documentError) {\n        console.error('Error creating document record:', documentError);\n\n        // Clean up: delete the uploaded file if document record creation failed\n        try {\n          await supabase.storage.from(STORAGE_BUCKET).remove([filePath]);\n          console.log('Cleaned up file after database record creation failure');\n        } catch (cleanupError) {\n          console.error('Error during cleanup of uploaded file:', cleanupError);\n        }\n\n        // Use a type-safe approach to access error message  \n        const errorMessage = documentError instanceof Error ? documentError.message : typeof documentError === 'object' && documentError !== null && 'message' in documentError ? String(documentError.message) : 'Error desconocido';\n        throw new Error(`Error al guardar el registro del documento: ${errorMessage}`);\n      }\n      console.log('Document uploaded successfully:', (_documentData$ = documentData[0]) === null || _documentData$ === void 0 ? void 0 : _documentData$.id);\n      return documentData[0];\n    } catch (dbError) {\n      // Si falla la creación del registro en la base de datos, intentar limpiar el archivo en storage\n      try {\n        await supabase.storage.from(STORAGE_BUCKET).remove([filePath]);\n        console.log('Cleaned up file after database error');\n      } catch (cleanupError) {\n        console.error('Error during file cleanup after database error:', cleanupError);\n      }\n      throw dbError; // Re-lanzar error original\n    }\n  } catch (error) {\n    console.error('Critical error in document upload process:', error);\n    throw error;\n  }\n};\n\n// Delete a document\nexport const deleteDocument = async documentId => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n\n    // Get document to get file path\n    const {\n      data: document,\n      error: fetchError\n    } = await supabase.from(DOCUMENTS_TABLE).select('file_path').eq('id', documentId).single();\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const {\n      error: storageError\n    } = await supabase.storage.from(STORAGE_BUCKET).remove([document.file_path]);\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error ? storageError.message : typeof storageError === 'object' && storageError !== null && 'message' in storageError ? String(storageError.message) : 'Error desconocido';\n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const {\n      error: deleteError\n    } = await supabase.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async filePath => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    const {\n      data,\n      error\n    } = await supabase.storage.from(STORAGE_BUCKET).createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId, userId, isVerified = true) => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).update({\n    is_verified: isVerified,\n    verified_by: userId,\n    verified_at: new Date().toISOString()\n  }).eq('id', documentId).select();\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n  return data[0];\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async applicationType => {\n  const {\n    data,\n    error\n  } = await supabase.from('required_documents').select('*').eq('application_type', applicationType);\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n  return data;\n};","map":{"version":3,"names":["supabase","TABLES","DOCUMENTS_TABLE","DOCUMENTS","STORAGE_BUCKET","ensureStorageBucketExists","data","error","storage","from","list","errorMessage","message","includes","console","log","Error","getApplicationDocuments","applicationId","select","eq","order","ascending","getClientDocuments","clientId","getDocumentById","id","single","uploadDocument","upload","file","application_id","client_id","userId","documentName","description","category","size","timestamp","Date","getTime","fileName","name","replace","fileExtension","split","pop","prefix","filePath","storageError","uploadResult","attempt","cacheControl","upsert","err","Promise","r","setTimeout","Math","pow","String","_documentData$","documentRecord","file_name","file_path","file_type","type","file_size","uploaded_by_user_id","Object","assign","documentData","documentError","insert","remove","cleanupError","dbError","deleteDocument","documentId","document","fetchError","deleteError","delete","getDocumentUrl","createSignedUrl","signedUrl","verifyDocument","isVerified","update","is_verified","verified_by","verified_at","toISOString","getRequiredDocuments","applicationType"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/documentService.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\n\nexport interface Document {\n  id: string;\n  created_at: string;\n  file_name: string;\n  file_path: string;\n  file_type: string;\n  file_size: number;\n  category?: string;\n  application_id?: string;\n  client_id?: string;\n  uploaded_by_user_id?: string;\n  is_verified?: boolean;\n  verified_by?: string;\n  verified_at?: string;\n}\n\nexport interface DocumentUpload {\n  file: File;\n  application_id?: string;\n  client_id?: string;\n  userId: string;\n  documentName: string;\n  description?: string;\n  category?: string;\n}\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async () => {\n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const { data, error } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .list();\n    \n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || \n          errorMessage.includes('does not exist') || \n          errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    \n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async (applicationId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('application_id', applicationId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async (clientId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('client_id', clientId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async (id: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n\n  return data as Document;\n};\n\n// Upload a document\nexport const uploadDocument = async (upload: DocumentUpload) => {\n  const { file, application_id, client_id, userId, documentName, description, category } = upload;\n  \n  try {\n    // Make sure the storage bucket exists\n    await ensureStorageBucketExists();\n    \n    if (!file) {\n      console.error('Upload failed: No file provided');\n      throw new Error(\"El archivo es requerido para la carga\");\n    }\n    \n    if (!application_id && !client_id) {\n      console.error('Upload failed: No application_id or client_id provided');\n      throw new Error(\"Se debe proporcionar un ID de solicitud o ID de cliente\");\n    }\n  \n    // Check file size (max 10MB)\n    if (file.size > 10 * 1024 * 1024) {\n      console.error('Upload failed: File too large', file.size);\n      throw new Error(\"El archivo es demasiado grande (máximo 10MB)\");\n    }\n    \n    // Generate a unique file path\n    const timestamp = new Date().getTime();\n    const fileName = file.name.replace(/[^a-zA-Z0-9.]/g, '_'); // Sanitize filename\n    const fileExtension = fileName.split('.').pop() || 'unknown';\n    const prefix = application_id ? `applications/${application_id}` : `clients/${client_id}`;\n    const filePath = `${prefix}/${timestamp}_${fileName}`;\n    \n    console.log(`Uploading document: ${documentName} to path: ${filePath}`);\n\n    // Attempt file upload with retry logic (max 3 attempts)\n    let storageError = null;\n    let uploadResult = null;\n    \n    for (let attempt = 0; attempt < 3; attempt++) {\n      try {\n        const { data, error } = await supabase.storage\n          .from(STORAGE_BUCKET)\n          .upload(filePath, file, {\n            cacheControl: '3600',\n            upsert: attempt > 0 // On retry, allow overwrite\n          });\n        \n        if (error) {\n          console.error(`Upload attempt ${attempt + 1} failed:`, error);\n          storageError = error;\n          \n          // Manejo específico de errores de permisos\n          if (error.message && error.message.includes(\"violates row-level security policy\")) {\n            console.error(\"RLS policy violation detected. User lacks permissions to upload.\");\n            throw new Error(\"No tienes permisos suficientes para subir archivos. Por favor contacta al administrador.\");\n          }\n        } else {\n          uploadResult = data;\n          storageError = null;\n          break; // Success, exit retry loop\n        }\n      } catch (err) {\n        console.error(`Unexpected error on upload attempt ${attempt + 1}:`, err);\n        storageError = err;\n      }\n      \n      // Wait before retry with exponential backoff\n      if (attempt < 2) {\n        await new Promise(r => setTimeout(r, 1000 * Math.pow(2, attempt)));\n      }\n    }\n\n    if (storageError) {\n      console.error('All upload attempts failed:', storageError);\n      // Use a type-safe approach to access error message\n      const errorMessage = storageError instanceof Error \n        ? storageError.message \n        : (typeof storageError === 'object' && storageError !== null && 'message' in storageError)\n          ? String(storageError.message)\n          : 'Error desconocido';\n      \n      // Mensaje más específico para errores de políticas RLS\n      if (errorMessage.includes(\"violates row-level security policy\")) {\n        throw new Error(`Error de permisos: No tienes acceso para subir archivos. Por favor contacta al administrador para configurar las políticas de seguridad en Supabase.`);\n      }\n      \n      throw new Error(`Error al subir el archivo: ${errorMessage}`);\n    }\n\n    // Después de una carga exitosa, crear el registro en la base de datos\n    try {\n      // Create document record in database\n      const documentRecord = {\n        file_name: documentName || fileName,\n        file_path: filePath,\n        file_type: file.type || `application/${fileExtension}`,\n        file_size: file.size,\n        uploaded_by_user_id: userId,\n        category\n      };\n      \n      if (application_id) {\n        Object.assign(documentRecord, { application_id });\n      }\n      \n      if (client_id) {\n        Object.assign(documentRecord, { client_id });\n      }\n      \n      if (description) {\n        Object.assign(documentRecord, { description });\n      }\n\n      console.log('Creating document record in database');\n      const { data: documentData, error: documentError } = await supabase\n        .from(DOCUMENTS_TABLE)\n        .insert([documentRecord])\n        .select();\n\n      if (documentError) {\n        console.error('Error creating document record:', documentError);\n        \n        // Clean up: delete the uploaded file if document record creation failed\n        try {\n          await supabase.storage\n            .from(STORAGE_BUCKET)\n            .remove([filePath]);\n          console.log('Cleaned up file after database record creation failure');\n        } catch (cleanupError) {\n          console.error('Error during cleanup of uploaded file:', cleanupError);\n        }\n        \n        // Use a type-safe approach to access error message  \n        const errorMessage = documentError instanceof Error \n          ? documentError.message \n          : (typeof documentError === 'object' && documentError !== null && 'message' in documentError)\n            ? String((documentError as {message: string}).message)\n            : 'Error desconocido';\n        \n        throw new Error(`Error al guardar el registro del documento: ${errorMessage}`);\n      }\n\n      console.log('Document uploaded successfully:', documentData[0]?.id);\n      return documentData[0] as Document;\n    } catch (dbError) {\n      // Si falla la creación del registro en la base de datos, intentar limpiar el archivo en storage\n      try {\n        await supabase.storage.from(STORAGE_BUCKET).remove([filePath]);\n        console.log('Cleaned up file after database error');\n      } catch (cleanupError) {\n        console.error('Error during file cleanup after database error:', cleanupError);\n      }\n      \n      throw dbError; // Re-lanzar error original\n    }\n  } catch (error) {\n    console.error('Critical error in document upload process:', error);\n    throw error;\n  }\n};\n\n// Delete a document\nexport const deleteDocument = async (documentId: string) => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n    \n    // Get document to get file path\n    const { data: document, error: fetchError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .select('file_path')\n      .eq('id', documentId)\n      .single();\n\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const { error: storageError } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .remove([document.file_path]);\n\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error \n        ? storageError.message \n        : (typeof storageError === 'object' && storageError !== null && 'message' in storageError)\n          ? String((storageError as {message: string}).message)\n          : 'Error desconocido';\n      \n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const { error: deleteError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .delete()\n      .eq('id', documentId);\n\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async (filePath: string) => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    \n    const { data, error } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId: string, userId: string, isVerified: boolean = true) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .update({\n      is_verified: isVerified,\n      verified_by: userId,\n      verified_at: new Date().toISOString()\n    })\n    .eq('id', documentId)\n    .select();\n\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n\n  return data[0] as Document;\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async (applicationType: string) => {\n  const { data, error } = await supabase\n    .from('required_documents')\n    .select('*')\n    .eq('application_type', applicationType);\n\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n\n  return data;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}