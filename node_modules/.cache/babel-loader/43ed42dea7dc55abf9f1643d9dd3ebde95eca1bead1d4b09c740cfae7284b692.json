{"ast":null,"code":"import { APPLICATION_TYPE_LABELS } from './constants/applications';\n\n/**\n * Obtiene una etiqueta legible para un tipo de aplicación\n * @param type El tipo de aplicación a formatear\n * @returns Etiqueta legible para el tipo de aplicación\n */\nexport const getApplicationTypeLabel = type => {\n  if (!type) return 'No especificado';\n\n  // 1. Verificar si está en los valores de APPLICATION_TYPE_LABELS\n  const typeLabel = APPLICATION_TYPE_LABELS[type];\n  if (typeLabel) return typeLabel;\n\n  // 2. Verificar casos específicos comunes que podrían no estar en mayúsculas\n  const typeMappings = {\n    'selected_plans': 'Planes Seleccionados',\n    'product_simulations': 'Simulación de Producto',\n    'cash_requests': 'Solicitud de Efectivo',\n    'auto_loan': 'Crédito Automotriz',\n    'car_backed_loan': 'Crédito con Garantía Automotriz',\n    'personal_loan': 'Préstamo Personal',\n    'cash_advance': 'Adelanto de Efectivo',\n    'simulacion': 'Simulación',\n    'solicitud': 'Solicitud'\n  };\n\n  // Buscar coincidencia exacta primero\n  if (typeMappings[type.toLowerCase()]) {\n    return typeMappings[type.toLowerCase()];\n  }\n\n  // 3. Buscar coincidencia parcial si no hay coincidencia exacta\n  const lowerType = type.toLowerCase();\n  for (const [key, value] of Object.entries(typeMappings)) {\n    if (lowerType.includes(key) || key.includes(lowerType)) {\n      return value;\n    }\n  }\n\n  // 4. Si es algún otro formato (como snake_case), formatearlo de manera legible\n  if (type.includes('_')) {\n    return type.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\n  }\n\n  // 5. Si nada funciona, devolver el tipo original con la primera letra en mayúscula\n  return type.charAt(0).toUpperCase() + type.slice(1).toLowerCase();\n};","map":{"version":3,"names":["APPLICATION_TYPE_LABELS","getApplicationTypeLabel","type","typeLabel","typeMappings","toLowerCase","lowerType","key","value","Object","entries","includes","split","map","word","charAt","toUpperCase","slice","join"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/formatters.ts"],"sourcesContent":["import { APPLICATION_TYPE_LABELS } from './constants/applications';\n\n/**\n * Obtiene una etiqueta legible para un tipo de aplicación\n * @param type El tipo de aplicación a formatear\n * @returns Etiqueta legible para el tipo de aplicación\n */\nexport const getApplicationTypeLabel = (type: string | null | undefined): string => {\n  if (!type) return 'No especificado';\n  \n  // 1. Verificar si está en los valores de APPLICATION_TYPE_LABELS\n  const typeLabel = APPLICATION_TYPE_LABELS[type];\n  if (typeLabel) return typeLabel;\n  \n  // 2. Verificar casos específicos comunes que podrían no estar en mayúsculas\n  const typeMappings: Record<string, string> = {\n    'selected_plans': 'Planes Seleccionados',\n    'product_simulations': 'Simulación de Producto',\n    'cash_requests': 'Solicitud de Efectivo',\n    'auto_loan': 'Crédito Automotriz',\n    'car_backed_loan': 'Crédito con Garantía Automotriz',\n    'personal_loan': 'Préstamo Personal',\n    'cash_advance': 'Adelanto de Efectivo',\n    'simulacion': 'Simulación',\n    'solicitud': 'Solicitud'\n  };\n  \n  // Buscar coincidencia exacta primero\n  if (typeMappings[type.toLowerCase()]) {\n    return typeMappings[type.toLowerCase()];\n  }\n  \n  // 3. Buscar coincidencia parcial si no hay coincidencia exacta\n  const lowerType = type.toLowerCase();\n  for (const [key, value] of Object.entries(typeMappings)) {\n    if (lowerType.includes(key) || key.includes(lowerType)) {\n      return value;\n    }\n  }\n  \n  // 4. Si es algún otro formato (como snake_case), formatearlo de manera legible\n  if (type.includes('_')) {\n    return type\n      .split('_')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n  }\n  \n  // 5. Si nada funciona, devolver el tipo original con la primera letra en mayúscula\n  return type.charAt(0).toUpperCase() + type.slice(1).toLowerCase();\n}; "],"mappings":"AAAA,SAASA,uBAAuB,QAAQ,0BAA0B;;AAElE;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,uBAAuB,GAAIC,IAA+B,IAAa;EAClF,IAAI,CAACA,IAAI,EAAE,OAAO,iBAAiB;;EAEnC;EACA,MAAMC,SAAS,GAAGH,uBAAuB,CAACE,IAAI,CAAC;EAC/C,IAAIC,SAAS,EAAE,OAAOA,SAAS;;EAE/B;EACA,MAAMC,YAAoC,GAAG;IAC3C,gBAAgB,EAAE,sBAAsB;IACxC,qBAAqB,EAAE,wBAAwB;IAC/C,eAAe,EAAE,uBAAuB;IACxC,WAAW,EAAE,oBAAoB;IACjC,iBAAiB,EAAE,iCAAiC;IACpD,eAAe,EAAE,mBAAmB;IACpC,cAAc,EAAE,sBAAsB;IACtC,YAAY,EAAE,YAAY;IAC1B,WAAW,EAAE;EACf,CAAC;;EAED;EACA,IAAIA,YAAY,CAACF,IAAI,CAACG,WAAW,CAAC,CAAC,CAAC,EAAE;IACpC,OAAOD,YAAY,CAACF,IAAI,CAACG,WAAW,CAAC,CAAC,CAAC;EACzC;;EAEA;EACA,MAAMC,SAAS,GAAGJ,IAAI,CAACG,WAAW,CAAC,CAAC;EACpC,KAAK,MAAM,CAACE,GAAG,EAAEC,KAAK,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACN,YAAY,CAAC,EAAE;IACvD,IAAIE,SAAS,CAACK,QAAQ,CAACJ,GAAG,CAAC,IAAIA,GAAG,CAACI,QAAQ,CAACL,SAAS,CAAC,EAAE;MACtD,OAAOE,KAAK;IACd;EACF;;EAEA;EACA,IAAIN,IAAI,CAACS,QAAQ,CAAC,GAAG,CAAC,EAAE;IACtB,OAAOT,IAAI,CACRU,KAAK,CAAC,GAAG,CAAC,CACVC,GAAG,CAACC,IAAI,IAAIA,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAGF,IAAI,CAACG,KAAK,CAAC,CAAC,CAAC,CAACZ,WAAW,CAAC,CAAC,CAAC,CACvEa,IAAI,CAAC,GAAG,CAAC;EACd;;EAEA;EACA,OAAOhB,IAAI,CAACa,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAGd,IAAI,CAACe,KAAK,CAAC,CAAC,CAAC,CAACZ,WAAW,CAAC,CAAC;AACnE,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}