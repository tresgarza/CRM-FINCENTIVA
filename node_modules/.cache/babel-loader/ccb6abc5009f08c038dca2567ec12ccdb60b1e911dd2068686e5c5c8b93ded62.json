{"ast":null,"code":"/**\n * Ejecuta una consulta SQL directa\n * @param query Consulta SQL a ejecutar\n * @returns Resultado de la consulta\n */\nexport const executeQuery = async query => {\n  try {\n    const response = await fetch('/query', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        query\n      })\n    });\n    if (!response.ok) {\n      const errorData = await response.json();\n      // Si el error es que la tabla no existe, informarlo de forma más específica\n      if (errorData.code === '42P01') {\n        console.error(`Error ejecutando consulta - tabla no existe: ${errorData.error}`);\n        throw new Error(`Tabla no existe: ${errorData.error}`);\n      } else {\n        console.error('Error al ejecutar la consulta:', errorData);\n        throw new Error(`Error al ejecutar la consulta: ${response.statusText}. Detalles: ${JSON.stringify(errorData)}`);\n      }\n    }\n    const data = await response.json();\n    return data.data;\n  } catch (error) {\n    // Si es un error controlado, propagarlo\n    if (error.message.includes('Tabla no existe')) {\n      throw error;\n    }\n    console.error('Error al realizar la consulta:', error);\n    throw new Error('Error al realizar la consulta: ' + error.message);\n  }\n};\n\n/**\n * Escapa caracteres especiales en string para prevenir inyección SQL\n * @param value String a escapar\n * @returns String escapado\n */\nexport const escapeSqlString = value => {\n  if (!value) return '';\n\n  // Reemplazar comillas simples por dos comillas simples (estándar SQL)\n  return value.replace(/'/g, \"''\");\n};\n\n/**\n * Formatea una fecha para SQL\n * @param date Fecha a formatear\n * @returns String formateado para SQL\n */\nexport const formatDateForSql = date => {\n  return date.toISOString();\n};\n\n/**\n * Convierte un objeto a una cadena de condiciones SQL WHERE\n * @param conditions Objeto con condiciones {columna: valor}\n * @returns String con condiciones SQL\n */\nexport const objectToSqlWhere = conditions => {\n  const clauses = [];\n  for (const [key, value] of Object.entries(conditions)) {\n    if (value === undefined || value === null) continue;\n    if (typeof value === 'string') {\n      clauses.push(`${key} = '${escapeSqlString(value)}'`);\n    } else if (typeof value === 'number' || typeof value === 'boolean') {\n      clauses.push(`${key} = ${value}`);\n    } else if (value instanceof Date) {\n      clauses.push(`${key} = '${formatDateForSql(value)}'`);\n    } else if (Array.isArray(value)) {\n      const formattedValues = value.map(v => typeof v === 'string' ? `'${escapeSqlString(v)}'` : v);\n      clauses.push(`${key} IN (${formattedValues.join(',')})`);\n    }\n  }\n  return clauses.length > 0 ? clauses.join(' AND ') : '1=1';\n};","map":{"version":3,"names":["executeQuery","query","response","fetch","method","headers","body","JSON","stringify","ok","errorData","json","code","console","error","Error","statusText","data","message","includes","escapeSqlString","value","replace","formatDateForSql","date","toISOString","objectToSqlWhere","conditions","clauses","key","Object","entries","undefined","push","Date","Array","isArray","formattedValues","map","v","join","length"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/databaseUtils.ts"],"sourcesContent":["/**\n * Ejecuta una consulta SQL directa\n * @param query Consulta SQL a ejecutar\n * @returns Resultado de la consulta\n */\nexport const executeQuery = async (query: string) => {\n  try {\n    const response = await fetch('/query', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ query }),\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      // Si el error es que la tabla no existe, informarlo de forma más específica\n      if (errorData.code === '42P01') {\n        console.error(`Error ejecutando consulta - tabla no existe: ${errorData.error}`);\n        throw new Error(`Tabla no existe: ${errorData.error}`);\n      } else {\n        console.error('Error al ejecutar la consulta:', errorData);\n        throw new Error(`Error al ejecutar la consulta: ${response.statusText}. Detalles: ${JSON.stringify(errorData)}`);\n      }\n    }\n\n    const data = await response.json();\n    return data.data;\n  } catch (error: any) {\n    // Si es un error controlado, propagarlo\n    if (error.message.includes('Tabla no existe')) {\n      throw error;\n    }\n    console.error('Error al realizar la consulta:', error);\n    throw new Error('Error al realizar la consulta: ' + error.message);\n  }\n};\n\n/**\n * Escapa caracteres especiales en string para prevenir inyección SQL\n * @param value String a escapar\n * @returns String escapado\n */\nexport const escapeSqlString = (value: string): string => {\n  if (!value) return '';\n  \n  // Reemplazar comillas simples por dos comillas simples (estándar SQL)\n  return value.replace(/'/g, \"''\");\n};\n\n/**\n * Formatea una fecha para SQL\n * @param date Fecha a formatear\n * @returns String formateado para SQL\n */\nexport const formatDateForSql = (date: Date): string => {\n  return date.toISOString();\n};\n\n/**\n * Convierte un objeto a una cadena de condiciones SQL WHERE\n * @param conditions Objeto con condiciones {columna: valor}\n * @returns String con condiciones SQL\n */\nexport const objectToSqlWhere = (conditions: Record<string, any>): string => {\n  const clauses = [];\n  \n  for (const [key, value] of Object.entries(conditions)) {\n    if (value === undefined || value === null) continue;\n    \n    if (typeof value === 'string') {\n      clauses.push(`${key} = '${escapeSqlString(value)}'`);\n    } else if (typeof value === 'number' || typeof value === 'boolean') {\n      clauses.push(`${key} = ${value}`);\n    } else if (value instanceof Date) {\n      clauses.push(`${key} = '${formatDateForSql(value)}'`);\n    } else if (Array.isArray(value)) {\n      const formattedValues = value.map(v => \n        typeof v === 'string' ? `'${escapeSqlString(v)}'` : v\n      );\n      clauses.push(`${key} IN (${formattedValues.join(',')})`);\n    }\n  }\n  \n  return clauses.length > 0 ? clauses.join(' AND ') : '1=1';\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}