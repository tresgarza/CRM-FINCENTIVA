{"ast":null,"code":"import{executeQuery}from'../utils/databaseUtils';import{TABLES}from'../utils/constants/tables';// Nombre de la tabla definido como constante para evitar errores de escritura\nconst CLIENTS_TABLE=TABLES.CLIENTS||'clients';// Get all clients with filters\nexport const getClients=async function(){let filters=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};try{const page=filters.page||1;const pageSize=filters.pageSize||10;const offset=(page-1)*pageSize;// Construir condiciones de filtrado\nconst whereConditions=[];if(filters.search){const searchTerm=filters.search.trim();whereConditions.push(`(name ILIKE '%${searchTerm}%' OR email ILIKE '%${searchTerm}%' OR phone ILIKE '%${searchTerm}%')`);}if(filters.company_id){whereConditions.push(`company_id = '${filters.company_id}'`);}const whereClause=whereConditions.length>0?`WHERE ${whereConditions.join(' AND ')}`:'';// Consulta para obtener clientes paginados\nconst query=`\n      SELECT * FROM ${TABLES.CLIENTS}\n      ${whereClause}\n      ORDER BY created_at DESC\n      LIMIT ${pageSize} OFFSET ${offset}\n    `;// Consulta para obtener el total de clientes (para paginación)\nconst countQuery=`\n      SELECT COUNT(*) as total FROM ${TABLES.CLIENTS}\n      ${whereClause}\n    `;// Ejecutar ambas consultas\nconst clients=await executeQuery(query);const totalResult=await executeQuery(countQuery);// Extraer el total de la respuesta de conteo\nconst totalCount=totalResult.length>0?parseInt(totalResult[0].total||'0'):0;// Retornar en el formato esperado por los componentes\nreturn{clients,totalCount};}catch(error){console.error('Error al obtener clientes:',error);return{clients:[],totalCount:0};}};// Get a single client by ID\nexport const getClientById=async id=>{try{const query=`SELECT * FROM ${CLIENTS_TABLE} WHERE id = '${id}'`;const data=await executeQuery(query);if(data&&data.length>0){return data[0];}throw new Error('Cliente no encontrado');}catch(error){console.error(`Error al obtener cliente con ID ${id}:`,error);throw error;}};/**\n * Escapa caracteres especiales en cadenas SQL\n */function escapeSQLString(str){return str.replace(/'/g,\"''\");}// Get applications for a specific client\nexport const getClientApplications=async clientId=>{try{const query=`\n      SELECT * FROM ${TABLES.APPLICATIONS} \n      WHERE client_id = '${clientId}' OR source_id = '${clientId}'\n      ORDER BY created_at DESC\n    `;return await executeQuery(query);}catch(error){console.error(`Error al obtener aplicaciones del cliente ${clientId}:`,error);throw error;}};// Create a new client\nexport const createClient=async client=>{try{// Construir lista de campos y valores\nconst fields=Object.keys(client).join(', ');const values=Object.values(client).map(value=>typeof value==='string'?`'${escapeSQLString(value)}'`:value).join(', ');const query=`\n      INSERT INTO ${CLIENTS_TABLE} (${fields})\n      VALUES (${values})\n      RETURNING *\n    `;const data=await executeQuery(query);if(data&&data.length>0){return data[0];}throw new Error('Error al crear el cliente');}catch(error){console.error('Error al crear cliente:',error);throw error;}};// Update an existing client\nexport const updateClient=async(id,updates)=>{try{// Construir lista de cambios\nconst setClause=Object.entries(updates).map(_ref=>{let[key,value]=_ref;return`${key} = ${typeof value==='string'?`'${escapeSQLString(value)}'`:value}`;}).join(', ');const query=`\n      UPDATE ${CLIENTS_TABLE}\n      SET ${setClause}\n      WHERE id = '${id}'\n      RETURNING *\n    `;const data=await executeQuery(query);if(data&&data.length>0){return data[0];}throw new Error('Cliente no encontrado');}catch(error){console.error(`Error al actualizar cliente con ID ${id}:`,error);throw error;}};// Delete a client\nexport const deleteClient=async id=>{try{const query=`\n      DELETE FROM ${CLIENTS_TABLE}\n      WHERE id = '${id}'\n      RETURNING id\n    `;const data=await executeQuery(query);if(data&&data.length>0){return true;}throw new Error('Cliente no encontrado');}catch(error){console.error(`Error al eliminar cliente con ID ${id}:`,error);throw error;}};// Check if a client with the given email or RFC already exists\nexport const checkClientExists=async(email,rfc)=>{try{let query=`\n      SELECT id, email, rfc FROM ${CLIENTS_TABLE}\n      WHERE email = '${escapeSQLString(email)}'\n    `;if(rfc){query+=` OR rfc = '${escapeSQLString(rfc)}'`;}const data=await executeQuery(query);if(data&&data.length>0){return{exists:true,client:data[0]};}return{exists:false};}catch(error){console.error('Error al verificar existencia de cliente:',error);throw error;}};// Get total count of clients with filters\nexport const getClientCount=async filters=>{try{let query=`SELECT COUNT(*) as count FROM ${CLIENTS_TABLE} WHERE 1=1`;// Aplicar filtros si existen\nif(filters){// Filtro por búsqueda\nif(filters.searchQuery){query+=` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;}// Filtro por asesor\nif(filters.advisor_id){query+=` AND advisor_id = '${filters.advisor_id}'`;}// Filtro por empresa\nif(filters.company_id){query+=` AND company_id = '${filters.company_id}'`;}}const data=await executeQuery(query);if(data&&data.length>0){return parseInt(data[0].count)||0;}return 0;}catch(error){console.error('Error al obtener conteo de clientes:',error);return 0;}};","map":{"version":3,"names":["executeQuery","TABLES","CLIENTS_TABLE","CLIENTS","getClients","filters","arguments","length","undefined","page","pageSize","offset","whereConditions","search","searchTerm","trim","push","company_id","whereClause","join","query","countQuery","clients","totalResult","totalCount","parseInt","total","error","console","getClientById","id","data","Error","escapeSQLString","str","replace","getClientApplications","clientId","APPLICATIONS","createClient","client","fields","Object","keys","values","map","value","updateClient","updates","setClause","entries","_ref","key","deleteClient","checkClientExists","email","rfc","exists","getClientCount","searchQuery","advisor_id","count"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/clientService.ts"],"sourcesContent":["import { executeQuery } from '../utils/databaseUtils';\nimport { TABLES } from '../utils/constants/tables';\n\nexport interface Client {\n  id: string;\n  created_at: string;\n  name: string;\n  email: string;\n  phone: string;\n  address?: string;\n  city?: string;\n  state?: string;\n  postal_code?: string;\n  birth_date?: string;\n  rfc?: string;\n  curp?: string;\n  company_id?: string;\n  advisor_id?: string;\n}\n\nexport interface ClientFilter {\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n  page?: number;\n  pageSize?: number;\n}\n\nexport interface ClientResult {\n  clients: any[];\n  totalCount: number;\n}\n\n// Nombre de la tabla definido como constante para evitar errores de escritura\nconst CLIENTS_TABLE = TABLES.CLIENTS || 'clients';\n\n// Get all clients with filters\nexport const getClients = async (filters: any = {}): Promise<ClientResult> => {\n  try {\n    const page = filters.page || 1;\n    const pageSize = filters.pageSize || 10;\n    const offset = (page - 1) * pageSize;\n    \n    // Construir condiciones de filtrado\n    const whereConditions = [];\n    \n    if (filters.search) {\n      const searchTerm = filters.search.trim();\n      whereConditions.push(`(name ILIKE '%${searchTerm}%' OR email ILIKE '%${searchTerm}%' OR phone ILIKE '%${searchTerm}%')`);\n    }\n    \n    if (filters.company_id) {\n      whereConditions.push(`company_id = '${filters.company_id}'`);\n    }\n    \n    const whereClause = whereConditions.length > 0 \n      ? `WHERE ${whereConditions.join(' AND ')}` \n      : '';\n    \n    // Consulta para obtener clientes paginados\n    const query = `\n      SELECT * FROM ${TABLES.CLIENTS}\n      ${whereClause}\n      ORDER BY created_at DESC\n      LIMIT ${pageSize} OFFSET ${offset}\n    `;\n    \n    // Consulta para obtener el total de clientes (para paginación)\n    const countQuery = `\n      SELECT COUNT(*) as total FROM ${TABLES.CLIENTS}\n      ${whereClause}\n    `;\n    \n    // Ejecutar ambas consultas\n    const clients = await executeQuery(query);\n    const totalResult = await executeQuery(countQuery);\n    \n    // Extraer el total de la respuesta de conteo\n    const totalCount = totalResult.length > 0 ? parseInt(totalResult[0].total || '0') : 0;\n    \n    // Retornar en el formato esperado por los componentes\n    return {\n      clients,\n      totalCount\n    };\n  } catch (error) {\n    console.error('Error al obtener clientes:', error);\n    return {\n      clients: [],\n      totalCount: 0\n    };\n  }\n};\n\n// Get a single client by ID\nexport const getClientById = async (id: string) => {\n  try {\n    const query = `SELECT * FROM ${CLIENTS_TABLE} WHERE id = '${id}'`;\n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return data[0] as Client;\n    }\n    \n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al obtener cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Escapa caracteres especiales en cadenas SQL\n */\nfunction escapeSQLString(str: string) {\n  return str.replace(/'/g, \"''\");\n}\n\n// Get applications for a specific client\nexport const getClientApplications = async (clientId: string) => {\n  try {\n    const query = `\n      SELECT * FROM ${TABLES.APPLICATIONS} \n      WHERE client_id = '${clientId}' OR source_id = '${clientId}'\n      ORDER BY created_at DESC\n    `;\n    \n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error al obtener aplicaciones del cliente ${clientId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new client\nexport const createClient = async (client: Omit<Client, 'id' | 'created_at'>) => {\n  try {\n    // Construir lista de campos y valores\n    const fields = Object.keys(client).join(', ');\n    const values = Object.values(client)\n      .map(value => typeof value === 'string' ? `'${escapeSQLString(value)}'` : value)\n      .join(', ');\n    \n    const query = `\n      INSERT INTO ${CLIENTS_TABLE} (${fields})\n      VALUES (${values})\n      RETURNING *\n    `;\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return data[0] as Client;\n    }\n    \n    throw new Error('Error al crear el cliente');\n  } catch (error) {\n    console.error('Error al crear cliente:', error);\n    throw error;\n  }\n};\n\n// Update an existing client\nexport const updateClient = async (id: string, updates: Partial<Client>) => {\n  try {\n    // Construir lista de cambios\n    const setClause = Object.entries(updates)\n      .map(([key, value]) => \n        `${key} = ${typeof value === 'string' ? `'${escapeSQLString(value)}'` : value}`\n      )\n      .join(', ');\n    \n    const query = `\n      UPDATE ${CLIENTS_TABLE}\n      SET ${setClause}\n      WHERE id = '${id}'\n      RETURNING *\n    `;\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return data[0] as Client;\n    }\n    \n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al actualizar cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete a client\nexport const deleteClient = async (id: string) => {\n  try {\n    const query = `\n      DELETE FROM ${CLIENTS_TABLE}\n      WHERE id = '${id}'\n      RETURNING id\n    `;\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return true;\n    }\n    \n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al eliminar cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Check if a client with the given email or RFC already exists\nexport const checkClientExists = async (email: string, rfc?: string) => {\n  try {\n    let query = `\n      SELECT id, email, rfc FROM ${CLIENTS_TABLE}\n      WHERE email = '${escapeSQLString(email)}'\n    `;\n    \n    if (rfc) {\n      query += ` OR rfc = '${escapeSQLString(rfc)}'`;\n    }\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return {\n        exists: true,\n        client: data[0]\n      };\n    }\n    \n    return { exists: false };\n  } catch (error) {\n    console.error('Error al verificar existencia de cliente:', error);\n    throw error;\n  }\n};\n\n// Get total count of clients with filters\nexport const getClientCount = async (filters?: ClientFilter) => {\n  try {\n    let query = `SELECT COUNT(*) as count FROM ${CLIENTS_TABLE} WHERE 1=1`;\n    \n    // Aplicar filtros si existen\n    if (filters) {\n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        query += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n      \n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n      \n      // Filtro por empresa\n      if (filters.company_id) {\n        query += ` AND company_id = '${filters.company_id}'`;\n      }\n    }\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return parseInt(data[0].count) || 0;\n    }\n    \n    return 0;\n  } catch (error) {\n    console.error('Error al obtener conteo de clientes:', error);\n    return 0;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}