{"ast":null,"code":"import { supabase, getServiceClient } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { checkTableExists } from '../utils/dbStructureCheck';\nimport { ErrorType, createAppError, logError } from '../utils/errorHandling';\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async client => {\n  const supabaseClient = client || supabase;\n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const {\n      error\n    } = await supabaseClient.storage.from(STORAGE_BUCKET).list();\n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || errorMessage.includes('does not exist') || errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async applicationId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('application_id', applicationId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async clientId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('client_id', clientId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async id => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('id', id).single();\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Upload a document\nexport const uploadDocument = async ({\n  application_id,\n  client_id,\n  file,\n  category,\n  userId\n}) => {\n  const supabaseClient = getServiceClient();\n  try {\n    var _uploadError;\n    // Verificar si la tabla existe antes de intentar operaciones\n    const tableExists = await checkTableExists(DOCUMENTS_TABLE);\n    if (!tableExists) {\n      logError(`La tabla ${DOCUMENTS_TABLE} no existe. Por favor, ejecute el script de creación de tablas.`, 'documentService.uploadDocument', {\n        table: DOCUMENTS_TABLE\n      });\n      throw createAppError(ErrorType.DATABASE, `Error de configuración: La tabla de documentos no está correctamente configurada.`, {\n        table: DOCUMENTS_TABLE\n      });\n    }\n\n    // Verificar si el bucket de storage existe\n    const {\n      data: buckets\n    } = await supabaseClient.storage.listBuckets();\n    const bucketExists = buckets === null || buckets === void 0 ? void 0 : buckets.some(bucket => bucket.name === STORAGE_BUCKET);\n    if (!bucketExists) {\n      logError(`El bucket ${STORAGE_BUCKET} no existe.`, 'documentService.uploadDocument', {\n        bucket: STORAGE_BUCKET\n      });\n      throw createAppError(ErrorType.UPLOAD, `Error de configuración: El almacenamiento de documentos no está correctamente configurado.`, {\n        bucket: STORAGE_BUCKET\n      });\n    }\n\n    // Generar información del archivo\n    const fileName = file.name;\n    const fileType = file.type;\n    const fileSize = file.size;\n\n    // Crear registro del documento\n    const {\n      data,\n      error\n    } = await supabaseClient.from(DOCUMENTS_TABLE).insert({\n      file_name: fileName,\n      file_type: fileType,\n      file_size: fileSize,\n      category,\n      application_id,\n      client_id,\n      uploaded_by_user_id: userId,\n      is_verified: false\n    }).select('*').single();\n    if (error) {\n      // Verificar si es un error de RLS\n      if (error.message && error.message.includes('policy')) {\n        logError(`Violación de política RLS al crear documento: ${error.message}`, 'documentService.uploadDocument', {\n          error\n        });\n        throw createAppError(ErrorType.AUTHORIZATION, 'No tienes permisos para crear documentos para este cliente o aplicación', {\n          error: error.message\n        });\n      }\n      logError(`Error al crear documento: ${error.message}`, 'documentService.uploadDocument', {\n        error\n      });\n      throw createAppError(ErrorType.DATABASE, 'Error al crear documento en la base de datos', {\n        error: error.message\n      });\n    }\n    if (!data) {\n      logError('No se retornaron datos al crear documento', 'documentService.uploadDocument');\n      throw createAppError(ErrorType.DATABASE, 'Error al crear documento en la base de datos');\n    }\n    const documentId = data.id;\n\n    // Construir nombre único para el archivo\n    const fileExtension = fileName.split('.').pop();\n    const uniqueFileName = `${documentId}.${fileExtension}`;\n    const filePath = `${client_id || application_id}/${uniqueFileName}`;\n\n    // Intentar subir el archivo con reintentos\n    let uploadError = null;\n    const maxRetries = 3;\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        // Subir el archivo al storage\n        const {\n          error: uploadError\n        } = await supabaseClient.storage.from(STORAGE_BUCKET).upload(filePath, file, {\n          upsert: true,\n          cacheControl: '3600'\n        });\n        if (uploadError) {\n          throw uploadError;\n        }\n\n        // Obtener URL pública del archivo\n        const {\n          data: publicUrlData\n        } = supabaseClient.storage.from(STORAGE_BUCKET).getPublicUrl(filePath);\n\n        // Actualizar el documento con la ruta del archivo\n        const {\n          error: updateError\n        } = await supabaseClient.from(DOCUMENTS_TABLE).update({\n          file_path: filePath\n        }).eq('id', documentId);\n        if (updateError) {\n          logError({\n            message: `Error al actualizar ruta del documento: ${updateError.message}`,\n            type: ErrorType.DATABASE_ERROR,\n            module: 'documentService',\n            function: 'uploadDocument'\n          });\n        }\n\n        // Construir y devolver el documento\n        return {\n          id: documentId,\n          applicationId: application_id || null,\n          clientId: client_id || null,\n          fileName,\n          filePath,\n          fileType,\n          fileSize,\n          category,\n          uploadedByUserId: userId,\n          isVerified: false,\n          createdAt: data.created_at,\n          publicUrl: publicUrlData.publicUrl\n        };\n      } catch (error) {\n        uploadError = error;\n\n        // Esperar con backoff exponencial antes de reintentar\n        if (attempt < maxRetries - 1) {\n          const waitTime = Math.pow(2, attempt) * 1000;\n          console.log(`Reintentando subir documento en ${waitTime}ms...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n\n    // Si llegamos aquí, todos los intentos fallaron\n    logError({\n      message: `Error al subir documento después de ${maxRetries} intentos: ${((_uploadError = uploadError) === null || _uploadError === void 0 ? void 0 : _uploadError.message) || 'Error desconocido'}`,\n      type: ErrorType.STORAGE_ERROR,\n      module: 'documentService',\n      function: 'uploadDocument'\n    });\n\n    // Intentar eliminar el documento creado\n    try {\n      await supabaseClient.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    } catch (deleteError) {\n      console.warn(`No se pudo eliminar el documento huérfano: ${deleteError}`);\n    }\n    throw createAppError({\n      message: 'Error al subir el archivo al sistema',\n      type: ErrorType.STORAGE_ERROR\n    });\n  } catch (error) {\n    // Si el error ya es un AppError, rethrow\n    if (error && error.isAppError) {\n      throw error;\n    }\n    logError(`Error inesperado en uploadDocument: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`, 'documentService.uploadDocument', {\n      error\n    });\n    throw createAppError(ErrorType.UNKNOWN, 'Error inesperado al subir documento', {\n      error: error === null || error === void 0 ? void 0 : error.message\n    });\n  }\n};\n\n// Delete a document\nexport const deleteDocument = async documentId => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n\n    // Get document to get file path\n    const {\n      data: document,\n      error: fetchError\n    } = await supabase.from(DOCUMENTS_TABLE).select('file_path').eq('id', documentId).single();\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const {\n      error: storageError\n    } = await supabase.storage.from(STORAGE_BUCKET).remove([document.file_path]);\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error ? storageError.message : typeof storageError === 'object' && storageError !== null && 'message' in storageError ? String(storageError.message) : 'Error desconocido';\n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const {\n      error: deleteError\n    } = await supabase.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async filePath => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    const {\n      data,\n      error\n    } = await supabase.storage.from(STORAGE_BUCKET).createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId, userId, isVerified = true) => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).update({\n    is_verified: isVerified,\n    verified_by: userId,\n    verified_at: new Date().toISOString()\n  }).eq('id', documentId).select();\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n  return data[0];\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async applicationType => {\n  const {\n    data,\n    error\n  } = await supabase.from('required_documents').select('*').eq('application_type', applicationType);\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n  return data;\n};","map":{"version":3,"names":["supabase","getServiceClient","TABLES","checkTableExists","ErrorType","createAppError","logError","DOCUMENTS_TABLE","DOCUMENTS","STORAGE_BUCKET","ensureStorageBucketExists","client","supabaseClient","error","storage","from","list","errorMessage","message","includes","console","log","Error","getApplicationDocuments","applicationId","data","select","eq","order","ascending","getClientDocuments","clientId","getDocumentById","id","single","uploadDocument","application_id","client_id","file","category","userId","_uploadError","tableExists","table","DATABASE","buckets","listBuckets","bucketExists","some","bucket","name","UPLOAD","fileName","fileType","type","fileSize","size","insert","file_name","file_type","file_size","uploaded_by_user_id","is_verified","AUTHORIZATION","documentId","fileExtension","split","pop","uniqueFileName","filePath","uploadError","maxRetries","attempt","upload","upsert","cacheControl","publicUrlData","getPublicUrl","updateError","update","file_path","DATABASE_ERROR","module","function","uploadedByUserId","isVerified","createdAt","created_at","publicUrl","waitTime","Math","pow","Promise","resolve","setTimeout","STORAGE_ERROR","delete","deleteError","warn","isAppError","UNKNOWN","deleteDocument","document","fetchError","storageError","remove","String","getDocumentUrl","createSignedUrl","signedUrl","verifyDocument","verified_by","verified_at","Date","toISOString","getRequiredDocuments","applicationType"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/documentService.ts"],"sourcesContent":["import { supabase, getServiceClient } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { checkTableExists } from '../utils/dbStructureCheck';\nimport { \n  ErrorType, \n  createAppError, \n  logError \n} from '../utils/errorHandling';\n\nexport interface Document {\n  id: string;\n  created_at: string;\n  file_name: string;\n  file_path: string;\n  file_type: string;\n  file_size: number;\n  category?: string;\n  application_id?: string;\n  client_id?: string;\n  uploaded_by_user_id?: string;\n  is_verified?: boolean;\n  verified_by?: string;\n  verified_at?: string;\n}\n\nexport interface DocumentUpload {\n  file: File;\n  application_id?: string;\n  client_id?: string;\n  userId: string;\n  documentName: string;\n  description?: string;\n  category?: string;\n  authClient?: SupabaseClient;\n}\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\nexport type UploadDocumentParams = DocumentUpload;\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async (client?: SupabaseClient) => {\n  const supabaseClient = client || supabase;\n  \n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const { error } = await supabaseClient.storage\n      .from(STORAGE_BUCKET)\n      .list();\n    \n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || \n          errorMessage.includes('does not exist') || \n          errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    \n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async (applicationId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('application_id', applicationId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async (clientId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('client_id', clientId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async (id: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n\n  return data as Document;\n};\n\n// Upload a document\nexport const uploadDocument = async ({\n  application_id,\n  client_id,\n  file,\n  category,\n  userId\n}: DocumentUpload): Promise<Document> => {\n  const supabaseClient = getServiceClient();\n  \n  try {\n    // Verificar si la tabla existe antes de intentar operaciones\n    const tableExists = await checkTableExists(DOCUMENTS_TABLE);\n    if (!tableExists) {\n      logError(\n        `La tabla ${DOCUMENTS_TABLE} no existe. Por favor, ejecute el script de creación de tablas.`,\n        'documentService.uploadDocument',\n        { table: DOCUMENTS_TABLE }\n      );\n      throw createAppError(\n        ErrorType.DATABASE,\n        `Error de configuración: La tabla de documentos no está correctamente configurada.`,\n        { table: DOCUMENTS_TABLE }\n      );\n    }\n    \n    // Verificar si el bucket de storage existe\n    const { data: buckets } = await supabaseClient.storage.listBuckets();\n    const bucketExists = buckets?.some((bucket: any) => bucket.name === STORAGE_BUCKET);\n    \n    if (!bucketExists) {\n      logError(\n        `El bucket ${STORAGE_BUCKET} no existe.`,\n        'documentService.uploadDocument',\n        { bucket: STORAGE_BUCKET }\n      );\n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error de configuración: El almacenamiento de documentos no está correctamente configurado.`,\n        { bucket: STORAGE_BUCKET }\n      );\n    }\n    \n    // Generar información del archivo\n    const fileName = file.name;\n    const fileType = file.type;\n    const fileSize = file.size;\n    \n    // Crear registro del documento\n    const { data, error } = await supabaseClient\n      .from(DOCUMENTS_TABLE)\n      .insert({\n        file_name: fileName,\n        file_type: fileType,\n        file_size: fileSize,\n        category,\n        application_id,\n        client_id,\n        uploaded_by_user_id: userId,\n        is_verified: false\n      })\n      .select('*')\n      .single();\n      \n    if (error) {\n      // Verificar si es un error de RLS\n      if (error.message && error.message.includes('policy')) {\n        logError(\n          `Violación de política RLS al crear documento: ${error.message}`,\n          'documentService.uploadDocument',\n          { error }\n        );\n        throw createAppError(\n          ErrorType.AUTHORIZATION,\n          'No tienes permisos para crear documentos para este cliente o aplicación',\n          { error: error.message }\n        );\n      }\n      \n      logError(\n        `Error al crear documento: ${error.message}`,\n        'documentService.uploadDocument',\n        { error }\n      );\n      throw createAppError(\n        ErrorType.DATABASE,\n        'Error al crear documento en la base de datos',\n        { error: error.message }\n      );\n    }\n    \n    if (!data) {\n      logError(\n        'No se retornaron datos al crear documento',\n        'documentService.uploadDocument'\n      );\n      throw createAppError(\n        ErrorType.DATABASE,\n        'Error al crear documento en la base de datos'\n      );\n    }\n    \n    const documentId = data.id;\n    \n    // Construir nombre único para el archivo\n    const fileExtension = fileName.split('.').pop();\n    const uniqueFileName = `${documentId}.${fileExtension}`;\n    const filePath = `${client_id || application_id}/${uniqueFileName}`;\n    \n    // Intentar subir el archivo con reintentos\n    let uploadError: any = null;\n    const maxRetries = 3;\n    \n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        // Subir el archivo al storage\n        const { error: uploadError } = await supabaseClient.storage\n          .from(STORAGE_BUCKET)\n          .upload(filePath, file, {\n            upsert: true,\n            cacheControl: '3600'\n          });\n          \n        if (uploadError) {\n          throw uploadError;\n        }\n        \n        // Obtener URL pública del archivo\n        const { data: publicUrlData } = supabaseClient.storage\n          .from(STORAGE_BUCKET)\n          .getPublicUrl(filePath);\n          \n        // Actualizar el documento con la ruta del archivo\n        const { error: updateError } = await supabaseClient\n          .from(DOCUMENTS_TABLE)\n          .update({\n            file_path: filePath\n          })\n          .eq('id', documentId);\n          \n        if (updateError) {\n          logError({\n            message: `Error al actualizar ruta del documento: ${updateError.message}`,\n            type: ErrorType.DATABASE_ERROR,\n            module: 'documentService',\n            function: 'uploadDocument'\n          });\n        }\n        \n        // Construir y devolver el documento\n        return {\n          id: documentId,\n          applicationId: application_id || null,\n          clientId: client_id || null,\n          fileName,\n          filePath,\n          fileType,\n          fileSize,\n          category,\n          uploadedByUserId: userId,\n          isVerified: false,\n          createdAt: data.created_at,\n          publicUrl: publicUrlData.publicUrl\n        };\n      } catch (error) {\n        uploadError = error;\n        \n        // Esperar con backoff exponencial antes de reintentar\n        if (attempt < maxRetries - 1) {\n          const waitTime = Math.pow(2, attempt) * 1000;\n          console.log(`Reintentando subir documento en ${waitTime}ms...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n    \n    // Si llegamos aquí, todos los intentos fallaron\n    logError({\n      message: `Error al subir documento después de ${maxRetries} intentos: ${uploadError?.message || 'Error desconocido'}`,\n      type: ErrorType.STORAGE_ERROR,\n      module: 'documentService',\n      function: 'uploadDocument'\n    });\n    \n    // Intentar eliminar el documento creado\n    try {\n      await supabaseClient\n        .from(DOCUMENTS_TABLE)\n        .delete()\n        .eq('id', documentId);\n    } catch (deleteError) {\n      console.warn(`No se pudo eliminar el documento huérfano: ${deleteError}`);\n    }\n    \n    throw createAppError({\n      message: 'Error al subir el archivo al sistema',\n      type: ErrorType.STORAGE_ERROR\n    });\n  } catch (error) {\n    // Si el error ya es un AppError, rethrow\n    if (error && (error as any).isAppError) {\n      throw error;\n    }\n    \n    logError(\n      `Error inesperado en uploadDocument: ${(error as any)?.message || 'Error desconocido'}`,\n      'documentService.uploadDocument',\n      { error }\n    );\n    \n    throw createAppError(\n      ErrorType.UNKNOWN,\n      'Error inesperado al subir documento',\n      { error: (error as any)?.message }\n    );\n  }\n};\n\n// Delete a document\nexport const deleteDocument = async (documentId: string) => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n    \n    // Get document to get file path\n    const { data: document, error: fetchError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .select('file_path')\n      .eq('id', documentId)\n      .single();\n\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const { error: storageError } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .remove([document.file_path]);\n\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error \n        ? storageError.message \n        : (typeof storageError === 'object' && storageError !== null && 'message' in storageError)\n          ? String((storageError as {message: string}).message)\n          : 'Error desconocido';\n      \n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const { error: deleteError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .delete()\n      .eq('id', documentId);\n\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async (filePath: string) => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    \n    const { data, error } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId: string, userId: string, isVerified: boolean = true) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .update({\n      is_verified: isVerified,\n      verified_by: userId,\n      verified_at: new Date().toISOString()\n    })\n    .eq('id', documentId)\n    .select();\n\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n\n  return data[0] as Document;\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async (applicationType: string) => {\n  const { data, error } = await supabase\n    .from('required_documents')\n    .select('*')\n    .eq('application_type', applicationType);\n\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n\n  return data;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}