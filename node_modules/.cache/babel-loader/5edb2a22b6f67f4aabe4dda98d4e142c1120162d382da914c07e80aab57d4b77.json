{"ast":null,"code":"import { TABLES } from '../utils/constants/tables';\nimport { APPLICATION_STATUS } from '../utils/constants/statuses';\nimport { executeQuery } from '../utils/databaseUtils';\n\n// Verify if APPLICATION_HISTORY table is defined in TABLES\nlet APPLICATION_HISTORY_TABLE = TABLES.APPLICATION_HISTORY;\nif (!APPLICATION_HISTORY_TABLE) {\n  // If not defined, create a fallback\n  APPLICATION_HISTORY_TABLE = 'application_history';\n}\n\n// Define the type of application statuses\n\n// Define application interface\n\n// Get all applications with filters\nexport const getApplications = async (filters, entityFilter) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE 1=1`;\n\n  // Aplicar filtro por entidad (asesor o empresa)\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n\n  // Aplicar otros filtros\n  if (filters) {\n    // Filter by status\n    if (filters.status && filters.status !== 'all') {\n      query += ` AND status = '${filters.status}'`;\n    }\n\n    // Filter by application type\n    if (filters.application_type && filters.application_type !== 'all') {\n      query += ` AND application_type = '${filters.application_type}'`;\n    }\n\n    // Filter by advisor\n    if (filters.advisor_id) {\n      query += ` AND assigned_to = '${filters.advisor_id}'`;\n    }\n\n    // Filter by company\n    if (filters.company_id) {\n      query += ` AND company_id = '${filters.company_id}'`;\n    }\n\n    // Filter by date range\n    if (filters.dateFrom) {\n      query += ` AND created_at >= '${filters.dateFrom}'`;\n    }\n    if (filters.dateTo) {\n      query += ` AND created_at <= '${filters.dateTo}'`;\n    }\n\n    // Filter by amount range\n    if (filters.amountMin !== undefined) {\n      query += ` AND amount >= ${filters.amountMin}`;\n    }\n    if (filters.amountMax !== undefined) {\n      query += ` AND amount <= ${filters.amountMax}`;\n    }\n\n    // Search by name, email or phone (ajustado a los campos reales)\n    if (filters.searchQuery) {\n      query += ` AND (\n        client_name ILIKE '%${filters.searchQuery}%' OR \n        client_email ILIKE '%${filters.searchQuery}%'\n      )`;\n    }\n  }\n\n  // Ordenar por fecha de creación más reciente\n  query += ` ORDER BY created_at DESC`;\n  try {\n    const data = await executeQuery(query);\n\n    // Mapear los campos de la BD a nuestra interfaz\n    return data.map(app => ({\n      id: app.id,\n      client_id: app.source_id || \"\",\n      company_id: app.company_id || \"\",\n      assigned_to: app.assigned_to || \"\",\n      application_type: app.application_type || \"\",\n      requested_amount: parseFloat(app.amount) || 0,\n      status: mapStatusFromDB(app.status),\n      created_at: app.created_at,\n      updated_at: app.updated_at,\n      client_name: app.client_name,\n      client_email: app.client_email,\n      company_name: app.company_name,\n      advisor_name: \"\",\n      // Este campo no está en la BD\n      approved_by_advisor: app.approved_by_advisor || false,\n      approved_by_company: app.approved_by_company || false,\n      approval_date_advisor: app.approval_date_advisor,\n      approval_date_company: app.approval_date_company,\n      // Mapeo directo de campos adicionales de la BD\n      client_phone: app.client_phone,\n      client_address: app.client_address,\n      dni: app.dni,\n      amount: parseFloat(app.amount) || 0,\n      term: app.term ? parseInt(app.term) : undefined,\n      interest_rate: app.interest_rate ? parseFloat(app.interest_rate) : undefined,\n      monthly_payment: app.monthly_payment ? parseFloat(app.monthly_payment) : undefined\n    }));\n  } catch (error) {\n    console.error('Error fetching applications:', error);\n    throw error;\n  }\n};\n\n// Función auxiliar para mapear estados de la BD a nuestro enum\nconst mapStatusFromDB = dbStatus => {\n  // Si el estado es undefined o null, devolver un valor por defecto\n  if (dbStatus === undefined || dbStatus === null) {\n    console.log('Estado de BD es undefined o null, usando PENDING como valor por defecto');\n    return APPLICATION_STATUS.PENDING;\n  }\n\n  // Primero verificamos si coincide con algún enum directamente\n  const directMapping = Object.values(APPLICATION_STATUS).find(status => status.toLowerCase() === dbStatus.toLowerCase());\n  if (directMapping) {\n    return directMapping;\n  }\n\n  // Si no hay coincidencia directa, usamos un mapeo manual\n  const statusMap = {\n    'Solicitud': APPLICATION_STATUS.SOLICITUD,\n    'Pendiente': APPLICATION_STATUS.PENDING,\n    'En Revisión': APPLICATION_STATUS.IN_REVIEW,\n    'Revisión': APPLICATION_STATUS.IN_REVIEW,\n    'Aprobado': APPLICATION_STATUS.APPROVED,\n    'Rechazado': APPLICATION_STATUS.REJECTED,\n    'Por Dispersar': APPLICATION_STATUS.POR_DISPERSAR,\n    'Completado': APPLICATION_STATUS.COMPLETED,\n    'Cancelado': APPLICATION_STATUS.CANCELLED,\n    'Expirado': APPLICATION_STATUS.EXPIRED\n  };\n  console.log(`Mapeando estado desde BD: \"${dbStatus}\" -> \"${statusMap[dbStatus] || APPLICATION_STATUS.PENDING}\"`);\n  return statusMap[dbStatus] || APPLICATION_STATUS.PENDING;\n};\n\n// Get a single application by ID\nexport const getApplicationById = async (id, entityFilter) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Application not found');\n  } catch (error) {\n    console.error(`Error fetching application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Create a new application\nexport const createApplication = async application => {\n  const fields = Object.keys(application).join(', ');\n  const values = Object.values(application).map(val => typeof val === 'string' ? `'${val}'` : val).join(', ');\n  const query = `\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;\n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error('Error creating application:', error);\n    throw error;\n  }\n};\n\n// Update an existing application\nexport const updateApplication = async (id, updates, entityFilter) => {\n  const setClause = Object.entries(updates).map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`).join(', ');\n  let query = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  query += ' RETURNING *';\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Application not found or you do not have permission to update it');\n  } catch (error) {\n    console.error(`Error updating application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Update application status and add to history\nexport const updateApplicationStatus = async (id, status, comment, user_id, entityFilter) => {\n  // 1. Obtener estado actual de la aplicación\n  let currentQuery = `\n    SELECT status FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      currentQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      currentQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    // Obtener el estado actual\n    const currentState = await executeQuery(currentQuery);\n    if (!currentState || currentState.length === 0) {\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    const currentStatus = currentState[0].status;\n\n    // 2. Actualizar el estado de la aplicación\n    let updateQuery = `\n      UPDATE ${TABLES.APPLICATIONS}\n      SET status = '${status}',\n          status_previous = '${currentStatus}'\n    `;\n\n    // Si el nuevo estado es \"completed\", actualizar la fecha de dispersión\n    if (status === 'completed') {\n      updateQuery += `, dispersal_date = NOW()`;\n    }\n    updateQuery += ` WHERE id = '${id}'`;\n\n    // Aplicar filtro por entidad si es necesario\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        updateQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n      }\n      if (entityFilter.company_id) {\n        updateQuery += ` AND company_id = '${entityFilter.company_id}'`;\n      }\n    }\n    updateQuery += ' RETURNING *';\n\n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n\n    // 3. Añadir al historial\n    const historyComment = currentStatus !== status ? `${comment} (Cambio de estado: ${currentStatus} → ${status})` : comment;\n    const historyQuery = `\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', '${status}', '${historyComment}', '${user_id}')\n      RETURNING *\n    `;\n    await executeQuery(historyQuery);\n    console.log(`Estado de aplicación actualizado: ${currentStatus} → ${status}`);\n    return updatedApp[0];\n  } catch (error) {\n    console.error(`Error updating status of application ${id}:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por asesor\nexport const approveByAdvisor = async (id, comment, advisor_id, entityFilter) => {\n  // Verificar que el usuario es realmente un asesor\n  if (!(entityFilter !== null && entityFilter !== void 0 && entityFilter.advisor_id)) {\n    throw new Error('Solo los asesores pueden realizar esta acción');\n  }\n\n  // Actualizar la solicitud\n  let updateQuery = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET approved_by_advisor = true, \n        approval_date_advisor = NOW()\n    WHERE id = '${id}' AND assigned_to = '${advisor_id}'\n    RETURNING *\n  `;\n  try {\n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n\n    // Añadir al historial\n    const historyQuery = `\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', 'approved_by_advisor', '${comment}', '${advisor_id}')\n      RETURNING *\n    `;\n    await executeQuery(historyQuery);\n\n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0];\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'approved') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");\n\n      // Si ambos han aprobado, actualizar el estado a aprobado\n      return await updateApplicationStatus(id, 'approved', 'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', advisor_id, entityFilter);\n    }\n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por empresa\nexport const approveByCompany = async (id, comment, company_admin_id, company_id, entityFilter) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!(entityFilter !== null && entityFilter !== void 0 && entityFilter.company_id) || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n\n  // Actualizar la solicitud\n  let updateQuery = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET approved_by_company = true, \n        approval_date_company = NOW()\n    WHERE id = '${id}' AND company_id = '${company_id}'\n    RETURNING *\n  `;\n  try {\n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n\n    // Añadir al historial\n    const historyQuery = `\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', 'approved_by_company', '${comment}', '${company_admin_id}')\n      RETURNING *\n    `;\n    await executeQuery(historyQuery);\n\n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0];\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'approved') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");\n\n      // Si ambos han aprobado, actualizar el estado a aprobado\n      return await updateApplicationStatus(id, 'approved', 'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', company_admin_id, entityFilter);\n    }\n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Obtener estado de aprobación de una solicitud\nexport const getApprovalStatus = async (id, entityFilter) => {\n  let query = `\n    SELECT \n      approved_by_advisor, \n      approved_by_company, \n      approval_date_advisor, \n      approval_date_company\n    FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return {\n        approvedByAdvisor: data[0].approved_by_advisor || false,\n        approvedByCompany: data[0].approved_by_company || false,\n        approvalDateAdvisor: data[0].approval_date_advisor,\n        approvalDateCompany: data[0].approval_date_company\n      };\n    }\n    throw new Error('Solicitud no encontrada');\n  } catch (error) {\n    console.error(`Error obteniendo estado de aprobación para solicitud ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete an application\nexport const deleteApplication = async (id, entityFilter) => {\n  let query = `DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    await executeQuery(query);\n    return true;\n  } catch (error) {\n    console.error(`Error deleting application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Get application history\nexport const getApplicationHistory = async (applicationId, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para ver esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view it');\n    }\n  }\n  const query = `\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${APPLICATION_HISTORY_TABLE} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;\n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching history for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Add a comment to an application\nexport const addComment = async (applicationId, userId, text, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para comentar esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to comment on it');\n    }\n  }\n  const query = `\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;\n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error(`Error adding comment to application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Get comments for an application\nexport const getComments = async (applicationId, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view its comments');\n    }\n  }\n  const query = `\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;\n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching comments for application ${applicationId}:`, error);\n    throw error;\n  }\n};","map":{"version":3,"names":["TABLES","APPLICATION_STATUS","executeQuery","APPLICATION_HISTORY_TABLE","APPLICATION_HISTORY","getApplications","filters","entityFilter","query","APPLICATIONS","advisor_id","company_id","status","application_type","dateFrom","dateTo","amountMin","undefined","amountMax","searchQuery","data","map","app","id","client_id","source_id","assigned_to","requested_amount","parseFloat","amount","mapStatusFromDB","created_at","updated_at","client_name","client_email","company_name","advisor_name","approved_by_advisor","approved_by_company","approval_date_advisor","approval_date_company","client_phone","client_address","dni","term","parseInt","interest_rate","monthly_payment","error","console","dbStatus","log","PENDING","directMapping","Object","values","find","toLowerCase","statusMap","SOLICITUD","IN_REVIEW","APPROVED","REJECTED","POR_DISPERSAR","COMPLETED","CANCELLED","EXPIRED","getApplicationById","length","Error","createApplication","application","fields","keys","join","val","updateApplication","updates","setClause","entries","key","value","updateApplicationStatus","comment","user_id","currentQuery","currentState","currentStatus","updateQuery","updatedApp","historyComment","historyQuery","approveByAdvisor","approveByCompany","company_admin_id","getApprovalStatus","approvedByAdvisor","approvedByCompany","approvalDateAdvisor","approvalDateCompany","deleteApplication","getApplicationHistory","applicationId","appQuery","addComment","userId","text","COMMENTS","getComments"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/applicationService.ts"],"sourcesContent":["import { TABLES } from '../utils/constants/tables';\nimport { APPLICATION_STATUS } from '../utils/constants/statuses';\nimport { executeQuery } from '../utils/databaseUtils';\n\n// Verify if APPLICATION_HISTORY table is defined in TABLES\nlet APPLICATION_HISTORY_TABLE = TABLES.APPLICATION_HISTORY;\nif (!APPLICATION_HISTORY_TABLE) {\n  // If not defined, create a fallback\n  APPLICATION_HISTORY_TABLE = 'application_history';\n}\n\n// Define the type of application statuses\nexport type ApplicationStatus = 'pending' | 'in_review' | 'approved' | 'rejected' | 'cancelled' | 'expired' | 'completed' | 'solicitud' | 'new' | 'por_dispersar';\n\n// Define application interface\nexport interface Application {\n  id: string;\n  client_id: string;\n  company_id: string;\n  assigned_to: string;\n  application_type: string;\n  requested_amount: number;\n  status: ApplicationStatus;\n  status_previous?: string;\n  created_at: string;\n  updated_at: string;\n  client_name?: string;\n  client_email?: string;\n  client_phone?: string;\n  client_address?: string;\n  company_name?: string;\n  advisor_name?: string;\n  approved_by_advisor: boolean;\n  approved_by_company: boolean;\n  approval_date_advisor?: string;\n  approval_date_company?: string;\n  dispersal_date?: string;\n  dni?: string;\n  \n  // Campos adicionales que necesitan los formularios\n  amount?: number;\n  term?: number;\n  interest_rate?: number;\n  monthly_payment?: number;\n}\n\nexport interface ApplicationFilter {\n  status?: string;\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n  application_type?: string;\n  amountMin?: number;\n  amountMax?: number;\n}\n\n// Get all applications with filters\nexport const getApplications = async (filters?: ApplicationFilter, entityFilter?: Record<string, any> | null) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE 1=1`;\n  \n  // Aplicar filtro por entidad (asesor o empresa)\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n\n  // Aplicar otros filtros\n  if (filters) {\n    // Filter by status\n    if (filters.status && filters.status !== 'all') {\n      query += ` AND status = '${filters.status}'`;\n    }\n\n    // Filter by application type\n    if (filters.application_type && filters.application_type !== 'all') {\n      query += ` AND application_type = '${filters.application_type}'`;\n    }\n\n    // Filter by advisor\n    if (filters.advisor_id) {\n      query += ` AND assigned_to = '${filters.advisor_id}'`;\n    }\n\n    // Filter by company\n    if (filters.company_id) {\n      query += ` AND company_id = '${filters.company_id}'`;\n    }\n\n    // Filter by date range\n    if (filters.dateFrom) {\n      query += ` AND created_at >= '${filters.dateFrom}'`;\n    }\n\n    if (filters.dateTo) {\n      query += ` AND created_at <= '${filters.dateTo}'`;\n    }\n\n    // Filter by amount range\n    if (filters.amountMin !== undefined) {\n      query += ` AND amount >= ${filters.amountMin}`;\n    }\n\n    if (filters.amountMax !== undefined) {\n      query += ` AND amount <= ${filters.amountMax}`;\n    }\n\n    // Search by name, email or phone (ajustado a los campos reales)\n    if (filters.searchQuery) {\n      query += ` AND (\n        client_name ILIKE '%${filters.searchQuery}%' OR \n        client_email ILIKE '%${filters.searchQuery}%'\n      )`;\n    }\n  }\n\n  // Ordenar por fecha de creación más reciente\n  query += ` ORDER BY created_at DESC`;\n\n  try {\n    const data = await executeQuery(query);\n    \n    // Mapear los campos de la BD a nuestra interfaz\n    return data.map((app: any) => ({\n      id: app.id,\n      client_id: app.source_id || \"\",\n      company_id: app.company_id || \"\",\n      assigned_to: app.assigned_to || \"\",\n      application_type: app.application_type || \"\",\n      requested_amount: parseFloat(app.amount) || 0,\n      status: mapStatusFromDB(app.status),\n      created_at: app.created_at,\n      updated_at: app.updated_at,\n      client_name: app.client_name,\n      client_email: app.client_email,\n      company_name: app.company_name,\n      advisor_name: \"\", // Este campo no está en la BD\n      approved_by_advisor: app.approved_by_advisor || false,\n      approved_by_company: app.approved_by_company || false,\n      approval_date_advisor: app.approval_date_advisor,\n      approval_date_company: app.approval_date_company,\n      \n      // Mapeo directo de campos adicionales de la BD\n      client_phone: app.client_phone,\n      client_address: app.client_address,\n      dni: app.dni,\n      amount: parseFloat(app.amount) || 0,\n      term: app.term ? parseInt(app.term) : undefined,\n      interest_rate: app.interest_rate ? parseFloat(app.interest_rate) : undefined,\n      monthly_payment: app.monthly_payment ? parseFloat(app.monthly_payment) : undefined,\n    })) as Application[];\n  } catch (error) {\n    console.error('Error fetching applications:', error);\n    throw error;\n  }\n};\n\n// Función auxiliar para mapear estados de la BD a nuestro enum\nconst mapStatusFromDB = (dbStatus: string | undefined | null): ApplicationStatus => {\n  // Si el estado es undefined o null, devolver un valor por defecto\n  if (dbStatus === undefined || dbStatus === null) {\n    console.log('Estado de BD es undefined o null, usando PENDING como valor por defecto');\n    return APPLICATION_STATUS.PENDING;\n  }\n  \n  // Primero verificamos si coincide con algún enum directamente\n  const directMapping = Object.values(APPLICATION_STATUS).find(status => \n    status.toLowerCase() === dbStatus.toLowerCase()\n  );\n  \n  if (directMapping) {\n    return directMapping as ApplicationStatus;\n  }\n  \n  // Si no hay coincidencia directa, usamos un mapeo manual\n  const statusMap: Record<string, ApplicationStatus> = {\n    'Solicitud': APPLICATION_STATUS.SOLICITUD,\n    'Pendiente': APPLICATION_STATUS.PENDING,\n    'En Revisión': APPLICATION_STATUS.IN_REVIEW,\n    'Revisión': APPLICATION_STATUS.IN_REVIEW,\n    'Aprobado': APPLICATION_STATUS.APPROVED,\n    'Rechazado': APPLICATION_STATUS.REJECTED,\n    'Por Dispersar': APPLICATION_STATUS.POR_DISPERSAR,\n    'Completado': APPLICATION_STATUS.COMPLETED,\n    'Cancelado': APPLICATION_STATUS.CANCELLED,\n    'Expirado': APPLICATION_STATUS.EXPIRED\n  };\n  \n  console.log(`Mapeando estado desde BD: \"${dbStatus}\" -> \"${statusMap[dbStatus] || APPLICATION_STATUS.PENDING}\"`);\n  return statusMap[dbStatus] || APPLICATION_STATUS.PENDING;\n};\n\n// Get a single application by ID\nexport const getApplicationById = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found');\n  } catch (error) {\n    console.error(`Error fetching application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Create a new application\nexport const createApplication = async (application: Omit<Application, 'id' | 'created_at' | 'updated_at'>) => {\n  const fields = Object.keys(application).join(', ');\n  const values = Object.values(application)\n    .map(val => (typeof val === 'string' ? `'${val}'` : val))\n    .join(', ');\n  \n  const query = `\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0] as Application;\n  } catch (error) {\n    console.error('Error creating application:', error);\n    throw error;\n  }\n};\n\n// Update an existing application\nexport const updateApplication = async (id: string, updates: Partial<Application>, entityFilter?: Record<string, any> | null) => {\n  const setClause = Object.entries(updates)\n    .map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`)\n    .join(', ');\n  \n  let query = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  query += ' RETURNING *';\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found or you do not have permission to update it');\n  } catch (error) {\n    console.error(`Error updating application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Update application status and add to history\nexport const updateApplicationStatus = async (\n  id: string, \n  status: Application['status'], \n  comment: string, \n  user_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // 1. Obtener estado actual de la aplicación\n  let currentQuery = `\n    SELECT status FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      currentQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      currentQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    // Obtener el estado actual\n    const currentState = await executeQuery(currentQuery);\n    if (!currentState || currentState.length === 0) {\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    const currentStatus = currentState[0].status;\n    \n    // 2. Actualizar el estado de la aplicación\n    let updateQuery = `\n      UPDATE ${TABLES.APPLICATIONS}\n      SET status = '${status}',\n          status_previous = '${currentStatus}'\n    `;\n    \n    // Si el nuevo estado es \"completed\", actualizar la fecha de dispersión\n    if (status === 'completed') {\n      updateQuery += `, dispersal_date = NOW()`;\n    }\n    \n    updateQuery += ` WHERE id = '${id}'`;\n    \n    // Aplicar filtro por entidad si es necesario\n    if (entityFilter) {\n      if (entityFilter.advisor_id) {\n        updateQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n      }\n      if (entityFilter.company_id) {\n        updateQuery += ` AND company_id = '${entityFilter.company_id}'`;\n      }\n    }\n    \n    updateQuery += ' RETURNING *';\n    \n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    // 3. Añadir al historial\n    const historyComment = currentStatus !== status \n      ? `${comment} (Cambio de estado: ${currentStatus} → ${status})`\n      : comment;\n      \n    const historyQuery = `\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', '${status}', '${historyComment}', '${user_id}')\n      RETURNING *\n    `;\n    \n    await executeQuery(historyQuery);\n    \n    console.log(`Estado de aplicación actualizado: ${currentStatus} → ${status}`);\n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`Error updating status of application ${id}:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por asesor\nexport const approveByAdvisor = async (\n  id: string,\n  comment: string,\n  advisor_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un asesor\n  if (!entityFilter?.advisor_id) {\n    throw new Error('Solo los asesores pueden realizar esta acción');\n  }\n  \n  // Actualizar la solicitud\n  let updateQuery = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET approved_by_advisor = true, \n        approval_date_advisor = NOW()\n    WHERE id = '${id}' AND assigned_to = '${advisor_id}'\n    RETURNING *\n  `;\n  \n  try {\n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    // Añadir al historial\n    const historyQuery = `\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', 'approved_by_advisor', '${comment}', '${advisor_id}')\n      RETURNING *\n    `;\n    \n    await executeQuery(historyQuery);\n    \n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0] as Application;\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'approved') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");\n      \n      // Si ambos han aprobado, actualizar el estado a aprobado\n      return await updateApplicationStatus(\n        id, \n        'approved', \n        'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', \n        advisor_id,\n        entityFilter\n      );\n    }\n    \n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por asesor:`, error);\n    throw error;\n  }\n};\n\n// Aprobar solicitud por empresa\nexport const approveByCompany = async (\n  id: string,\n  comment: string,\n  company_admin_id: string,\n  company_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // Verificar que el usuario es realmente un administrador de la empresa correcta\n  if (!entityFilter?.company_id || entityFilter.company_id !== company_id) {\n    throw new Error('Solo los administradores de la empresa pueden realizar esta acción');\n  }\n  \n  // Actualizar la solicitud\n  let updateQuery = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET approved_by_company = true, \n        approval_date_company = NOW()\n    WHERE id = '${id}' AND company_id = '${company_id}'\n    RETURNING *\n  `;\n  \n  try {\n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Solicitud no encontrada o no tienes permisos para aprobarla');\n    }\n    \n    // Añadir al historial\n    const historyQuery = `\n      INSERT INTO ${APPLICATION_HISTORY_TABLE} (application_id, status, comment, created_by)\n      VALUES ('${id}', 'approved_by_company', '${comment}', '${company_admin_id}')\n      RETURNING *\n    `;\n    \n    await executeQuery(historyQuery);\n    \n    // Verificar si ambas aprobaciones están completas, para actualizar el estado principal\n    const app = updatedApp[0] as Application;\n    if (app.approved_by_advisor && app.approved_by_company && app.status !== 'approved') {\n      console.log(\"Ambas aprobaciones completadas, actualizando estado principal a 'approved'\");\n      \n      // Si ambos han aprobado, actualizar el estado a aprobado\n      return await updateApplicationStatus(\n        id, \n        'approved', \n        'Aprobación completa: Asesor y Empresa han aprobado esta solicitud', \n        company_admin_id,\n        entityFilter\n      );\n    }\n    \n    return app;\n  } catch (error) {\n    console.error(`Error aprobando solicitud ${id} por empresa:`, error);\n    throw error;\n  }\n};\n\n// Obtener estado de aprobación de una solicitud\nexport const getApprovalStatus = async (\n  id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  let query = `\n    SELECT \n      approved_by_advisor, \n      approved_by_company, \n      approval_date_advisor, \n      approval_date_company\n    FROM ${TABLES.APPLICATIONS}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return {\n        approvedByAdvisor: data[0].approved_by_advisor || false,\n        approvedByCompany: data[0].approved_by_company || false,\n        approvalDateAdvisor: data[0].approval_date_advisor,\n        approvalDateCompany: data[0].approval_date_company\n      };\n    }\n    throw new Error('Solicitud no encontrada');\n  } catch (error) {\n    console.error(`Error obteniendo estado de aprobación para solicitud ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete an application\nexport const deleteApplication = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    await executeQuery(query);\n    return true;\n  } catch (error) {\n    console.error(`Error deleting application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Get application history\nexport const getApplicationHistory = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view it');\n    }\n  }\n  \n  const query = `\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${APPLICATION_HISTORY_TABLE} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching history for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Add a comment to an application\nexport const addComment = async (applicationId: string, userId: string, text: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para comentar esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to comment on it');\n    }\n  }\n  \n  const query = `\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error(`Error adding comment to application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Get comments for an application\nexport const getComments = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND assigned_to = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view its comments');\n    }\n  }\n  \n  const query = `\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching comments for application ${applicationId}:`, error);\n    throw error;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}