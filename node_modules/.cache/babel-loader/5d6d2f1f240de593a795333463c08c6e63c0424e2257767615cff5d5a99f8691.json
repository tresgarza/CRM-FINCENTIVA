{"ast":null,"code":"import { TABLES } from '../utils/constants/tables';\n// Función para ejecutar consultas SQL a través del servidor MCP\nconst executeQuery = async query => {\n  try {\n    const response = await fetch('http://localhost:3100/query', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        query\n      })\n    });\n    const result = await response.json();\n    if (result.error) {\n      console.error('Error en la consulta SQL:', result.error);\n      throw new Error(result.error);\n    }\n    return result.data;\n  } catch (error) {\n    console.error('Error ejecutando la consulta:', error);\n    throw error;\n  }\n};\n\n// Get all applications with filters\nexport const getApplications = async (filters, entityFilter) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE 1=1`;\n\n  // Aplicar filtro por entidad (asesor o empresa)\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n\n  // Aplicar otros filtros\n  if (filters) {\n    // Filter by status\n    if (filters.status && filters.status !== 'all') {\n      query += ` AND status = '${filters.status}'`;\n    }\n\n    // Filter by advisor\n    if (filters.advisor_id) {\n      query += ` AND advisor_id = '${filters.advisor_id}'`;\n    }\n\n    // Filter by company\n    if (filters.company_id) {\n      query += ` AND company_id = '${filters.company_id}'`;\n    }\n\n    // Filter by date range\n    if (filters.dateFrom) {\n      query += ` AND created_at >= '${filters.dateFrom}'`;\n    }\n    if (filters.dateTo) {\n      query += ` AND created_at <= '${filters.dateTo}'`;\n    }\n\n    // Search by name, email or phone\n    if (filters.searchQuery) {\n      query += ` AND (\n        applicant_name ILIKE '%${filters.searchQuery}%' OR \n        email ILIKE '%${filters.searchQuery}%' OR \n        phone ILIKE '%${filters.searchQuery}%'\n      )`;\n    }\n  }\n\n  // Ordenar por fecha de creación más reciente\n  query += ` ORDER BY created_at DESC`;\n  try {\n    const data = await executeQuery(query);\n    return data;\n  } catch (error) {\n    console.error('Error fetching applications:', error);\n    throw error;\n  }\n};\n\n// Get a single application by ID\nexport const getApplicationById = async (id, entityFilter) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Application not found');\n  } catch (error) {\n    console.error(`Error fetching application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Create a new application\nexport const createApplication = async application => {\n  const fields = Object.keys(application).join(', ');\n  const values = Object.values(application).map(val => typeof val === 'string' ? `'${val}'` : val).join(', ');\n  const query = `\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;\n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error('Error creating application:', error);\n    throw error;\n  }\n};\n\n// Update an existing application\nexport const updateApplication = async (id, updates, entityFilter) => {\n  const setClause = Object.entries(updates).map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`).join(', ');\n  let query = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  query += ' RETURNING *';\n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Application not found or you do not have permission to update it');\n  } catch (error) {\n    console.error(`Error updating application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Update application status and add to history\nexport const updateApplicationStatus = async (id, status, comment, user_id, entityFilter) => {\n  // 1. Actualizar el estado de la aplicación\n  let updateQuery = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET status = '${status}'\n    WHERE id = '${id}'\n  `;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      updateQuery += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      updateQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  updateQuery += ' RETURNING *';\n  try {\n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n\n    // 2. Añadir al historial\n    const historyQuery = `\n      INSERT INTO ${TABLES.APPLICATION_HISTORY} (application_id, status, comment, created_by)\n      VALUES ('${id}', '${status}', '${comment}', '${user_id}')\n      RETURNING *\n    `;\n    await executeQuery(historyQuery);\n    return updatedApp[0];\n  } catch (error) {\n    console.error(`Error updating status of application ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete an application\nexport const deleteApplication = async (id, entityFilter) => {\n  let query = `DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n\n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  try {\n    await executeQuery(query);\n    return true;\n  } catch (error) {\n    console.error(`Error deleting application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Get application history\nexport const getApplicationHistory = async (applicationId, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para ver esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view it');\n    }\n  }\n  const query = `\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.APPLICATION_HISTORY} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;\n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching history for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Add a comment to an application\nexport const addComment = async (applicationId, userId, text, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para comentar esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to comment on it');\n    }\n  }\n  const query = `\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;\n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error(`Error adding comment to application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Get comments for an application\nexport const getComments = async (applicationId, entityFilter) => {\n  // Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    if (entityFilter.advisor_id) {\n      appQuery += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view its comments');\n    }\n  }\n  const query = `\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;\n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching comments for application ${applicationId}:`, error);\n    throw error;\n  }\n};","map":{"version":3,"names":["TABLES","executeQuery","query","response","fetch","method","headers","body","JSON","stringify","result","json","error","console","Error","data","getApplications","filters","entityFilter","APPLICATIONS","advisor_id","company_id","status","dateFrom","dateTo","searchQuery","getApplicationById","id","length","createApplication","application","fields","Object","keys","join","values","map","val","updateApplication","updates","setClause","entries","key","value","updateApplicationStatus","comment","user_id","updateQuery","updatedApp","historyQuery","APPLICATION_HISTORY","deleteApplication","getApplicationHistory","applicationId","appQuery","app","addComment","userId","text","COMMENTS","getComments"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/applicationService.ts"],"sourcesContent":["import { TABLES } from '../utils/constants/tables';\n\nexport interface Application {\n  id: string;\n  created_at: string;\n  applicant_name: string;\n  email: string;\n  phone: string;\n  status: 'pending' | 'review' | 'approved' | 'rejected';\n  amount: number;\n  advisor_id?: string;\n  company_id?: string;\n  client_id?: string;\n  credit_type: 'personal' | 'auto' | 'car_backed' | 'cash_advance';\n  notes?: string;\n}\n\nexport interface ApplicationFilter {\n  status?: string;\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n}\n\n// Función para ejecutar consultas SQL a través del servidor MCP\nconst executeQuery = async (query: string) => {\n  try {\n    const response = await fetch('http://localhost:3100/query', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ query }),\n    });\n    \n    const result = await response.json();\n    \n    if (result.error) {\n      console.error('Error en la consulta SQL:', result.error);\n      throw new Error(result.error);\n    }\n    \n    return result.data;\n  } catch (error) {\n    console.error('Error ejecutando la consulta:', error);\n    throw error;\n  }\n};\n\n// Get all applications with filters\nexport const getApplications = async (filters?: ApplicationFilter, entityFilter?: Record<string, any> | null) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE 1=1`;\n  \n  // Aplicar filtro por entidad (asesor o empresa)\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n\n  // Aplicar otros filtros\n  if (filters) {\n    // Filter by status\n    if (filters.status && filters.status !== 'all') {\n      query += ` AND status = '${filters.status}'`;\n    }\n\n    // Filter by advisor\n    if (filters.advisor_id) {\n      query += ` AND advisor_id = '${filters.advisor_id}'`;\n    }\n\n    // Filter by company\n    if (filters.company_id) {\n      query += ` AND company_id = '${filters.company_id}'`;\n    }\n\n    // Filter by date range\n    if (filters.dateFrom) {\n      query += ` AND created_at >= '${filters.dateFrom}'`;\n    }\n\n    if (filters.dateTo) {\n      query += ` AND created_at <= '${filters.dateTo}'`;\n    }\n\n    // Search by name, email or phone\n    if (filters.searchQuery) {\n      query += ` AND (\n        applicant_name ILIKE '%${filters.searchQuery}%' OR \n        email ILIKE '%${filters.searchQuery}%' OR \n        phone ILIKE '%${filters.searchQuery}%'\n      )`;\n    }\n  }\n\n  // Ordenar por fecha de creación más reciente\n  query += ` ORDER BY created_at DESC`;\n\n  try {\n    const data = await executeQuery(query);\n    return data as Application[];\n  } catch (error) {\n    console.error('Error fetching applications:', error);\n    throw error;\n  }\n};\n\n// Get a single application by ID\nexport const getApplicationById = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `SELECT * FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found');\n  } catch (error) {\n    console.error(`Error fetching application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Create a new application\nexport const createApplication = async (application: Omit<Application, 'id' | 'created_at'>) => {\n  const fields = Object.keys(application).join(', ');\n  const values = Object.values(application)\n    .map(val => (typeof val === 'string' ? `'${val}'` : val))\n    .join(', ');\n  \n  const query = `\n    INSERT INTO ${TABLES.APPLICATIONS} (${fields})\n    VALUES (${values})\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0] as Application;\n  } catch (error) {\n    console.error('Error creating application:', error);\n    throw error;\n  }\n};\n\n// Update an existing application\nexport const updateApplication = async (id: string, updates: Partial<Application>, entityFilter?: Record<string, any> | null) => {\n  const setClause = Object.entries(updates)\n    .map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`)\n    .join(', ');\n  \n  let query = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET ${setClause}\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  query += ' RETURNING *';\n  \n  try {\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0] as Application;\n    }\n    throw new Error('Application not found or you do not have permission to update it');\n  } catch (error) {\n    console.error(`Error updating application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Update application status and add to history\nexport const updateApplicationStatus = async (\n  id: string, \n  status: Application['status'], \n  comment: string, \n  user_id: string,\n  entityFilter?: Record<string, any> | null\n) => {\n  // 1. Actualizar el estado de la aplicación\n  let updateQuery = `\n    UPDATE ${TABLES.APPLICATIONS}\n    SET status = '${status}'\n    WHERE id = '${id}'\n  `;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      updateQuery += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      updateQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  updateQuery += ' RETURNING *';\n  \n  try {\n    // Ejecutar la actualización\n    const updatedApp = await executeQuery(updateQuery);\n    if (!updatedApp || updatedApp.length === 0) {\n      throw new Error('Application not found or you do not have permission to update it');\n    }\n    \n    // 2. Añadir al historial\n    const historyQuery = `\n      INSERT INTO ${TABLES.APPLICATION_HISTORY} (application_id, status, comment, created_by)\n      VALUES ('${id}', '${status}', '${comment}', '${user_id}')\n      RETURNING *\n    `;\n    \n    await executeQuery(historyQuery);\n    \n    return updatedApp[0] as Application;\n  } catch (error) {\n    console.error(`Error updating status of application ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete an application\nexport const deleteApplication = async (id: string, entityFilter?: Record<string, any> | null) => {\n  let query = `DELETE FROM ${TABLES.APPLICATIONS} WHERE id = '${id}'`;\n  \n  // Aplicar filtro por entidad si es necesario\n  if (entityFilter) {\n    if (entityFilter.advisor_id) {\n      query += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      query += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n  }\n  \n  try {\n    await executeQuery(query);\n    return true;\n  } catch (error) {\n    console.error(`Error deleting application with ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Get application history\nexport const getApplicationHistory = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view it');\n    }\n  }\n  \n  const query = `\n    SELECT h.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.APPLICATION_HISTORY} h\n    LEFT JOIN users u ON h.created_by = u.id\n    WHERE h.application_id = '${applicationId}'\n    ORDER BY h.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching history for application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Add a comment to an application\nexport const addComment = async (applicationId: string, userId: string, text: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para comentar esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to comment on it');\n    }\n  }\n  \n  const query = `\n    INSERT INTO ${TABLES.COMMENTS} (application_id, user_id, text)\n    VALUES ('${applicationId}', '${userId}', '${text}')\n    RETURNING *\n  `;\n  \n  try {\n    const data = await executeQuery(query);\n    return data[0];\n  } catch (error) {\n    console.error(`Error adding comment to application ${applicationId}:`, error);\n    throw error;\n  }\n};\n\n// Get comments for an application\nexport const getComments = async (applicationId: string, entityFilter?: Record<string, any> | null) => {\n  // Verificar primero si el usuario tiene permiso para ver los comentarios de esta aplicación\n  if (entityFilter) {\n    let appQuery = `\n      SELECT id FROM ${TABLES.APPLICATIONS} \n      WHERE id = '${applicationId}'\n    `;\n    \n    if (entityFilter.advisor_id) {\n      appQuery += ` AND advisor_id = '${entityFilter.advisor_id}'`;\n    }\n    if (entityFilter.company_id) {\n      appQuery += ` AND company_id = '${entityFilter.company_id}'`;\n    }\n    \n    const app = await executeQuery(appQuery);\n    if (!app || app.length === 0) {\n      throw new Error('Application not found or you do not have permission to view its comments');\n    }\n  }\n  \n  const query = `\n    SELECT c.*, u.id as user_id, u.name as user_name, u.email as user_email\n    FROM ${TABLES.COMMENTS} c\n    LEFT JOIN users u ON c.user_id = u.id\n    WHERE c.application_id = '${applicationId}'\n    ORDER BY c.created_at DESC\n  `;\n  \n  try {\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error fetching comments for application ${applicationId}:`, error);\n    throw error;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}