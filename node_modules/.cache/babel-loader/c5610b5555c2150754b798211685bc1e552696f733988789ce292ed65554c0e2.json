{"ast":null,"code":"import { executeQuery } from '../utils/databaseUtils';\nimport { TABLES } from '../utils/constants/tables';\n// Nombre de la tabla definido como constante para evitar errores de escritura\nconst CLIENTS_TABLE = TABLES.CLIENTS || 'clients';\n\n// Get all clients with filters\nexport const getClients = async filters => {\n  try {\n    // Construir la consulta base\n    let query = `SELECT * FROM ${CLIENTS_TABLE} WHERE 1=1`;\n\n    // Aplicar filtros si existen\n    if (filters) {\n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        query += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n\n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n\n      // Filtro por empresa\n      if (filters.company_id) {\n        query += ` AND company_id = '${filters.company_id}'`;\n      }\n\n      // Filtro por fecha\n      if (filters.dateFrom) {\n        query += ` AND created_at >= '${filters.dateFrom}'`;\n      }\n      if (filters.dateTo) {\n        query += ` AND created_at <= '${filters.dateTo}'`;\n      }\n    }\n\n    // Agregar ordenamiento\n    query += ` ORDER BY created_at DESC`;\n\n    // Agregar paginación si se especifica\n    if ((filters === null || filters === void 0 ? void 0 : filters.page) !== undefined && filters !== null && filters !== void 0 && filters.pageSize) {\n      const offset = (filters.page - 1) * filters.pageSize;\n      query += ` LIMIT ${filters.pageSize} OFFSET ${offset}`;\n    }\n\n    // Ejecutar la consulta\n    const data = await executeQuery(query);\n    return data || [];\n  } catch (error) {\n    console.error('Error al obtener clientes:', error);\n    // Si la tabla no existe o hay otro error, devolver un array vacío\n    return [];\n  }\n};\n\n// Get a single client by ID\nexport const getClientById = async id => {\n  try {\n    const query = `SELECT * FROM ${CLIENTS_TABLE} WHERE id = '${id}'`;\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al obtener cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Escapa caracteres especiales en cadenas SQL\n */\nfunction escapeSQLString(str) {\n  return str.replace(/'/g, \"''\");\n}\n\n// Get applications for a specific client\nexport const getClientApplications = async clientId => {\n  try {\n    const query = `\n      SELECT * FROM ${TABLES.APPLICATIONS} \n      WHERE client_id = '${clientId}' OR source_id = '${clientId}'\n      ORDER BY created_at DESC\n    `;\n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error al obtener aplicaciones del cliente ${clientId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new client\nexport const createClient = async client => {\n  try {\n    // Construir lista de campos y valores\n    const fields = Object.keys(client).join(', ');\n    const values = Object.values(client).map(value => typeof value === 'string' ? `'${escapeSQLString(value)}'` : value).join(', ');\n    const query = `\n      INSERT INTO ${CLIENTS_TABLE} (${fields})\n      VALUES (${values})\n      RETURNING *\n    `;\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Error al crear el cliente');\n  } catch (error) {\n    console.error('Error al crear cliente:', error);\n    throw error;\n  }\n};\n\n// Update an existing client\nexport const updateClient = async (id, updates) => {\n  try {\n    // Construir lista de cambios\n    const setClause = Object.entries(updates).map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${escapeSQLString(value)}'` : value}`).join(', ');\n    const query = `\n      UPDATE ${CLIENTS_TABLE}\n      SET ${setClause}\n      WHERE id = '${id}'\n      RETURNING *\n    `;\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return data[0];\n    }\n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al actualizar cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete a client\nexport const deleteClient = async id => {\n  try {\n    const query = `\n      DELETE FROM ${CLIENTS_TABLE}\n      WHERE id = '${id}'\n      RETURNING id\n    `;\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return true;\n    }\n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al eliminar cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Check if a client with the given email or RFC already exists\nexport const checkClientExists = async (email, rfc) => {\n  try {\n    let query = `\n      SELECT id, email, rfc FROM ${CLIENTS_TABLE}\n      WHERE email = '${escapeSQLString(email)}'\n    `;\n    if (rfc) {\n      query += ` OR rfc = '${escapeSQLString(rfc)}'`;\n    }\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return {\n        exists: true,\n        client: data[0]\n      };\n    }\n    return {\n      exists: false\n    };\n  } catch (error) {\n    console.error('Error al verificar existencia de cliente:', error);\n    throw error;\n  }\n};\n\n// Get total count of clients with filters\nexport const getClientCount = async filters => {\n  try {\n    let query = `SELECT COUNT(*) as count FROM ${CLIENTS_TABLE} WHERE 1=1`;\n\n    // Aplicar filtros si existen\n    if (filters) {\n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        query += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n\n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n\n      // Filtro por empresa\n      if (filters.company_id) {\n        query += ` AND company_id = '${filters.company_id}'`;\n      }\n    }\n    const data = await executeQuery(query);\n    if (data && data.length > 0) {\n      return parseInt(data[0].count) || 0;\n    }\n    return 0;\n  } catch (error) {\n    console.error('Error al obtener conteo de clientes:', error);\n    return 0;\n  }\n};","map":{"version":3,"names":["executeQuery","TABLES","CLIENTS_TABLE","CLIENTS","getClients","filters","query","searchQuery","advisor_id","company_id","dateFrom","dateTo","page","undefined","pageSize","offset","data","error","console","getClientById","id","length","Error","escapeSQLString","str","replace","getClientApplications","clientId","APPLICATIONS","createClient","client","fields","Object","keys","join","values","map","value","updateClient","updates","setClause","entries","key","deleteClient","checkClientExists","email","rfc","exists","getClientCount","parseInt","count"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/clientService.ts"],"sourcesContent":["import { executeQuery } from '../utils/databaseUtils';\nimport { TABLES } from '../utils/constants/tables';\n\nexport interface Client {\n  id: string;\n  created_at: string;\n  name: string;\n  email: string;\n  phone: string;\n  address?: string;\n  city?: string;\n  state?: string;\n  postal_code?: string;\n  birth_date?: string;\n  rfc?: string;\n  curp?: string;\n  company_id?: string;\n  advisor_id?: string;\n}\n\nexport interface ClientFilter {\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n  page?: number;\n  pageSize?: number;\n}\n\n// Nombre de la tabla definido como constante para evitar errores de escritura\nconst CLIENTS_TABLE = TABLES.CLIENTS || 'clients';\n\n// Get all clients with filters\nexport const getClients = async (filters?: ClientFilter) => {\n  try {\n    // Construir la consulta base\n    let query = `SELECT * FROM ${CLIENTS_TABLE} WHERE 1=1`;\n\n    // Aplicar filtros si existen\n    if (filters) {\n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        query += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n\n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n\n      // Filtro por empresa\n      if (filters.company_id) {\n        query += ` AND company_id = '${filters.company_id}'`;\n      }\n\n      // Filtro por fecha\n      if (filters.dateFrom) {\n        query += ` AND created_at >= '${filters.dateFrom}'`;\n      }\n      if (filters.dateTo) {\n        query += ` AND created_at <= '${filters.dateTo}'`;\n      }\n    }\n\n    // Agregar ordenamiento\n    query += ` ORDER BY created_at DESC`;\n\n    // Agregar paginación si se especifica\n    if (filters?.page !== undefined && filters?.pageSize) {\n      const offset = (filters.page - 1) * filters.pageSize;\n      query += ` LIMIT ${filters.pageSize} OFFSET ${offset}`;\n    }\n\n    // Ejecutar la consulta\n    const data = await executeQuery(query);\n    return data || [];\n  } catch (error) {\n    console.error('Error al obtener clientes:', error);\n    // Si la tabla no existe o hay otro error, devolver un array vacío\n    return [];\n  }\n};\n\n// Get a single client by ID\nexport const getClientById = async (id: string) => {\n  try {\n    const query = `SELECT * FROM ${CLIENTS_TABLE} WHERE id = '${id}'`;\n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return data[0] as Client;\n    }\n    \n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al obtener cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Escapa caracteres especiales en cadenas SQL\n */\nfunction escapeSQLString(str: string) {\n  return str.replace(/'/g, \"''\");\n}\n\n// Get applications for a specific client\nexport const getClientApplications = async (clientId: string) => {\n  try {\n    const query = `\n      SELECT * FROM ${TABLES.APPLICATIONS} \n      WHERE client_id = '${clientId}' OR source_id = '${clientId}'\n      ORDER BY created_at DESC\n    `;\n    \n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error al obtener aplicaciones del cliente ${clientId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new client\nexport const createClient = async (client: Omit<Client, 'id' | 'created_at'>) => {\n  try {\n    // Construir lista de campos y valores\n    const fields = Object.keys(client).join(', ');\n    const values = Object.values(client)\n      .map(value => typeof value === 'string' ? `'${escapeSQLString(value)}'` : value)\n      .join(', ');\n    \n    const query = `\n      INSERT INTO ${CLIENTS_TABLE} (${fields})\n      VALUES (${values})\n      RETURNING *\n    `;\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return data[0] as Client;\n    }\n    \n    throw new Error('Error al crear el cliente');\n  } catch (error) {\n    console.error('Error al crear cliente:', error);\n    throw error;\n  }\n};\n\n// Update an existing client\nexport const updateClient = async (id: string, updates: Partial<Client>) => {\n  try {\n    // Construir lista de cambios\n    const setClause = Object.entries(updates)\n      .map(([key, value]) => \n        `${key} = ${typeof value === 'string' ? `'${escapeSQLString(value)}'` : value}`\n      )\n      .join(', ');\n    \n    const query = `\n      UPDATE ${CLIENTS_TABLE}\n      SET ${setClause}\n      WHERE id = '${id}'\n      RETURNING *\n    `;\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return data[0] as Client;\n    }\n    \n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al actualizar cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete a client\nexport const deleteClient = async (id: string) => {\n  try {\n    const query = `\n      DELETE FROM ${CLIENTS_TABLE}\n      WHERE id = '${id}'\n      RETURNING id\n    `;\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return true;\n    }\n    \n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al eliminar cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Check if a client with the given email or RFC already exists\nexport const checkClientExists = async (email: string, rfc?: string) => {\n  try {\n    let query = `\n      SELECT id, email, rfc FROM ${CLIENTS_TABLE}\n      WHERE email = '${escapeSQLString(email)}'\n    `;\n    \n    if (rfc) {\n      query += ` OR rfc = '${escapeSQLString(rfc)}'`;\n    }\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return {\n        exists: true,\n        client: data[0]\n      };\n    }\n    \n    return { exists: false };\n  } catch (error) {\n    console.error('Error al verificar existencia de cliente:', error);\n    throw error;\n  }\n};\n\n// Get total count of clients with filters\nexport const getClientCount = async (filters?: ClientFilter) => {\n  try {\n    let query = `SELECT COUNT(*) as count FROM ${CLIENTS_TABLE} WHERE 1=1`;\n    \n    // Aplicar filtros si existen\n    if (filters) {\n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        query += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n      \n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n      \n      // Filtro por empresa\n      if (filters.company_id) {\n        query += ` AND company_id = '${filters.company_id}'`;\n      }\n    }\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return parseInt(data[0].count) || 0;\n    }\n    \n    return 0;\n  } catch (error) {\n    console.error('Error al obtener conteo de clientes:', error);\n    return 0;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}