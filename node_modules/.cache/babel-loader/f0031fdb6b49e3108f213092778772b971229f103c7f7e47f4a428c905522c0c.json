{"ast":null,"code":"import { supabase, getServiceClient } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { checkTableExists } from '../utils/dbStructureCheck';\nimport { ErrorType, createAppError, logError } from '../utils/errorHandling';\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async client => {\n  const supabaseClient = client || supabase;\n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const {\n      error\n    } = await supabaseClient.storage.from(STORAGE_BUCKET).list();\n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || errorMessage.includes('does not exist') || errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async applicationId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('application_id', applicationId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async clientId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('client_id', clientId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async id => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('id', id).single();\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Upload a document\nexport const uploadDocument = async ({\n  applicationId,\n  clientId,\n  file,\n  category,\n  userId\n}) => {\n  const supabase = getServiceClient();\n  try {\n    var _uploadError;\n    // Verificar si la tabla existe antes de intentar operaciones\n    const tableExists = await checkTableExists(DOCUMENTS_TABLE);\n    if (!tableExists) {\n      logError({\n        message: `La tabla ${DOCUMENTS_TABLE} no existe. Por favor, ejecute el script de creación de tablas.`,\n        type: ErrorType.DATABASE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: `Error de configuración: La tabla de documentos no está correctamente configurada.`,\n        type: ErrorType.DATABASE_ERROR\n      });\n    }\n\n    // Verificar si el bucket de storage existe\n    const {\n      data: buckets\n    } = await supabase.storage.listBuckets();\n    const bucketExists = buckets === null || buckets === void 0 ? void 0 : buckets.some(bucket => bucket.name === STORAGE_BUCKET);\n    if (!bucketExists) {\n      logError({\n        message: `El bucket ${STORAGE_BUCKET} no existe.`,\n        type: ErrorType.STORAGE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: `Error de configuración: El almacenamiento de documentos no está correctamente configurado.`,\n        type: ErrorType.STORAGE_ERROR\n      });\n    }\n\n    // Generar información del archivo\n    const fileName = file.name;\n    const fileType = file.type;\n    const fileSize = file.size;\n\n    // Crear registro del documento\n    const {\n      data,\n      error\n    } = await supabase.from(DOCUMENTS_TABLE).insert({\n      file_name: fileName,\n      file_type: fileType,\n      file_size: fileSize,\n      category,\n      application_id: applicationId,\n      client_id: clientId,\n      uploaded_by_user_id: userId,\n      is_verified: false\n    }).select('*').single();\n    if (error) {\n      // Verificar si es un error de RLS\n      if (error.message && error.message.includes('policy')) {\n        logError({\n          message: `Violación de política RLS al crear documento: ${error.message}`,\n          type: ErrorType.PERMISSION_ERROR,\n          module: 'documentService',\n          function: 'uploadDocument'\n        });\n        throw createAppError({\n          message: 'No tienes permisos para crear documentos para este cliente o aplicación',\n          type: ErrorType.PERMISSION_ERROR\n        });\n      }\n      logError({\n        message: `Error al crear documento: ${error.message}`,\n        type: ErrorType.DATABASE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: 'Error al crear documento en la base de datos',\n        type: ErrorType.DATABASE_ERROR\n      });\n    }\n    if (!data) {\n      logError({\n        message: 'No se retornaron datos al crear documento',\n        type: ErrorType.DATABASE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: 'Error al crear documento en la base de datos',\n        type: ErrorType.DATABASE_ERROR\n      });\n    }\n    const documentId = data.id;\n\n    // Construir nombre único para el archivo\n    const fileExtension = fileName.split('.').pop();\n    const uniqueFileName = `${documentId}.${fileExtension}`;\n    const filePath = `${clientId || applicationId}/${uniqueFileName}`;\n\n    // Intentar subir el archivo con reintentos\n    let uploadError = null;\n    const maxRetries = 3;\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        // Subir el archivo al storage\n        const {\n          error: uploadError\n        } = await supabase.storage.from(STORAGE_BUCKET).upload(filePath, file, {\n          upsert: true,\n          cacheControl: '3600'\n        });\n        if (uploadError) {\n          throw uploadError;\n        }\n\n        // Obtener URL pública del archivo\n        const {\n          data: publicUrlData\n        } = supabase.storage.from(STORAGE_BUCKET).getPublicUrl(filePath);\n\n        // Actualizar el documento con la ruta del archivo\n        const {\n          error: updateError\n        } = await supabase.from(DOCUMENTS_TABLE).update({\n          file_path: filePath\n        }).eq('id', documentId);\n        if (updateError) {\n          logError({\n            message: `Error al actualizar ruta del documento: ${updateError.message}`,\n            type: ErrorType.DATABASE_ERROR,\n            module: 'documentService',\n            function: 'uploadDocument'\n          });\n        }\n\n        // Construir y devolver el documento\n        return {\n          id: documentId,\n          applicationId: applicationId || null,\n          clientId: clientId || null,\n          fileName,\n          filePath,\n          fileType,\n          fileSize,\n          category,\n          uploadedByUserId: userId,\n          isVerified: false,\n          createdAt: data.created_at,\n          publicUrl: publicUrlData.publicUrl\n        };\n      } catch (error) {\n        uploadError = error;\n\n        // Esperar con backoff exponencial antes de reintentar\n        if (attempt < maxRetries - 1) {\n          const waitTime = Math.pow(2, attempt) * 1000;\n          console.log(`Reintentando subir documento en ${waitTime}ms...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n\n    // Si llegamos aquí, todos los intentos fallaron\n    logError({\n      message: `Error al subir documento después de ${maxRetries} intentos: ${((_uploadError = uploadError) === null || _uploadError === void 0 ? void 0 : _uploadError.message) || 'Error desconocido'}`,\n      type: ErrorType.STORAGE_ERROR,\n      module: 'documentService',\n      function: 'uploadDocument'\n    });\n\n    // Intentar eliminar el documento creado\n    try {\n      await supabase.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    } catch (deleteError) {\n      console.warn(`No se pudo eliminar el documento huérfano: ${deleteError}`);\n    }\n    throw createAppError({\n      message: 'Error al subir el archivo al sistema',\n      type: ErrorType.STORAGE_ERROR\n    });\n  } catch (error) {\n    // Si el error ya es un AppError, rethrow\n    if (error && error.isAppError) {\n      throw error;\n    }\n    logError({\n      message: `Error inesperado en uploadDocument: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`,\n      type: ErrorType.UNEXPECTED_ERROR,\n      module: 'documentService',\n      function: 'uploadDocument',\n      error\n    });\n    throw createAppError({\n      message: 'Error inesperado al subir documento',\n      type: ErrorType.UNEXPECTED_ERROR\n    });\n  }\n};\n\n// Delete a document\nexport const deleteDocument = async documentId => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n\n    // Get document to get file path\n    const {\n      data: document,\n      error: fetchError\n    } = await supabase.from(DOCUMENTS_TABLE).select('file_path').eq('id', documentId).single();\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const {\n      error: storageError\n    } = await supabase.storage.from(STORAGE_BUCKET).remove([document.file_path]);\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error ? storageError.message : typeof storageError === 'object' && storageError !== null && 'message' in storageError ? String(storageError.message) : 'Error desconocido';\n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const {\n      error: deleteError\n    } = await supabase.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async filePath => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    const {\n      data,\n      error\n    } = await supabase.storage.from(STORAGE_BUCKET).createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId, userId, isVerified = true) => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).update({\n    is_verified: isVerified,\n    verified_by: userId,\n    verified_at: new Date().toISOString()\n  }).eq('id', documentId).select();\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n  return data[0];\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async applicationType => {\n  const {\n    data,\n    error\n  } = await supabase.from('required_documents').select('*').eq('application_type', applicationType);\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n  return data;\n};","map":{"version":3,"names":["supabase","getServiceClient","TABLES","checkTableExists","ErrorType","createAppError","logError","DOCUMENTS_TABLE","DOCUMENTS","STORAGE_BUCKET","ensureStorageBucketExists","client","supabaseClient","error","storage","from","list","errorMessage","message","includes","console","log","Error","getApplicationDocuments","applicationId","data","select","eq","order","ascending","getClientDocuments","clientId","getDocumentById","id","single","uploadDocument","file","category","userId","_uploadError","tableExists","type","DATABASE_ERROR","module","function","buckets","listBuckets","bucketExists","some","bucket","name","STORAGE_ERROR","fileName","fileType","fileSize","size","insert","file_name","file_type","file_size","application_id","client_id","uploaded_by_user_id","is_verified","PERMISSION_ERROR","documentId","fileExtension","split","pop","uniqueFileName","filePath","uploadError","maxRetries","attempt","upload","upsert","cacheControl","publicUrlData","getPublicUrl","updateError","update","file_path","uploadedByUserId","isVerified","createdAt","created_at","publicUrl","waitTime","Math","pow","Promise","resolve","setTimeout","delete","deleteError","warn","isAppError","UNEXPECTED_ERROR","deleteDocument","document","fetchError","storageError","remove","String","getDocumentUrl","createSignedUrl","signedUrl","verifyDocument","verified_by","verified_at","Date","toISOString","getRequiredDocuments","applicationType"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/documentService.ts"],"sourcesContent":["import { supabase, getServiceClient } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { checkTableExists } from '../utils/dbStructureCheck';\nimport { \n  ErrorType, \n  createAppError, \n  logError \n} from '../utils/errorHandling';\n\nexport interface Document {\n  id: string;\n  created_at: string;\n  file_name: string;\n  file_path: string;\n  file_type: string;\n  file_size: number;\n  category?: string;\n  application_id?: string;\n  client_id?: string;\n  uploaded_by_user_id?: string;\n  is_verified?: boolean;\n  verified_by?: string;\n  verified_at?: string;\n}\n\nexport interface DocumentUpload {\n  file: File;\n  application_id?: string;\n  client_id?: string;\n  userId: string;\n  documentName: string;\n  description?: string;\n  category?: string;\n  authClient?: SupabaseClient;\n}\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\nexport type UploadDocumentParams = DocumentUpload;\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async (client?: SupabaseClient) => {\n  const supabaseClient = client || supabase;\n  \n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const { error } = await supabaseClient.storage\n      .from(STORAGE_BUCKET)\n      .list();\n    \n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || \n          errorMessage.includes('does not exist') || \n          errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    \n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async (applicationId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('application_id', applicationId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async (clientId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('client_id', clientId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async (id: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n\n  return data as Document;\n};\n\n// Upload a document\nexport const uploadDocument = async ({\n  applicationId,\n  clientId,\n  file,\n  category,\n  userId\n}: DocumentUpload): Promise<Document> => {\n  const supabase = getServiceClient();\n  \n  try {\n    // Verificar si la tabla existe antes de intentar operaciones\n    const tableExists = await checkTableExists(DOCUMENTS_TABLE);\n    if (!tableExists) {\n      logError({\n        message: `La tabla ${DOCUMENTS_TABLE} no existe. Por favor, ejecute el script de creación de tablas.`,\n        type: ErrorType.DATABASE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: `Error de configuración: La tabla de documentos no está correctamente configurada.`,\n        type: ErrorType.DATABASE_ERROR\n      });\n    }\n    \n    // Verificar si el bucket de storage existe\n    const { data: buckets } = await supabase.storage.listBuckets();\n    const bucketExists = buckets?.some(bucket => bucket.name === STORAGE_BUCKET);\n    \n    if (!bucketExists) {\n      logError({\n        message: `El bucket ${STORAGE_BUCKET} no existe.`,\n        type: ErrorType.STORAGE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: `Error de configuración: El almacenamiento de documentos no está correctamente configurado.`,\n        type: ErrorType.STORAGE_ERROR\n      });\n    }\n    \n    // Generar información del archivo\n    const fileName = file.name;\n    const fileType = file.type;\n    const fileSize = file.size;\n    \n    // Crear registro del documento\n    const { data, error } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .insert({\n        file_name: fileName,\n        file_type: fileType,\n        file_size: fileSize,\n        category,\n        application_id: applicationId,\n        client_id: clientId,\n        uploaded_by_user_id: userId,\n        is_verified: false\n      })\n      .select('*')\n      .single();\n      \n    if (error) {\n      // Verificar si es un error de RLS\n      if (error.message && error.message.includes('policy')) {\n        logError({\n          message: `Violación de política RLS al crear documento: ${error.message}`,\n          type: ErrorType.PERMISSION_ERROR,\n          module: 'documentService',\n          function: 'uploadDocument'\n        });\n        throw createAppError({\n          message: 'No tienes permisos para crear documentos para este cliente o aplicación',\n          type: ErrorType.PERMISSION_ERROR\n        });\n      }\n      \n      logError({\n        message: `Error al crear documento: ${error.message}`,\n        type: ErrorType.DATABASE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: 'Error al crear documento en la base de datos',\n        type: ErrorType.DATABASE_ERROR\n      });\n    }\n    \n    if (!data) {\n      logError({\n        message: 'No se retornaron datos al crear documento',\n        type: ErrorType.DATABASE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: 'Error al crear documento en la base de datos',\n        type: ErrorType.DATABASE_ERROR\n      });\n    }\n    \n    const documentId = data.id;\n    \n    // Construir nombre único para el archivo\n    const fileExtension = fileName.split('.').pop();\n    const uniqueFileName = `${documentId}.${fileExtension}`;\n    const filePath = `${clientId || applicationId}/${uniqueFileName}`;\n    \n    // Intentar subir el archivo con reintentos\n    let uploadError: any = null;\n    const maxRetries = 3;\n    \n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        // Subir el archivo al storage\n        const { error: uploadError } = await supabase.storage\n          .from(STORAGE_BUCKET)\n          .upload(filePath, file, {\n            upsert: true,\n            cacheControl: '3600'\n          });\n          \n        if (uploadError) {\n          throw uploadError;\n        }\n        \n        // Obtener URL pública del archivo\n        const { data: publicUrlData } = supabase.storage\n          .from(STORAGE_BUCKET)\n          .getPublicUrl(filePath);\n          \n        // Actualizar el documento con la ruta del archivo\n        const { error: updateError } = await supabase\n          .from(DOCUMENTS_TABLE)\n          .update({\n            file_path: filePath\n          })\n          .eq('id', documentId);\n          \n        if (updateError) {\n          logError({\n            message: `Error al actualizar ruta del documento: ${updateError.message}`,\n            type: ErrorType.DATABASE_ERROR,\n            module: 'documentService',\n            function: 'uploadDocument'\n          });\n        }\n        \n        // Construir y devolver el documento\n        return {\n          id: documentId,\n          applicationId: applicationId || null,\n          clientId: clientId || null,\n          fileName,\n          filePath,\n          fileType,\n          fileSize,\n          category,\n          uploadedByUserId: userId,\n          isVerified: false,\n          createdAt: data.created_at,\n          publicUrl: publicUrlData.publicUrl\n        };\n      } catch (error) {\n        uploadError = error;\n        \n        // Esperar con backoff exponencial antes de reintentar\n        if (attempt < maxRetries - 1) {\n          const waitTime = Math.pow(2, attempt) * 1000;\n          console.log(`Reintentando subir documento en ${waitTime}ms...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n    \n    // Si llegamos aquí, todos los intentos fallaron\n    logError({\n      message: `Error al subir documento después de ${maxRetries} intentos: ${uploadError?.message || 'Error desconocido'}`,\n      type: ErrorType.STORAGE_ERROR,\n      module: 'documentService',\n      function: 'uploadDocument'\n    });\n    \n    // Intentar eliminar el documento creado\n    try {\n      await supabase\n        .from(DOCUMENTS_TABLE)\n        .delete()\n        .eq('id', documentId);\n    } catch (deleteError) {\n      console.warn(`No se pudo eliminar el documento huérfano: ${deleteError}`);\n    }\n    \n    throw createAppError({\n      message: 'Error al subir el archivo al sistema',\n      type: ErrorType.STORAGE_ERROR\n    });\n  } catch (error) {\n    // Si el error ya es un AppError, rethrow\n    if (error && (error as any).isAppError) {\n      throw error;\n    }\n    \n    logError({\n      message: `Error inesperado en uploadDocument: ${(error as any)?.message || 'Error desconocido'}`,\n      type: ErrorType.UNEXPECTED_ERROR,\n      module: 'documentService',\n      function: 'uploadDocument',\n      error\n    });\n    \n    throw createAppError({\n      message: 'Error inesperado al subir documento',\n      type: ErrorType.UNEXPECTED_ERROR\n    });\n  }\n};\n\n// Delete a document\nexport const deleteDocument = async (documentId: string) => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n    \n    // Get document to get file path\n    const { data: document, error: fetchError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .select('file_path')\n      .eq('id', documentId)\n      .single();\n\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const { error: storageError } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .remove([document.file_path]);\n\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error \n        ? storageError.message \n        : (typeof storageError === 'object' && storageError !== null && 'message' in storageError)\n          ? String((storageError as {message: string}).message)\n          : 'Error desconocido';\n      \n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const { error: deleteError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .delete()\n      .eq('id', documentId);\n\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async (filePath: string) => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    \n    const { data, error } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId: string, userId: string, isVerified: boolean = true) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .update({\n      is_verified: isVerified,\n      verified_by: userId,\n      verified_at: new Date().toISOString()\n    })\n    .eq('id', documentId)\n    .select();\n\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n\n  return data[0] as Document;\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async (applicationType: string) => {\n  const { data, error } = await supabase\n    .from('required_documents')\n    .select('*')\n    .eq('application_type', applicationType);\n\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n\n  return data;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}