{"ast":null,"code":"import { supabase } from '../lib/supabaseClient';\nimport { ErrorType, createAppError, logError, safeAsync } from './errorHandling';\nimport { v4 as uuidv4 } from 'uuid';\nimport { getStorage } from '../lib/supabaseClient';\n/**\n * Maximum number of upload retry attempts\n */\nexport const MAX_UPLOAD_RETRIES = 3;\n\n/**\n * Validates if a file is a valid document for upload\n */\nexport const isValidDocument = file => {\n  // Allowed MIME types\n  const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/jpg', 'image/heic', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/msword', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.ms-excel'];\n\n  // Maximum file size (10MB)\n  const maxSize = 10 * 1024 * 1024;\n  return allowedTypes.includes(file.type) && file.size <= maxSize;\n};\n\n/**\n * Uploads a document to storage with automatic retries\n */\nexport const uploadDocumentToStorage = async (document, folder, attempt = 1) => {\n  const file = document.file;\n  if (!isValidDocument(file)) {\n    throw createAppError(ErrorType.VALIDATION, 'Invalid document format or size', {\n      fileName: file.name,\n      fileType: file.type,\n      fileSize: file.size\n    });\n  }\n  try {\n    // Generate unique file id and name\n    const fileId = uuidv4();\n    const fileExtension = file.name.split('.').pop();\n    const fileName = `${fileId}.${fileExtension}`;\n    const filePath = `${folder}/${fileName}`;\n\n    // Upload the file\n    const {\n      error: uploadError\n    } = await supabase.storage.from('documents').upload(filePath, file);\n    if (uploadError) {\n      throw createAppError(ErrorType.UPLOAD, `Error uploading document: ${uploadError.message}`, {\n        filePath,\n        attempt\n      }, uploadError);\n    }\n\n    // Get public URL for the uploaded file\n    const {\n      data: publicUrlData\n    } = supabase.storage.from('documents').getPublicUrl(filePath);\n\n    // Return document info\n    return {\n      id: fileId,\n      name: file.name,\n      size: file.size,\n      type: document.type,\n      url: publicUrlData.publicUrl,\n      description: document.description,\n      createdAt: new Date().toISOString()\n    };\n  } catch (error) {\n    // Retry logic for transient errors\n    if (attempt < MAX_UPLOAD_RETRIES) {\n      logError(error, 'documentUpload', {\n        message: `Retrying upload (${attempt + 1}/${MAX_UPLOAD_RETRIES})`,\n        fileName: file.name\n      });\n\n      // Exponential backoff delay\n      const delay = Math.pow(2, attempt) * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n\n      // Retry with incremented attempt count\n      return uploadDocumentToStorage(document, folder, attempt + 1);\n    }\n\n    // Max retries reached, rethrow error\n    throw error;\n  }\n};\n\n/**\n * Uploads multiple documents with reliable error handling\n */\nexport const uploadDocuments = async (documents, folder) => {\n  const uploadedDocs = [];\n  const failedDocs = [];\n\n  // Process each document\n  for (const document of documents) {\n    const [uploaded, error] = await safeAsync(uploadDocumentToStorage(document, folder), 'uploadDocuments');\n    if (uploaded) {\n      uploadedDocs.push(uploaded);\n    } else if (error) {\n      failedDocs.push({\n        document,\n        error\n      });\n    }\n  }\n  return {\n    uploadedDocs,\n    failedDocs\n  };\n};\n\n/**\n * Asegura que el bucket de almacenamiento exista antes de utilizarlo\n * @param bucketName Nombre del bucket a verificar\n * @returns True si el bucket existe o fue creado correctamente\n */\nexport const ensureClientBucketExists = async (bucketName = 'client-documents') => {\n  try {\n    console.log(`Verificando si el bucket ${bucketName} existe...`);\n    const storage = getStorage();\n\n    // Intentar listar buckets para verificar si existe\n    const {\n      data: buckets,\n      error: listError\n    } = await storage.listBuckets();\n    if (listError) {\n      console.error(`Error al listar buckets:`, listError);\n      // Si hay un error al listar buckets, podría ser un problema de permisos\n      // Intentaremos verificar directamente intentando listar archivos del bucket\n      const {\n        error: listFilesError\n      } = await storage.from(bucketName).list();\n      if (!listFilesError) {\n        // Si no hay error al listar archivos, significa que el bucket existe\n        console.log(`El bucket ${bucketName} existe y es accesible.`);\n        return true;\n      }\n      throw createAppError(ErrorType.UPLOAD, `Error al acceder al almacenamiento: ${listError.message}`, {\n        error: listError\n      });\n    }\n\n    // Verificar si el bucket ya existe\n    const bucketExists = buckets === null || buckets === void 0 ? void 0 : buckets.some(bucket => bucket.name === bucketName);\n    if (bucketExists) {\n      console.log(`El bucket ${bucketName} ya existe.`);\n      return true;\n    }\n    console.log(`El bucket ${bucketName} no existe. Intentando crearlo...`);\n\n    // Crear el bucket si no existe\n    const MAX_RETRIES = 2;\n    let attempt = 0;\n    let lastError = null;\n    while (attempt < MAX_RETRIES) {\n      try {\n        const {\n          data,\n          error: createError\n        } = await storage.createBucket(bucketName, {\n          public: false\n        });\n        if (createError) {\n          var _createError$message;\n          console.error(`Error al crear el bucket ${bucketName} (intento ${attempt + 1}/${MAX_RETRIES}):`, createError);\n          lastError = createError;\n\n          // Si el error indica que el bucket ya existe, consideremos eso un éxito\n          if ((_createError$message = createError.message) !== null && _createError$message !== void 0 && _createError$message.includes('already exists')) {\n            console.log(`El bucket ${bucketName} ya existe (según el mensaje de error).`);\n            return true;\n          }\n          throw createError;\n        }\n        console.log(`Bucket ${bucketName} creado correctamente.`);\n\n        // Intentar establecer políticas públicas para el bucket\n        try {\n          // Establecer políticas de acceso público para archivos en el bucket\n          const {\n            error: policyError\n          } = await storage.from(bucketName).createPolicy('public-read', {\n            name: 'public-read',\n            definition: {\n              file: {\n                downloadBySignedUrl: true // permitir acceso por URL firmada\n              }\n            }\n          });\n          if (policyError && !policyError.message.includes('already exists')) {\n            console.warn(`Advertencia al configurar políticas del bucket: ${policyError.message}`);\n          }\n        } catch (policyError) {\n          // No bloquear el proceso si falla la creación de la política\n          console.warn(`No se pudo crear la política para el bucket ${bucketName}:`, policyError);\n        }\n        return true;\n      } catch (error) {\n        lastError = error;\n        attempt++;\n\n        // Si no es el último intento, esperar antes de reintentar\n        if (attempt < MAX_RETRIES) {\n          const waitTime = 1000 * Math.pow(2, attempt - 1); // Backoff exponencial\n          console.log(`Esperando ${waitTime}ms antes de reintentar crear el bucket...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n\n    // Si llegamos aquí, todos los intentos fallaron\n    throw lastError || new Error(`No se pudo crear el bucket ${bucketName} después de ${MAX_RETRIES} intentos.`);\n  } catch (error) {\n    // Como último recurso, verificamos si podemos escribir en el bucket aunque no podamos crearlo\n    try {\n      const storage = getStorage();\n      const testFilePath = `test-${Date.now()}.txt`;\n      const testContent = new Blob(['test'], {\n        type: 'text/plain'\n      });\n      console.log(`Intentando escribir archivo de prueba en ${bucketName}/${testFilePath} como último recurso...`);\n      const {\n        error: uploadError\n      } = await storage.from(bucketName).upload(testFilePath, testContent);\n      if (!uploadError) {\n        console.log(`¡Éxito! El bucket ${bucketName} existe y permite escritura.`);\n        // Limpieza del archivo de prueba\n        await storage.from(bucketName).remove([testFilePath]);\n        return true;\n      }\n    } catch (testError) {\n      console.error(`Error en la prueba final de escritura en bucket:`, testError);\n    }\n    console.error(`Error al verificar/crear bucket ${bucketName}:`, error);\n    throw createAppError(ErrorType.UPLOAD, error instanceof Error ? `Error al crear el bucket de almacenamiento: ${error.message}` : 'Error desconocido al crear el bucket de almacenamiento', {\n      bucketName,\n      error\n    });\n  }\n};\n\n/**\n * Uploads client documents to storage\n * @param clientId The client ID\n * @param documents Array of documents to upload\n * @param maxRetries Maximum number of retry attempts (default: 2)\n * @returns Array of successfully uploaded documents (without the original file object)\n */\nexport const uploadClientDocuments = async (clientId, documents, maxRetries = 2) => {\n  // Verify parameters\n  if (!clientId) {\n    throw new Error('Client ID is required for uploading documents');\n  }\n  if (!documents || !Array.isArray(documents) || documents.length === 0) {\n    return [];\n  }\n  try {\n    // Asegurar que el bucket existe antes de continuar\n    const bucketName = 'client-documents';\n    await ensureClientBucketExists(bucketName);\n    const storage = getStorage();\n    const uploadedDocs = [];\n    const failedDocs = [];\n\n    // Filter out documents without files\n    const validDocuments = documents.filter(doc => doc.file && doc.category && doc.name);\n    console.log(`Intentando subir ${validDocuments.length} documentos para el cliente ${clientId}`);\n    for (const doc of validDocuments) {\n      let fileUrl = '';\n      let success = false;\n      let attempts = 0;\n      let lastError = null;\n      while (!success && attempts <= maxRetries) {\n        attempts++;\n        try {\n          // Construct a unique file name to avoid collisions\n          const timestamp = new Date().getTime();\n          const fileName = `${timestamp}_${doc.file.name.replace(/\\s+/g, '_')}`;\n          const filePath = `${clientId}/${doc.category}/${fileName}`;\n          console.log(`Intento ${attempts}/${maxRetries + 1}: Subiendo documento \"${doc.name}\" a ${filePath}`);\n\n          // Upload the file\n          const {\n            data,\n            error\n          } = await storage.from(bucketName).upload(filePath, doc.file, {\n            cacheControl: '3600',\n            upsert: true // Cambiar a true para sobrescribir si existe\n          });\n          if (error) {\n            console.error(`Error al subir archivo (intento ${attempts}/${maxRetries + 1}):`, error);\n            lastError = error;\n            throw error;\n          }\n\n          // Get the public URL\n          const {\n            data: urlData\n          } = storage.from(bucketName).getPublicUrl(filePath);\n          fileUrl = urlData.publicUrl;\n          success = true;\n          console.log(`Documento \"${doc.name}\" subido exitosamente a ${filePath}`);\n        } catch (error) {\n          lastError = error;\n\n          // Si no es el último intento, esperar antes de reintentar\n          if (attempts <= maxRetries) {\n            const waitTime = Math.pow(2, attempts - 1) * 1000; // Backoff exponencial\n            console.log(`Esperando ${waitTime}ms antes de reintentar...`);\n            await new Promise(resolve => setTimeout(resolve, waitTime));\n          } else {\n            console.error(`Falló la subida después de ${attempts} intentos.`);\n            failedDocs.push({\n              name: doc.name || doc.file.name,\n              error: error\n            });\n            logError(ErrorType.UPLOAD, `Error al subir documento \"${doc.name || doc.file.name}\" después de ${maxRetries + 1} intentos`, {\n              documentName: doc.file.name,\n              clientId,\n              error,\n              category: doc.category\n            });\n          }\n        }\n      }\n      if (success) {\n        // Create document without the file property\n        const {\n          file,\n          ...docWithoutFile\n        } = doc;\n        uploadedDocs.push({\n          ...docWithoutFile,\n          url: fileUrl\n        });\n      }\n    }\n    if (failedDocs.length > 0) {\n      console.warn(`${failedDocs.length} documentos fallaron al subirse:`, failedDocs);\n    }\n    console.log(`Completado: ${uploadedDocs.length} documentos subidos exitosamente`);\n    return uploadedDocs;\n  } catch (error) {\n    console.error('Error general en uploadClientDocuments:', error);\n    throw createAppError(ErrorType.UPLOAD, error instanceof Error ? error.message : 'Error al subir documentos', {\n      clientId,\n      error\n    });\n  }\n};","map":{"version":3,"names":["supabase","ErrorType","createAppError","logError","safeAsync","v4","uuidv4","getStorage","MAX_UPLOAD_RETRIES","isValidDocument","file","allowedTypes","maxSize","includes","type","size","uploadDocumentToStorage","document","folder","attempt","VALIDATION","fileName","name","fileType","fileSize","fileId","fileExtension","split","pop","filePath","error","uploadError","storage","from","upload","UPLOAD","message","data","publicUrlData","getPublicUrl","id","url","publicUrl","description","createdAt","Date","toISOString","delay","Math","pow","Promise","resolve","setTimeout","uploadDocuments","documents","uploadedDocs","failedDocs","uploaded","push","ensureClientBucketExists","bucketName","console","log","buckets","listError","listBuckets","listFilesError","list","bucketExists","some","bucket","MAX_RETRIES","lastError","createError","createBucket","public","_createError$message","policyError","createPolicy","definition","downloadBySignedUrl","warn","waitTime","Error","testFilePath","now","testContent","Blob","remove","testError","uploadClientDocuments","clientId","maxRetries","Array","isArray","length","validDocuments","filter","doc","category","fileUrl","success","attempts","timestamp","getTime","replace","cacheControl","upsert","urlData","documentName","docWithoutFile"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/documentUpload.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { ErrorType, createAppError, logError, safeAsync } from './errorHandling';\nimport { v4 as uuidv4 } from 'uuid';\nimport { getStorage } from '../lib/supabaseClient';\nimport { ClientDocument } from '../types/client';\n\nexport interface UploadDocument {\n  file: File;\n  type: string;\n  description?: string;\n}\n\nexport interface UploadedDocument {\n  id: string;\n  name: string;\n  size: number;\n  type: string;\n  url: string;\n  description?: string;\n  createdAt: string;\n}\n\n/**\n * Maximum number of upload retry attempts\n */\nexport const MAX_UPLOAD_RETRIES = 3;\n\n/**\n * Validates if a file is a valid document for upload\n */\nexport const isValidDocument = (file: File): boolean => {\n  // Allowed MIME types\n  const allowedTypes = [\n    'application/pdf',\n    'image/jpeg',\n    'image/png',\n    'image/jpg',\n    'image/heic',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n    'application/vnd.ms-excel'\n  ];\n\n  // Maximum file size (10MB)\n  const maxSize = 10 * 1024 * 1024;\n\n  return allowedTypes.includes(file.type) && file.size <= maxSize;\n};\n\n/**\n * Uploads a document to storage with automatic retries\n */\nexport const uploadDocumentToStorage = async (\n  document: UploadDocument,\n  folder: string,\n  attempt = 1\n): Promise<UploadedDocument> => {\n  const file = document.file;\n  \n  if (!isValidDocument(file)) {\n    throw createAppError(\n      ErrorType.VALIDATION,\n      'Invalid document format or size',\n      { \n        fileName: file.name, \n        fileType: file.type, \n        fileSize: file.size \n      }\n    );\n  }\n  \n  try {\n    // Generate unique file id and name\n    const fileId = uuidv4();\n    const fileExtension = file.name.split('.').pop();\n    const fileName = `${fileId}.${fileExtension}`;\n    const filePath = `${folder}/${fileName}`;\n    \n    // Upload the file\n    const { error: uploadError } = await supabase.storage\n      .from('documents')\n      .upload(filePath, file);\n    \n    if (uploadError) {\n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error uploading document: ${uploadError.message}`,\n        { filePath, attempt },\n        uploadError\n      );\n    }\n    \n    // Get public URL for the uploaded file\n    const { data: publicUrlData } = supabase.storage\n      .from('documents')\n      .getPublicUrl(filePath);\n    \n    // Return document info\n    return {\n      id: fileId,\n      name: file.name,\n      size: file.size,\n      type: document.type,\n      url: publicUrlData.publicUrl,\n      description: document.description,\n      createdAt: new Date().toISOString()\n    };\n  } catch (error) {\n    // Retry logic for transient errors\n    if (attempt < MAX_UPLOAD_RETRIES) {\n      logError(error, 'documentUpload', { \n        message: `Retrying upload (${attempt + 1}/${MAX_UPLOAD_RETRIES})`,\n        fileName: file.name\n      });\n      \n      // Exponential backoff delay\n      const delay = Math.pow(2, attempt) * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n      \n      // Retry with incremented attempt count\n      return uploadDocumentToStorage(document, folder, attempt + 1);\n    }\n    \n    // Max retries reached, rethrow error\n    throw error;\n  }\n};\n\n/**\n * Uploads multiple documents with reliable error handling\n */\nexport const uploadDocuments = async (\n  documents: UploadDocument[],\n  folder: string\n): Promise<{\n  uploadedDocs: UploadedDocument[];\n  failedDocs: Array<{ document: UploadDocument; error: any }>;\n}> => {\n  const uploadedDocs: UploadedDocument[] = [];\n  const failedDocs: Array<{ document: UploadDocument; error: any }> = [];\n  \n  // Process each document\n  for (const document of documents) {\n    const [uploaded, error] = await safeAsync(\n      uploadDocumentToStorage(document, folder),\n      'uploadDocuments'\n    );\n    \n    if (uploaded) {\n      uploadedDocs.push(uploaded);\n    } else if (error) {\n      failedDocs.push({ \n        document, \n        error \n      });\n    }\n  }\n  \n  return { uploadedDocs, failedDocs };\n};\n\n/**\n * Asegura que el bucket de almacenamiento exista antes de utilizarlo\n * @param bucketName Nombre del bucket a verificar\n * @returns True si el bucket existe o fue creado correctamente\n */\nexport const ensureClientBucketExists = async (bucketName: string = 'client-documents'): Promise<boolean> => {\n  try {\n    console.log(`Verificando si el bucket ${bucketName} existe...`);\n    const storage = getStorage();\n    \n    // Intentar listar buckets para verificar si existe\n    const { data: buckets, error: listError } = await storage.listBuckets();\n    \n    if (listError) {\n      console.error(`Error al listar buckets:`, listError);\n      // Si hay un error al listar buckets, podría ser un problema de permisos\n      // Intentaremos verificar directamente intentando listar archivos del bucket\n      const { error: listFilesError } = await storage.from(bucketName).list();\n      \n      if (!listFilesError) {\n        // Si no hay error al listar archivos, significa que el bucket existe\n        console.log(`El bucket ${bucketName} existe y es accesible.`);\n        return true;\n      }\n      \n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error al acceder al almacenamiento: ${listError.message}`,\n        { error: listError }\n      );\n    }\n    \n    // Verificar si el bucket ya existe\n    const bucketExists = buckets?.some(bucket => bucket.name === bucketName);\n    \n    if (bucketExists) {\n      console.log(`El bucket ${bucketName} ya existe.`);\n      return true;\n    }\n    \n    console.log(`El bucket ${bucketName} no existe. Intentando crearlo...`);\n    \n    // Crear el bucket si no existe\n    const MAX_RETRIES = 2;\n    let attempt = 0;\n    let lastError = null;\n    \n    while (attempt < MAX_RETRIES) {\n      try {\n        const { data, error: createError } = await storage.createBucket(bucketName, {\n          public: false\n        });\n        \n        if (createError) {\n          console.error(`Error al crear el bucket ${bucketName} (intento ${attempt + 1}/${MAX_RETRIES}):`, createError);\n          lastError = createError;\n          \n          // Si el error indica que el bucket ya existe, consideremos eso un éxito\n          if (createError.message?.includes('already exists')) {\n            console.log(`El bucket ${bucketName} ya existe (según el mensaje de error).`);\n            return true;\n          }\n          \n          throw createError;\n        }\n        \n        console.log(`Bucket ${bucketName} creado correctamente.`);\n        \n        // Intentar establecer políticas públicas para el bucket\n        try {\n          // Establecer políticas de acceso público para archivos en el bucket\n          const { error: policyError } = await storage.from(bucketName).createPolicy(\n            'public-read',\n            {\n              name: 'public-read',\n              definition: {\n                file: {\n                  downloadBySignedUrl: true  // permitir acceso por URL firmada\n                }\n              }\n            }\n          );\n          \n          if (policyError && !policyError.message.includes('already exists')) {\n            console.warn(`Advertencia al configurar políticas del bucket: ${policyError.message}`);\n          }\n        } catch (policyError) {\n          // No bloquear el proceso si falla la creación de la política\n          console.warn(`No se pudo crear la política para el bucket ${bucketName}:`, policyError);\n        }\n        \n        return true;\n      } catch (error) {\n        lastError = error;\n        attempt++;\n        \n        // Si no es el último intento, esperar antes de reintentar\n        if (attempt < MAX_RETRIES) {\n          const waitTime = 1000 * Math.pow(2, attempt - 1); // Backoff exponencial\n          console.log(`Esperando ${waitTime}ms antes de reintentar crear el bucket...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n    \n    // Si llegamos aquí, todos los intentos fallaron\n    throw lastError || new Error(`No se pudo crear el bucket ${bucketName} después de ${MAX_RETRIES} intentos.`);\n  } catch (error) {\n    // Como último recurso, verificamos si podemos escribir en el bucket aunque no podamos crearlo\n    try {\n      const storage = getStorage();\n      const testFilePath = `test-${Date.now()}.txt`;\n      const testContent = new Blob(['test'], { type: 'text/plain' });\n      \n      console.log(`Intentando escribir archivo de prueba en ${bucketName}/${testFilePath} como último recurso...`);\n      const { error: uploadError } = await storage.from(bucketName).upload(testFilePath, testContent);\n      \n      if (!uploadError) {\n        console.log(`¡Éxito! El bucket ${bucketName} existe y permite escritura.`);\n        // Limpieza del archivo de prueba\n        await storage.from(bucketName).remove([testFilePath]);\n        return true;\n      }\n    } catch (testError) {\n      console.error(`Error en la prueba final de escritura en bucket:`, testError);\n    }\n    \n    console.error(`Error al verificar/crear bucket ${bucketName}:`, error);\n    throw createAppError(\n      ErrorType.UPLOAD,\n      error instanceof Error \n        ? `Error al crear el bucket de almacenamiento: ${error.message}` \n        : 'Error desconocido al crear el bucket de almacenamiento',\n      { bucketName, error }\n    );\n  }\n};\n\n/**\n * Uploads client documents to storage\n * @param clientId The client ID\n * @param documents Array of documents to upload\n * @param maxRetries Maximum number of retry attempts (default: 2)\n * @returns Array of successfully uploaded documents (without the original file object)\n */\nexport const uploadClientDocuments = async (\n  clientId: string,\n  documents: ClientDocument[],\n  maxRetries = 2\n): Promise<Omit<ClientDocument & { url: string }, 'file'>[]> => {\n  // Verify parameters\n  if (!clientId) {\n    throw new Error('Client ID is required for uploading documents');\n  }\n\n  if (!documents || !Array.isArray(documents) || documents.length === 0) {\n    return [];\n  }\n\n  try {\n    // Asegurar que el bucket existe antes de continuar\n    const bucketName = 'client-documents';\n    await ensureClientBucketExists(bucketName);\n    \n    const storage = getStorage();\n    const uploadedDocs: Array<Omit<ClientDocument & { url: string }, 'file'>> = [];\n    const failedDocs: Array<{name: string, error: any}> = [];\n\n    // Filter out documents without files\n    const validDocuments = documents.filter(doc => doc.file && doc.category && doc.name);\n    console.log(`Intentando subir ${validDocuments.length} documentos para el cliente ${clientId}`);\n\n    for (const doc of validDocuments) {\n      let fileUrl = '';\n      let success = false;\n      let attempts = 0;\n      let lastError = null;\n\n      while (!success && attempts <= maxRetries) {\n        attempts++;\n        try {\n          // Construct a unique file name to avoid collisions\n          const timestamp = new Date().getTime();\n          const fileName = `${timestamp}_${doc.file.name.replace(/\\s+/g, '_')}`;\n          const filePath = `${clientId}/${doc.category}/${fileName}`;\n\n          console.log(`Intento ${attempts}/${maxRetries+1}: Subiendo documento \"${doc.name}\" a ${filePath}`);\n\n          // Upload the file\n          const { data, error } = await storage\n            .from(bucketName)\n            .upload(filePath, doc.file, {\n              cacheControl: '3600',\n              upsert: true, // Cambiar a true para sobrescribir si existe\n            });\n\n          if (error) {\n            console.error(`Error al subir archivo (intento ${attempts}/${maxRetries+1}):`, error);\n            lastError = error;\n            throw error;\n          }\n\n          // Get the public URL\n          const { data: urlData } = storage\n            .from(bucketName)\n            .getPublicUrl(filePath);\n\n          fileUrl = urlData.publicUrl;\n          success = true;\n          console.log(`Documento \"${doc.name}\" subido exitosamente a ${filePath}`);\n        } catch (error) {\n          lastError = error;\n          \n          // Si no es el último intento, esperar antes de reintentar\n          if (attempts <= maxRetries) {\n            const waitTime = Math.pow(2, attempts-1) * 1000; // Backoff exponencial\n            console.log(`Esperando ${waitTime}ms antes de reintentar...`);\n            await new Promise(resolve => setTimeout(resolve, waitTime));\n          } else {\n            console.error(`Falló la subida después de ${attempts} intentos.`);\n            failedDocs.push({\n              name: doc.name || doc.file.name,\n              error: error\n            });\n            \n            logError(\n              ErrorType.UPLOAD,\n              `Error al subir documento \"${doc.name || doc.file.name}\" después de ${maxRetries+1} intentos`,\n              { documentName: doc.file.name, clientId, error, category: doc.category }\n            );\n          }\n        }\n      }\n\n      if (success) {\n        // Create document without the file property\n        const { file, ...docWithoutFile } = doc;\n        uploadedDocs.push({\n          ...docWithoutFile,\n          url: fileUrl\n        });\n      }\n    }\n\n    if (failedDocs.length > 0) {\n      console.warn(`${failedDocs.length} documentos fallaron al subirse:`, failedDocs);\n    }\n    \n    console.log(`Completado: ${uploadedDocs.length} documentos subidos exitosamente`);\n    return uploadedDocs;\n  } catch (error) {\n    console.error('Error general en uploadClientDocuments:', error);\n    throw createAppError(\n      ErrorType.UPLOAD,\n      error instanceof Error ? error.message : 'Error al subir documentos',\n      { clientId, error }\n    );\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}