{"ast":null,"code":"import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\n// Tipos de mensajes para clasificar la comunicación\nexport let MessageType = /*#__PURE__*/function (MessageType) {\n  MessageType[\"GENERAL\"] = \"general\";\n  MessageType[\"APPLICATION\"] = \"application\";\n  MessageType[\"APPROVAL_REQUEST\"] = \"approval_request\";\n  MessageType[\"APPROVAL_RESPONSE\"] = \"approval_response\";\n  MessageType[\"DOCUMENT_REQUEST\"] = \"document_request\";\n  MessageType[\"PAYMENT_NOTIFICATION\"] = \"payment_notification\";\n  MessageType[\"SYSTEM\"] = \"system\";\n  return MessageType;\n}({});\n\n// Interfaz para el objeto de mensaje\n\n// Interfaz para el objeto de mensaje al crearlo (sin ID ni timestamp)\n\n/**\n * Envía un mensaje entre usuarios\n * @param messageData Datos del mensaje a enviar\n * @returns El mensaje creado\n */\nexport const sendMessage = async messageData => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from(TABLES.MESSAGES).insert([messageData]).select('*').single();\n    if (error) {\n      console.error('Error al enviar mensaje:', error);\n      throw new Error(`Error al enviar mensaje: ${error.message}`);\n    }\n    return data;\n  } catch (error) {\n    console.error('Error en sendMessage:', error);\n    throw new Error(`Error al enviar mensaje: ${error.message}`);\n  }\n};\n\n/**\n * Obtiene todos los mensajes para un usuario específico\n * @param userId ID del usuario para el que se obtienen los mensajes\n * @param filter Filtros opcionales (aplicación relacionada, tipo de mensaje)\n * @returns Lista de mensajes\n */\nexport const getUserMessages = async (userId, filter) => {\n  try {\n    let query = supabase.from(TABLES.MESSAGES).select('*').or(`receiver_id.eq.${userId},sender_id.eq.${userId}`).order('created_at', {\n      ascending: false\n    });\n\n    // Aplicar filtros si existen\n    if (filter !== null && filter !== void 0 && filter.relatedApplicationId) {\n      query = query.eq('related_application_id', filter.relatedApplicationId);\n    }\n    if (filter !== null && filter !== void 0 && filter.messageType) {\n      query = query.eq('message_type', filter.messageType);\n    }\n    if (filter !== null && filter !== void 0 && filter.onlyUnread) {\n      query = query.eq('read_status', false).eq('receiver_id', userId);\n    }\n    if (filter !== null && filter !== void 0 && filter.otherUserId) {\n      query = query.or(`receiver_id.eq.${filter.otherUserId},sender_id.eq.${filter.otherUserId}`);\n    }\n    const {\n      data,\n      error\n    } = await query;\n    if (error) {\n      console.error('Error al obtener mensajes:', error);\n      throw new Error(`Error al obtener mensajes: ${error.message}`);\n    }\n    return data;\n  } catch (error) {\n    console.error('Error en getUserMessages:', error);\n    throw new Error(`Error al obtener mensajes: ${error.message}`);\n  }\n};\n\n/**\n * Obtiene las conversaciones de un usuario\n * @param userId ID del usuario\n * @returns Lista de usuarios con los que ha conversado, con el último mensaje\n */\nexport const getUserConversations = async userId => {\n  try {\n    // Primero obtenemos todos los mensajes del usuario\n    const {\n      data: messages,\n      error\n    } = await supabase.from(TABLES.MESSAGES).select('*').or(`receiver_id.eq.${userId},sender_id.eq.${userId}`).order('created_at', {\n      ascending: false\n    });\n    if (error) {\n      console.error('Error al obtener conversaciones:', error);\n      throw new Error(`Error al obtener conversaciones: ${error.message}`);\n    }\n\n    // Agrupar mensajes por usuario (conversación)\n    const conversations = new Map();\n    for (const message of messages) {\n      // Identificar al otro usuario de la conversación\n      const otherUserId = message.sender_id === userId ? message.receiver_id : message.sender_id;\n\n      // Si no tenemos esta conversación aún, añadirla\n      if (!conversations.has(otherUserId)) {\n        conversations.set(otherUserId, {\n          userId: otherUserId,\n          lastMessage: message,\n          unreadCount: message.receiver_id === userId && !message.read_status ? 1 : 0\n        });\n      } else if (message.receiver_id === userId && !message.read_status) {\n        // Si ya tenemos la conversación, solo actualizar el contador de no leídos\n        const conversation = conversations.get(otherUserId);\n        conversation.unreadCount += 1;\n      }\n    }\n\n    // Convertir el mapa en array y retornar\n    return Array.from(conversations.values());\n  } catch (error) {\n    console.error('Error en getUserConversations:', error);\n    throw new Error(`Error al obtener conversaciones: ${error.message}`);\n  }\n};\n\n/**\n * Obtiene todos los mensajes entre dos usuarios\n * @param userId1 ID del primer usuario\n * @param userId2 ID del segundo usuario\n * @param applicationId ID opcional de una aplicación relacionada\n * @returns Lista de mensajes\n */\nexport const getConversation = async (userId1, userId2, applicationId) => {\n  try {\n    let query = supabase.from(TABLES.MESSAGES).select('*').or(`and(sender_id.eq.${userId1},receiver_id.eq.${userId2}),and(sender_id.eq.${userId2},receiver_id.eq.${userId1})`).order('created_at', {\n      ascending: true\n    });\n    if (applicationId) {\n      query = query.eq('related_application_id', applicationId);\n    }\n    const {\n      data,\n      error\n    } = await query;\n    if (error) {\n      console.error('Error al obtener conversación:', error);\n      throw new Error(`Error al obtener conversación: ${error.message}`);\n    }\n    return data;\n  } catch (error) {\n    console.error('Error en getConversation:', error);\n    throw new Error(`Error al obtener conversación: ${error.message}`);\n  }\n};\n\n/**\n * Marca un mensaje como leído\n * @param messageId ID del mensaje a marcar\n * @returns El mensaje actualizado\n */\nexport const markMessageAsRead = async messageId => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from(TABLES.MESSAGES).update({\n      read_status: true\n    }).eq('id', messageId);\n    if (error) {\n      console.error('Error al marcar mensaje como leído:', error);\n      throw new Error(`Error al marcar mensaje como leído: ${error.message}`);\n    }\n    return;\n  } catch (error) {\n    console.error('Error en markMessageAsRead:', error);\n    throw new Error(`Error al marcar mensaje como leído: ${error.message}`);\n  }\n};\n\n/**\n * Marca todos los mensajes de una conversación como leídos\n * @param userId ID del usuario que está marcando los mensajes\n * @param otherUserId ID del otro usuario en la conversación\n * @returns Void\n */\nexport const markConversationAsRead = async (userId, otherUserId) => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from(TABLES.MESSAGES).update({\n      read_status: true\n    }).eq('receiver_id', userId).eq('sender_id', otherUserId).eq('read_status', false);\n    if (error) {\n      console.error('Error al marcar conversación como leída:', error);\n      throw new Error(`Error al marcar conversación como leída: ${error.message}`);\n    }\n    return;\n  } catch (error) {\n    console.error('Error en markConversationAsRead:', error);\n    throw new Error(`Error al marcar conversación como leída: ${error.message}`);\n  }\n};\n\n/**\n * Marca todos los mensajes relacionados con una aplicación como leídos\n * @param userId ID del usuario que está marcando los mensajes\n * @param applicationId ID de la aplicación relacionada\n * @returns Void\n */\nexport const markApplicationMessagesAsRead = async (userId, applicationId) => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from(TABLES.MESSAGES).update({\n      read_status: true\n    }).eq('receiver_id', userId).eq('related_application_id', applicationId).eq('read_status', false);\n    if (error) {\n      console.error('Error al marcar mensajes de aplicación como leídos:', error);\n      throw new Error(`Error al marcar mensajes de aplicación como leídos: ${error.message}`);\n    }\n    return;\n  } catch (error) {\n    console.error('Error en markApplicationMessagesAsRead:', error);\n    throw new Error(`Error al marcar mensajes de aplicación como leídos: ${error.message}`);\n  }\n};\n\n/**\n * Cuenta los mensajes no leídos para un usuario\n * @param userId ID del usuario\n * @returns Número de mensajes no leídos\n */\nexport const getUnreadMessageCount = async userId => {\n  try {\n    const {\n      count,\n      error\n    } = await supabase.from(TABLES.MESSAGES).select('*', {\n      count: 'exact',\n      head: true\n    }).eq('receiver_id', userId).eq('read_status', false);\n    if (error) {\n      console.error('Error al contar mensajes no leídos:', error);\n      throw new Error(`Error al contar mensajes no leídos: ${error.message}`);\n    }\n    return count || 0;\n  } catch (error) {\n    console.error('Error en getUnreadMessageCount:', error);\n    throw new Error(`Error al contar mensajes no leídos: ${error.message}`);\n  }\n};","map":{"version":3,"names":["supabase","TABLES","MessageType","sendMessage","messageData","data","error","from","MESSAGES","insert","select","single","console","Error","message","getUserMessages","userId","filter","query","or","order","ascending","relatedApplicationId","eq","messageType","onlyUnread","otherUserId","getUserConversations","messages","conversations","Map","sender_id","receiver_id","has","set","lastMessage","unreadCount","read_status","conversation","get","Array","values","getConversation","userId1","userId2","applicationId","markMessageAsRead","messageId","update","markConversationAsRead","markApplicationMessagesAsRead","getUnreadMessageCount","count","head"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/messageService.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { ApplicationFilter } from './applicationService';\n\n// Tipos de mensajes para clasificar la comunicación\nexport enum MessageType {\n  GENERAL = 'general',\n  APPLICATION = 'application',\n  APPROVAL_REQUEST = 'approval_request',\n  APPROVAL_RESPONSE = 'approval_response',\n  DOCUMENT_REQUEST = 'document_request',\n  PAYMENT_NOTIFICATION = 'payment_notification',\n  SYSTEM = 'system'\n}\n\n// Interfaz para el objeto de mensaje\nexport interface Message {\n  id: string;\n  sender_id: string;\n  receiver_id: string;\n  message_content: string;\n  related_application_id?: string;\n  read_status: boolean;\n  message_type: MessageType;\n  created_at: string;\n}\n\n// Interfaz para el objeto de mensaje al crearlo (sin ID ni timestamp)\nexport interface MessageInput {\n  sender_id: string;\n  receiver_id: string;\n  message_content: string;\n  related_application_id?: string;\n  message_type: MessageType;\n}\n\n/**\n * Envía un mensaje entre usuarios\n * @param messageData Datos del mensaje a enviar\n * @returns El mensaje creado\n */\nexport const sendMessage = async (messageData: MessageInput): Promise<Message> => {\n  try {\n    const { data, error } = await supabase\n      .from(TABLES.MESSAGES)\n      .insert([messageData])\n      .select('*')\n      .single();\n\n    if (error) {\n      console.error('Error al enviar mensaje:', error);\n      throw new Error(`Error al enviar mensaje: ${error.message}`);\n    }\n\n    return data as Message;\n  } catch (error: any) {\n    console.error('Error en sendMessage:', error);\n    throw new Error(`Error al enviar mensaje: ${error.message}`);\n  }\n};\n\n/**\n * Obtiene todos los mensajes para un usuario específico\n * @param userId ID del usuario para el que se obtienen los mensajes\n * @param filter Filtros opcionales (aplicación relacionada, tipo de mensaje)\n * @returns Lista de mensajes\n */\nexport const getUserMessages = async (\n  userId: string,\n  filter?: {\n    relatedApplicationId?: string;\n    messageType?: MessageType;\n    onlyUnread?: boolean;\n    otherUserId?: string;\n  }\n): Promise<Message[]> => {\n  try {\n    let query = supabase\n      .from(TABLES.MESSAGES)\n      .select('*')\n      .or(`receiver_id.eq.${userId},sender_id.eq.${userId}`)\n      .order('created_at', { ascending: false });\n\n    // Aplicar filtros si existen\n    if (filter?.relatedApplicationId) {\n      query = query.eq('related_application_id', filter.relatedApplicationId);\n    }\n\n    if (filter?.messageType) {\n      query = query.eq('message_type', filter.messageType);\n    }\n\n    if (filter?.onlyUnread) {\n      query = query.eq('read_status', false).eq('receiver_id', userId);\n    }\n\n    if (filter?.otherUserId) {\n      query = query.or(`receiver_id.eq.${filter.otherUserId},sender_id.eq.${filter.otherUserId}`);\n    }\n\n    const { data, error } = await query;\n\n    if (error) {\n      console.error('Error al obtener mensajes:', error);\n      throw new Error(`Error al obtener mensajes: ${error.message}`);\n    }\n\n    return data as Message[];\n  } catch (error: any) {\n    console.error('Error en getUserMessages:', error);\n    throw new Error(`Error al obtener mensajes: ${error.message}`);\n  }\n};\n\n/**\n * Obtiene las conversaciones de un usuario\n * @param userId ID del usuario\n * @returns Lista de usuarios con los que ha conversado, con el último mensaje\n */\nexport const getUserConversations = async (userId: string): Promise<any[]> => {\n  try {\n    // Primero obtenemos todos los mensajes del usuario\n    const { data: messages, error } = await supabase\n      .from(TABLES.MESSAGES)\n      .select('*')\n      .or(`receiver_id.eq.${userId},sender_id.eq.${userId}`)\n      .order('created_at', { ascending: false });\n\n    if (error) {\n      console.error('Error al obtener conversaciones:', error);\n      throw new Error(`Error al obtener conversaciones: ${error.message}`);\n    }\n\n    // Agrupar mensajes por usuario (conversación)\n    const conversations = new Map();\n    \n    for (const message of messages) {\n      // Identificar al otro usuario de la conversación\n      const otherUserId = message.sender_id === userId \n        ? message.receiver_id \n        : message.sender_id;\n      \n      // Si no tenemos esta conversación aún, añadirla\n      if (!conversations.has(otherUserId)) {\n        conversations.set(otherUserId, {\n          userId: otherUserId,\n          lastMessage: message,\n          unreadCount: (message.receiver_id === userId && !message.read_status) ? 1 : 0\n        });\n      } else if (message.receiver_id === userId && !message.read_status) {\n        // Si ya tenemos la conversación, solo actualizar el contador de no leídos\n        const conversation = conversations.get(otherUserId);\n        conversation.unreadCount += 1;\n      }\n    }\n    \n    // Convertir el mapa en array y retornar\n    return Array.from(conversations.values());\n  } catch (error: any) {\n    console.error('Error en getUserConversations:', error);\n    throw new Error(`Error al obtener conversaciones: ${error.message}`);\n  }\n};\n\n/**\n * Obtiene todos los mensajes entre dos usuarios\n * @param userId1 ID del primer usuario\n * @param userId2 ID del segundo usuario\n * @param applicationId ID opcional de una aplicación relacionada\n * @returns Lista de mensajes\n */\nexport const getConversation = async (\n  userId1: string, \n  userId2: string,\n  applicationId?: string\n): Promise<Message[]> => {\n  try {\n    let query = supabase\n      .from(TABLES.MESSAGES)\n      .select('*')\n      .or(`and(sender_id.eq.${userId1},receiver_id.eq.${userId2}),and(sender_id.eq.${userId2},receiver_id.eq.${userId1})`)\n      .order('created_at', { ascending: true });\n    \n    if (applicationId) {\n      query = query.eq('related_application_id', applicationId);\n    }\n    \n    const { data, error } = await query;\n\n    if (error) {\n      console.error('Error al obtener conversación:', error);\n      throw new Error(`Error al obtener conversación: ${error.message}`);\n    }\n\n    return data as Message[];\n  } catch (error: any) {\n    console.error('Error en getConversation:', error);\n    throw new Error(`Error al obtener conversación: ${error.message}`);\n  }\n};\n\n/**\n * Marca un mensaje como leído\n * @param messageId ID del mensaje a marcar\n * @returns El mensaje actualizado\n */\nexport const markMessageAsRead = async (messageId: string): Promise<void> => {\n  try {\n    const { data, error } = await supabase\n      .from(TABLES.MESSAGES)\n      .update({ read_status: true })\n      .eq('id', messageId);\n\n    if (error) {\n      console.error('Error al marcar mensaje como leído:', error);\n      throw new Error(`Error al marcar mensaje como leído: ${error.message}`);\n    }\n\n    return;\n  } catch (error: any) {\n    console.error('Error en markMessageAsRead:', error);\n    throw new Error(`Error al marcar mensaje como leído: ${error.message}`);\n  }\n};\n\n/**\n * Marca todos los mensajes de una conversación como leídos\n * @param userId ID del usuario que está marcando los mensajes\n * @param otherUserId ID del otro usuario en la conversación\n * @returns Void\n */\nexport const markConversationAsRead = async (userId: string, otherUserId: string): Promise<void> => {\n  try {\n    const { data, error } = await supabase\n      .from(TABLES.MESSAGES)\n      .update({ read_status: true })\n      .eq('receiver_id', userId)\n      .eq('sender_id', otherUserId)\n      .eq('read_status', false);\n\n    if (error) {\n      console.error('Error al marcar conversación como leída:', error);\n      throw new Error(`Error al marcar conversación como leída: ${error.message}`);\n    }\n\n    return;\n  } catch (error: any) {\n    console.error('Error en markConversationAsRead:', error);\n    throw new Error(`Error al marcar conversación como leída: ${error.message}`);\n  }\n};\n\n/**\n * Marca todos los mensajes relacionados con una aplicación como leídos\n * @param userId ID del usuario que está marcando los mensajes\n * @param applicationId ID de la aplicación relacionada\n * @returns Void\n */\nexport const markApplicationMessagesAsRead = async (userId: string, applicationId: string): Promise<void> => {\n  try {\n    const { data, error } = await supabase\n      .from(TABLES.MESSAGES)\n      .update({ read_status: true })\n      .eq('receiver_id', userId)\n      .eq('related_application_id', applicationId)\n      .eq('read_status', false);\n\n    if (error) {\n      console.error('Error al marcar mensajes de aplicación como leídos:', error);\n      throw new Error(`Error al marcar mensajes de aplicación como leídos: ${error.message}`);\n    }\n\n    return;\n  } catch (error: any) {\n    console.error('Error en markApplicationMessagesAsRead:', error);\n    throw new Error(`Error al marcar mensajes de aplicación como leídos: ${error.message}`);\n  }\n};\n\n/**\n * Cuenta los mensajes no leídos para un usuario\n * @param userId ID del usuario\n * @returns Número de mensajes no leídos\n */\nexport const getUnreadMessageCount = async (userId: string): Promise<number> => {\n  try {\n    const { count, error } = await supabase\n      .from(TABLES.MESSAGES)\n      .select('*', { count: 'exact', head: true })\n      .eq('receiver_id', userId)\n      .eq('read_status', false);\n\n    if (error) {\n      console.error('Error al contar mensajes no leídos:', error);\n      throw new Error(`Error al contar mensajes no leídos: ${error.message}`);\n    }\n\n    return count || 0;\n  } catch (error: any) {\n    console.error('Error en getUnreadMessageCount:', error);\n    throw new Error(`Error al contar mensajes no leídos: ${error.message}`);\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}