{"ast":null,"code":"import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async client => {\n  const supabaseClient = client || supabase;\n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const {\n      error\n    } = await supabaseClient.storage.from(STORAGE_BUCKET).list();\n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || errorMessage.includes('does not exist') || errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async applicationId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('application_id', applicationId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async clientId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('client_id', clientId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async id => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('id', id).single();\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Upload a document\nexport async function uploadDocument(params) {\n  const {\n    file,\n    client_id,\n    application_id,\n    userId,\n    documentName,\n    category,\n    description,\n    authClient\n  } = params;\n\n  // Use authenticated client if provided, otherwise use default client\n  const supabaseClient = authClient || supabase;\n  console.log(`Starting document upload: ${documentName} for client ${client_id}`);\n  try {\n    // Primero creamos el registro para el documento\n    const {\n      data,\n      error\n    } = await supabaseClient.from(DOCUMENTS_TABLE).insert([{\n      name: documentName,\n      category,\n      description: description || null,\n      client_id: client_id || null,\n      application_id: application_id || null,\n      created_by: userId\n    }]).select().single();\n    if (error) {\n      console.error('Error creating document record:', error);\n\n      // Mejorar el mensaje de error para problemas de RLS\n      if (error.message && error.message.includes('violates row-level security policy')) {\n        console.error('RLS policy violation detected on document table insert');\n        throw new Error('No tienes permisos para crear documentos. Contacta al administrador para configurar las políticas RLS.');\n      }\n      throw new Error(`Error al crear el registro del documento: ${error.message}`);\n    }\n    if (!data) {\n      throw new Error('No se recibió respuesta al crear el registro del documento');\n    }\n    const documentId = data.id;\n    console.log(`Document record created with ID: ${documentId}`);\n\n    // Ahora subimos el archivo al bucket de storage\n    // Implementamos reintentos con backoff exponencial\n    const MAX_RETRIES = 3;\n    let lastError = null;\n    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {\n      try {\n        console.log(`Uploading file for document ${documentId}, attempt ${attempt}/${MAX_RETRIES}`);\n\n        // Construir la ruta del archivo\n        let filePath;\n        if (client_id) {\n          filePath = `client_${client_id}/${documentId}`;\n        } else if (application_id) {\n          filePath = `application_${application_id}/${documentId}`;\n        } else {\n          filePath = `uncategorized/${documentId}`;\n        }\n\n        // Convertir el file blob a un ArrayBuffer para la carga\n        const arrayBuffer = await file.arrayBuffer();\n        const fileBuffer = new Uint8Array(arrayBuffer);\n\n        // Subir el archivo usando el cliente autenticado\n        const {\n          data: uploadData,\n          error: uploadError\n        } = await supabaseClient.storage.from('documents').upload(filePath, fileBuffer, {\n          contentType: file.type,\n          upsert: true\n        });\n        if (uploadError) {\n          console.error(`Error uploading file (attempt ${attempt}/${MAX_RETRIES}):`, uploadError);\n\n          // Detección específica de problemas de RLS\n          if (uploadError.message.includes('violates row-level security policy') || uploadError.message.includes('Unauthorized') || typeof uploadError === 'object' && 'status' in uploadError && uploadError.status === 403) {\n            // No hacer más reintentos para errores de permisos\n            throw new Error('No tienes permisos para subir archivos al bucket. Contacta al administrador para configurar las políticas RLS del bucket \"documents\".');\n          }\n\n          // Lanzar error y permitir reintento\n          throw new Error(`Error al subir el archivo: ${uploadError.message}`);\n        }\n        if (!uploadData) {\n          throw new Error('No se recibió respuesta al subir el archivo');\n        }\n\n        // Actualizar el registro con la URL del archivo\n        const fileUrl = `${supabaseClient.storage.from('documents').getPublicUrl(filePath).data.publicUrl}`;\n        const {\n          data: updatedData,\n          error: updateError\n        } = await supabaseClient.from(DOCUMENTS_TABLE).update({\n          file_url: fileUrl,\n          file_path: filePath\n        }).eq('id', documentId).select().single();\n        if (updateError) {\n          console.error('Error updating document with file URL:', updateError);\n\n          // Intentar eliminar el archivo que subimos para evitar archivos huérfanos\n          try {\n            await supabaseClient.storage.from('documents').remove([filePath]);\n            console.log(`Cleaned up orphaned file at ${filePath} after failed URL update`);\n          } catch (cleanupError) {\n            console.warn('Failed to clean up orphaned file after URL update error:', cleanupError);\n          }\n          throw new Error(`Error al actualizar el documento con la URL del archivo: ${updateError.message}`);\n        }\n        if (!updatedData) {\n          // Intentar eliminar el archivo que subimos\n          try {\n            await supabaseClient.storage.from('documents').remove([filePath]);\n            console.log(`Cleaned up orphaned file at ${filePath} after failed document update`);\n          } catch (cleanupError) {\n            console.warn('Failed to clean up orphaned file after document update failure:', cleanupError);\n          }\n          throw new Error('No se recibió respuesta al actualizar el documento con la URL del archivo');\n        }\n        console.log(`Document ${documentId} successfully uploaded and updated with file URL`);\n\n        // Si llegamos aquí, todo salió bien\n        return updatedData;\n      } catch (error) {\n        lastError = error;\n\n        // Si es el último intento o es un error de permisos, no reintentamos\n        if (attempt === MAX_RETRIES || error instanceof Error && (error.message.includes('No tienes permisos') || error.message.includes('policy'))) {\n          break;\n        }\n\n        // Esperar antes de reintentar con backoff exponencial\n        const waitTime = 1000 * Math.pow(2, attempt - 1);\n        console.log(`Waiting ${waitTime}ms before retrying document upload...`);\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n      }\n    }\n\n    // Si llegamos aquí, todos los intentos fallaron\n    // Intentar eliminar el registro de documento ya que no pudimos subir el archivo\n    try {\n      await supabaseClient.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n      console.log(`Deleted document record ${documentId} after failed file upload`);\n    } catch (deleteError) {\n      console.warn(`Warning: Could not delete document record ${documentId} after failed upload:`, deleteError);\n    }\n\n    // Lanzar el último error que ocurrió\n    throw lastError || new Error('Error desconocido al subir el documento');\n  } catch (error) {\n    const documentError = {\n      message: error instanceof Error ? error.message : 'Error desconocido al subir el documento',\n      details: error\n    };\n    console.error('Document upload error:', documentError);\n    throw error;\n  }\n}\n\n// Delete a document\nexport const deleteDocument = async documentId => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n\n    // Get document to get file path\n    const {\n      data: document,\n      error: fetchError\n    } = await supabase.from(DOCUMENTS_TABLE).select('file_path').eq('id', documentId).single();\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const {\n      error: storageError\n    } = await supabase.storage.from(STORAGE_BUCKET).remove([document.file_path]);\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error ? storageError.message : typeof storageError === 'object' && storageError !== null && 'message' in storageError ? String(storageError.message) : 'Error desconocido';\n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const {\n      error: deleteError\n    } = await supabase.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async filePath => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    const {\n      data,\n      error\n    } = await supabase.storage.from(STORAGE_BUCKET).createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId, userId, isVerified = true) => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).update({\n    is_verified: isVerified,\n    verified_by: userId,\n    verified_at: new Date().toISOString()\n  }).eq('id', documentId).select();\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n  return data[0];\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async applicationType => {\n  const {\n    data,\n    error\n  } = await supabase.from('required_documents').select('*').eq('application_type', applicationType);\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n  return data;\n};","map":{"version":3,"names":["supabase","TABLES","DOCUMENTS_TABLE","DOCUMENTS","STORAGE_BUCKET","ensureStorageBucketExists","client","supabaseClient","error","storage","from","list","errorMessage","message","includes","console","log","Error","getApplicationDocuments","applicationId","data","select","eq","order","ascending","getClientDocuments","clientId","getDocumentById","id","single","uploadDocument","params","file","client_id","application_id","userId","documentName","category","description","authClient","insert","name","created_by","documentId","MAX_RETRIES","lastError","attempt","filePath","arrayBuffer","fileBuffer","Uint8Array","uploadData","uploadError","upload","contentType","type","upsert","status","fileUrl","getPublicUrl","publicUrl","updatedData","updateError","update","file_url","file_path","remove","cleanupError","warn","waitTime","Math","pow","Promise","resolve","setTimeout","delete","deleteError","documentError","details","deleteDocument","document","fetchError","storageError","String","getDocumentUrl","createSignedUrl","signedUrl","verifyDocument","isVerified","is_verified","verified_by","verified_at","Date","toISOString","getRequiredDocuments","applicationType"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/documentService.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { SupabaseClient } from '@supabase/supabase-js';\n\nexport interface Document {\n  id: string;\n  created_at: string;\n  file_name: string;\n  file_path: string;\n  file_type: string;\n  file_size: number;\n  category?: string;\n  application_id?: string;\n  client_id?: string;\n  uploaded_by_user_id?: string;\n  is_verified?: boolean;\n  verified_by?: string;\n  verified_at?: string;\n}\n\nexport interface DocumentUpload {\n  file: File;\n  application_id?: string;\n  client_id?: string;\n  userId: string;\n  documentName: string;\n  description?: string;\n  category?: string;\n  authClient?: SupabaseClient;\n}\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\nexport type UploadDocumentParams = DocumentUpload;\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async (client?: SupabaseClient) => {\n  const supabaseClient = client || supabase;\n  \n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const { error } = await supabaseClient.storage\n      .from(STORAGE_BUCKET)\n      .list();\n    \n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || \n          errorMessage.includes('does not exist') || \n          errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    \n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async (applicationId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('application_id', applicationId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async (clientId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('client_id', clientId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async (id: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n\n  return data as Document;\n};\n\n// Upload a document\nexport async function uploadDocument(params: UploadDocumentParams): Promise<Document> {\n  const { file, client_id, application_id, userId, documentName, category, description, authClient } = params;\n  \n  // Use authenticated client if provided, otherwise use default client\n  const supabaseClient = authClient || supabase;\n  \n  console.log(`Starting document upload: ${documentName} for client ${client_id}`);\n  \n  try {\n    // Primero creamos el registro para el documento\n    const { data, error } = await supabaseClient\n      .from(DOCUMENTS_TABLE)\n      .insert([\n        {\n          name: documentName,\n          category,\n          description: description || null,\n          client_id: client_id || null,\n          application_id: application_id || null,\n          created_by: userId,\n        },\n      ])\n      .select()\n      .single();\n\n    if (error) {\n      console.error('Error creating document record:', error);\n      \n      // Mejorar el mensaje de error para problemas de RLS\n      if (error.message && error.message.includes('violates row-level security policy')) {\n        console.error('RLS policy violation detected on document table insert');\n        throw new Error('No tienes permisos para crear documentos. Contacta al administrador para configurar las políticas RLS.');\n      }\n      \n      throw new Error(`Error al crear el registro del documento: ${error.message}`);\n    }\n\n    if (!data) {\n      throw new Error('No se recibió respuesta al crear el registro del documento');\n    }\n\n    const documentId = data.id;\n    console.log(`Document record created with ID: ${documentId}`);\n\n    // Ahora subimos el archivo al bucket de storage\n    // Implementamos reintentos con backoff exponencial\n    const MAX_RETRIES = 3;\n    let lastError = null;\n    \n    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {\n      try {\n        console.log(`Uploading file for document ${documentId}, attempt ${attempt}/${MAX_RETRIES}`);\n        \n        // Construir la ruta del archivo\n        let filePath: string;\n        if (client_id) {\n          filePath = `client_${client_id}/${documentId}`;\n        } else if (application_id) {\n          filePath = `application_${application_id}/${documentId}`;\n        } else {\n          filePath = `uncategorized/${documentId}`;\n        }\n\n        // Convertir el file blob a un ArrayBuffer para la carga\n        const arrayBuffer = await file.arrayBuffer();\n        const fileBuffer = new Uint8Array(arrayBuffer);\n\n        // Subir el archivo usando el cliente autenticado\n        const { data: uploadData, error: uploadError } = await supabaseClient.storage\n          .from('documents')\n          .upload(filePath, fileBuffer, {\n            contentType: file.type,\n            upsert: true,\n          });\n\n        if (uploadError) {\n          console.error(`Error uploading file (attempt ${attempt}/${MAX_RETRIES}):`, uploadError);\n          \n          // Detección específica de problemas de RLS\n          if (uploadError.message.includes('violates row-level security policy') || \n              uploadError.message.includes('Unauthorized') ||\n              (typeof uploadError === 'object' && 'status' in uploadError && uploadError.status === 403)) {\n            // No hacer más reintentos para errores de permisos\n            throw new Error('No tienes permisos para subir archivos al bucket. Contacta al administrador para configurar las políticas RLS del bucket \"documents\".');\n          }\n          \n          // Lanzar error y permitir reintento\n          throw new Error(`Error al subir el archivo: ${uploadError.message}`);\n        }\n\n        if (!uploadData) {\n          throw new Error('No se recibió respuesta al subir el archivo');\n        }\n\n        // Actualizar el registro con la URL del archivo\n        const fileUrl = `${supabaseClient.storage.from('documents').getPublicUrl(filePath).data.publicUrl}`;\n        \n        const { data: updatedData, error: updateError } = await supabaseClient\n          .from(DOCUMENTS_TABLE)\n          .update({ file_url: fileUrl, file_path: filePath })\n          .eq('id', documentId)\n          .select()\n          .single();\n\n        if (updateError) {\n          console.error('Error updating document with file URL:', updateError);\n          \n          // Intentar eliminar el archivo que subimos para evitar archivos huérfanos\n          try {\n            await supabaseClient.storage\n              .from('documents')\n              .remove([filePath]);\n            console.log(`Cleaned up orphaned file at ${filePath} after failed URL update`);\n          } catch (cleanupError) {\n            console.warn('Failed to clean up orphaned file after URL update error:', cleanupError);\n          }\n          \n          throw new Error(`Error al actualizar el documento con la URL del archivo: ${updateError.message}`);\n        }\n\n        if (!updatedData) {\n          // Intentar eliminar el archivo que subimos\n          try {\n            await supabaseClient.storage\n              .from('documents')\n              .remove([filePath]);\n            console.log(`Cleaned up orphaned file at ${filePath} after failed document update`);\n          } catch (cleanupError) {\n            console.warn('Failed to clean up orphaned file after document update failure:', cleanupError);\n          }\n          \n          throw new Error('No se recibió respuesta al actualizar el documento con la URL del archivo');\n        }\n\n        console.log(`Document ${documentId} successfully uploaded and updated with file URL`);\n        \n        // Si llegamos aquí, todo salió bien\n        return updatedData;\n      } catch (error) {\n        lastError = error;\n        \n        // Si es el último intento o es un error de permisos, no reintentamos\n        if (attempt === MAX_RETRIES || \n            (error instanceof Error && \n             (error.message.includes('No tienes permisos') || \n              error.message.includes('policy')))) {\n          break;\n        }\n        \n        // Esperar antes de reintentar con backoff exponencial\n        const waitTime = 1000 * Math.pow(2, attempt - 1);\n        console.log(`Waiting ${waitTime}ms before retrying document upload...`);\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n      }\n    }\n\n    // Si llegamos aquí, todos los intentos fallaron\n    // Intentar eliminar el registro de documento ya que no pudimos subir el archivo\n    try {\n      await supabaseClient\n        .from(DOCUMENTS_TABLE)\n        .delete()\n        .eq('id', documentId);\n      console.log(`Deleted document record ${documentId} after failed file upload`);\n    } catch (deleteError) {\n      console.warn(`Warning: Could not delete document record ${documentId} after failed upload:`, deleteError);\n    }\n\n    // Lanzar el último error que ocurrió\n    throw lastError || new Error('Error desconocido al subir el documento');\n  } catch (error) {\n    const documentError = {\n      message: error instanceof Error ? error.message : 'Error desconocido al subir el documento',\n      details: error\n    };\n    console.error('Document upload error:', documentError);\n    throw error;\n  }\n}\n\n// Delete a document\nexport const deleteDocument = async (documentId: string) => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n    \n    // Get document to get file path\n    const { data: document, error: fetchError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .select('file_path')\n      .eq('id', documentId)\n      .single();\n\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const { error: storageError } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .remove([document.file_path]);\n\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error \n        ? storageError.message \n        : (typeof storageError === 'object' && storageError !== null && 'message' in storageError)\n          ? String((storageError as {message: string}).message)\n          : 'Error desconocido';\n      \n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const { error: deleteError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .delete()\n      .eq('id', documentId);\n\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async (filePath: string) => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    \n    const { data, error } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId: string, userId: string, isVerified: boolean = true) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .update({\n      is_verified: isVerified,\n      verified_by: userId,\n      verified_at: new Date().toISOString()\n    })\n    .eq('id', documentId)\n    .select();\n\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n\n  return data[0] as Document;\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async (applicationType: string) => {\n  const { data, error } = await supabase\n    .from('required_documents')\n    .select('*')\n    .eq('application_type', applicationType);\n\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n\n  return data;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}