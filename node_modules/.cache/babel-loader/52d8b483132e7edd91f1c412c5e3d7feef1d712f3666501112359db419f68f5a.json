{"ast":null,"code":"import { supabase, getServiceClient } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { checkTableExists } from '../utils/dbStructureCheck';\nimport { ErrorType, createAppError, logError } from '../utils/errorHandling';\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async client => {\n  const supabaseClient = client || supabase;\n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const {\n      error\n    } = await supabaseClient.storage.from(STORAGE_BUCKET).list();\n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || errorMessage.includes('does not exist') || errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async applicationId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('application_id', applicationId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async clientId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('client_id', clientId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async id => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('id', id).single();\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Upload a document\nexport const uploadDocument = async ({\n  application_id,\n  client_id,\n  file,\n  category,\n  userId\n}) => {\n  const supabaseClient = getServiceClient();\n  try {\n    var _uploadError, _uploadError2;\n    // Verificar si la tabla existe antes de intentar operaciones\n    const tableExists = await checkTableExists(DOCUMENTS_TABLE);\n    if (!tableExists) {\n      logError(`La tabla ${DOCUMENTS_TABLE} no existe. Por favor, ejecute el script de creación de tablas.`, 'documentService.uploadDocument', {\n        table: DOCUMENTS_TABLE\n      });\n      throw createAppError(ErrorType.DATABASE, `Error de configuración: La tabla de documentos no está correctamente configurada.`, {\n        table: DOCUMENTS_TABLE\n      });\n    }\n\n    // Verificar si el bucket de storage existe\n    const {\n      data: buckets\n    } = await supabaseClient.storage.listBuckets();\n    const bucketExists = buckets === null || buckets === void 0 ? void 0 : buckets.some(bucket => bucket.name === STORAGE_BUCKET);\n    if (!bucketExists) {\n      logError(`El bucket ${STORAGE_BUCKET} no existe.`, 'documentService.uploadDocument', {\n        bucket: STORAGE_BUCKET\n      });\n      throw createAppError(ErrorType.UPLOAD, `Error de configuración: El almacenamiento de documentos no está correctamente configurado.`, {\n        bucket: STORAGE_BUCKET\n      });\n    }\n\n    // Generar información del archivo\n    const fileName = file.name;\n    const fileType = file.type;\n    const fileSize = file.size;\n\n    // Crear registro del documento\n    const {\n      data,\n      error\n    } = await supabaseClient.from(DOCUMENTS_TABLE).insert({\n      file_name: fileName,\n      file_type: fileType,\n      file_size: fileSize,\n      category,\n      application_id,\n      client_id,\n      uploaded_by_user_id: userId,\n      is_verified: false\n    }).select('*').single();\n    if (error) {\n      // Verificar si es un error de RLS\n      if (error.message && error.message.includes('policy')) {\n        logError(`Violación de política RLS al crear documento: ${error.message}`, 'documentService.uploadDocument', {\n          error\n        });\n        throw createAppError(ErrorType.AUTHORIZATION, 'No tienes permisos para crear documentos para este cliente o aplicación', {\n          error: error.message\n        });\n      }\n      logError(`Error al crear documento: ${error.message}`, 'documentService.uploadDocument', {\n        error\n      });\n      throw createAppError(ErrorType.DATABASE, 'Error al crear documento en la base de datos', {\n        error: error.message\n      });\n    }\n    if (!data) {\n      logError('No se retornaron datos al crear documento', 'documentService.uploadDocument');\n      throw createAppError(ErrorType.DATABASE, 'Error al crear documento en la base de datos');\n    }\n    const documentId = data.id;\n\n    // Construir nombre único para el archivo\n    const fileExtension = fileName.split('.').pop();\n    const uniqueFileName = `${documentId}.${fileExtension}`;\n    const filePath = `${client_id || application_id}/${uniqueFileName}`;\n\n    // Intentar subir el archivo con reintentos\n    let uploadError = null;\n    const maxRetries = 3;\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        // Subir el archivo al storage\n        const {\n          error: uploadError\n        } = await supabaseClient.storage.from(STORAGE_BUCKET).upload(filePath, file, {\n          upsert: true,\n          cacheControl: '3600'\n        });\n        if (uploadError) {\n          throw uploadError;\n        }\n\n        // Obtener URL pública del archivo\n        const {\n          data: publicUrlData\n        } = supabaseClient.storage.from(STORAGE_BUCKET).getPublicUrl(filePath);\n\n        // Actualizar el documento con la ruta del archivo\n        const {\n          error: updateError\n        } = await supabaseClient.from(DOCUMENTS_TABLE).update({\n          file_path: filePath\n        }).eq('id', documentId);\n        if (updateError) {\n          logError(`Error al actualizar ruta del documento: ${updateError.message}`, 'documentService.uploadDocument', {\n            error: updateError\n          });\n        }\n\n        // Construir y devolver el documento\n        const documentResult = {\n          id: documentId,\n          application_id: application_id || undefined,\n          client_id: client_id || undefined,\n          file_name: fileName,\n          file_path: filePath,\n          file_type: fileType,\n          file_size: fileSize,\n          category,\n          uploaded_by_user_id: userId,\n          is_verified: false,\n          created_at: data.created_at\n        };\n        return documentResult;\n      } catch (error) {\n        uploadError = error;\n\n        // Esperar con backoff exponencial antes de reintentar\n        if (attempt < maxRetries - 1) {\n          const waitTime = Math.pow(2, attempt) * 1000;\n          console.log(`Reintentando subir documento en ${waitTime}ms...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n\n    // Si llegamos aquí, todos los intentos fallaron\n    logError(`Error al subir documento después de ${maxRetries} intentos: ${((_uploadError = uploadError) === null || _uploadError === void 0 ? void 0 : _uploadError.message) || 'Error desconocido'}`, 'documentService.uploadDocument', {\n      error: uploadError,\n      attempts: maxRetries\n    });\n\n    // Intentar eliminar el documento creado\n    try {\n      await supabaseClient.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    } catch (deleteError) {\n      console.warn(`No se pudo eliminar el documento huérfano: ${deleteError}`);\n    }\n    throw createAppError(ErrorType.UPLOAD, 'Error al subir el archivo al sistema', {\n      error: (_uploadError2 = uploadError) === null || _uploadError2 === void 0 ? void 0 : _uploadError2.message\n    });\n  } catch (error) {\n    // Si el error ya es un AppError, rethrow\n    if (error && error.isAppError) {\n      throw error;\n    }\n    logError(`Error inesperado en uploadDocument: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`, 'documentService.uploadDocument', {\n      error\n    });\n    throw createAppError(ErrorType.UNKNOWN, 'Error inesperado al subir documento', {\n      error: error === null || error === void 0 ? void 0 : error.message\n    });\n  }\n};\n\n// Delete a document\nexport const deleteDocument = async documentId => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n\n    // Get document to get file path\n    const {\n      data: document,\n      error: fetchError\n    } = await supabase.from(DOCUMENTS_TABLE).select('file_path').eq('id', documentId).single();\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const {\n      error: storageError\n    } = await supabase.storage.from(STORAGE_BUCKET).remove([document.file_path]);\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error ? storageError.message : typeof storageError === 'object' && storageError !== null && 'message' in storageError ? String(storageError.message) : 'Error desconocido';\n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const {\n      error: deleteError\n    } = await supabase.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async filePath => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    const {\n      data,\n      error\n    } = await supabase.storage.from(STORAGE_BUCKET).createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId, userId, isVerified = true) => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).update({\n    is_verified: isVerified,\n    verified_by: userId,\n    verified_at: new Date().toISOString()\n  }).eq('id', documentId).select();\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n  return data[0];\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async applicationType => {\n  const {\n    data,\n    error\n  } = await supabase.from('required_documents').select('*').eq('application_type', applicationType);\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n  return data;\n};","map":{"version":3,"names":["supabase","getServiceClient","TABLES","checkTableExists","ErrorType","createAppError","logError","DOCUMENTS_TABLE","DOCUMENTS","STORAGE_BUCKET","ensureStorageBucketExists","client","supabaseClient","error","storage","from","list","errorMessage","message","includes","console","log","Error","getApplicationDocuments","applicationId","data","select","eq","order","ascending","getClientDocuments","clientId","getDocumentById","id","single","uploadDocument","application_id","client_id","file","category","userId","_uploadError","_uploadError2","tableExists","table","DATABASE","buckets","listBuckets","bucketExists","some","bucket","name","UPLOAD","fileName","fileType","type","fileSize","size","insert","file_name","file_type","file_size","uploaded_by_user_id","is_verified","AUTHORIZATION","documentId","fileExtension","split","pop","uniqueFileName","filePath","uploadError","maxRetries","attempt","upload","upsert","cacheControl","publicUrlData","getPublicUrl","updateError","update","file_path","documentResult","undefined","created_at","waitTime","Math","pow","Promise","resolve","setTimeout","attempts","delete","deleteError","warn","isAppError","UNKNOWN","deleteDocument","document","fetchError","storageError","remove","String","getDocumentUrl","createSignedUrl","signedUrl","verifyDocument","isVerified","verified_by","verified_at","Date","toISOString","getRequiredDocuments","applicationType"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/documentService.ts"],"sourcesContent":["import { supabase, getServiceClient } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { checkTableExists } from '../utils/dbStructureCheck';\nimport { \n  ErrorType, \n  createAppError, \n  logError \n} from '../utils/errorHandling';\n\nexport interface Document {\n  id: string;\n  created_at: string;\n  file_name: string;\n  file_path: string;\n  file_type: string;\n  file_size: number;\n  category?: string;\n  application_id?: string;\n  client_id?: string;\n  uploaded_by_user_id?: string;\n  is_verified?: boolean;\n  verified_by?: string;\n  verified_at?: string;\n}\n\nexport interface DocumentUpload {\n  file: File;\n  application_id?: string;\n  client_id?: string;\n  userId: string;\n  documentName: string;\n  description?: string;\n  category?: string;\n  authClient?: SupabaseClient;\n}\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\nexport type UploadDocumentParams = DocumentUpload;\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async (client?: SupabaseClient) => {\n  const supabaseClient = client || supabase;\n  \n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const { error } = await supabaseClient.storage\n      .from(STORAGE_BUCKET)\n      .list();\n    \n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || \n          errorMessage.includes('does not exist') || \n          errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    \n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async (applicationId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('application_id', applicationId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async (clientId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('client_id', clientId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async (id: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n\n  return data as Document;\n};\n\n// Upload a document\nexport const uploadDocument = async ({\n  application_id,\n  client_id,\n  file,\n  category,\n  userId\n}: DocumentUpload): Promise<Document> => {\n  const supabaseClient = getServiceClient();\n  \n  try {\n    // Verificar si la tabla existe antes de intentar operaciones\n    const tableExists = await checkTableExists(DOCUMENTS_TABLE);\n    if (!tableExists) {\n      logError(\n        `La tabla ${DOCUMENTS_TABLE} no existe. Por favor, ejecute el script de creación de tablas.`,\n        'documentService.uploadDocument',\n        { table: DOCUMENTS_TABLE }\n      );\n      throw createAppError(\n        ErrorType.DATABASE,\n        `Error de configuración: La tabla de documentos no está correctamente configurada.`,\n        { table: DOCUMENTS_TABLE }\n      );\n    }\n    \n    // Verificar si el bucket de storage existe\n    const { data: buckets } = await supabaseClient.storage.listBuckets();\n    const bucketExists = buckets?.some((bucket: any) => bucket.name === STORAGE_BUCKET);\n    \n    if (!bucketExists) {\n      logError(\n        `El bucket ${STORAGE_BUCKET} no existe.`,\n        'documentService.uploadDocument',\n        { bucket: STORAGE_BUCKET }\n      );\n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error de configuración: El almacenamiento de documentos no está correctamente configurado.`,\n        { bucket: STORAGE_BUCKET }\n      );\n    }\n    \n    // Generar información del archivo\n    const fileName = file.name;\n    const fileType = file.type;\n    const fileSize = file.size;\n    \n    // Crear registro del documento\n    const { data, error } = await supabaseClient\n      .from(DOCUMENTS_TABLE)\n      .insert({\n        file_name: fileName,\n        file_type: fileType,\n        file_size: fileSize,\n        category,\n        application_id,\n        client_id,\n        uploaded_by_user_id: userId,\n        is_verified: false\n      })\n      .select('*')\n      .single();\n      \n    if (error) {\n      // Verificar si es un error de RLS\n      if (error.message && error.message.includes('policy')) {\n        logError(\n          `Violación de política RLS al crear documento: ${error.message}`,\n          'documentService.uploadDocument',\n          { error }\n        );\n        throw createAppError(\n          ErrorType.AUTHORIZATION,\n          'No tienes permisos para crear documentos para este cliente o aplicación',\n          { error: error.message }\n        );\n      }\n      \n      logError(\n        `Error al crear documento: ${error.message}`,\n        'documentService.uploadDocument',\n        { error }\n      );\n      throw createAppError(\n        ErrorType.DATABASE,\n        'Error al crear documento en la base de datos',\n        { error: error.message }\n      );\n    }\n    \n    if (!data) {\n      logError(\n        'No se retornaron datos al crear documento',\n        'documentService.uploadDocument'\n      );\n      throw createAppError(\n        ErrorType.DATABASE,\n        'Error al crear documento en la base de datos'\n      );\n    }\n    \n    const documentId = data.id;\n    \n    // Construir nombre único para el archivo\n    const fileExtension = fileName.split('.').pop();\n    const uniqueFileName = `${documentId}.${fileExtension}`;\n    const filePath = `${client_id || application_id}/${uniqueFileName}`;\n    \n    // Intentar subir el archivo con reintentos\n    let uploadError: any = null;\n    const maxRetries = 3;\n    \n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        // Subir el archivo al storage\n        const { error: uploadError } = await supabaseClient.storage\n          .from(STORAGE_BUCKET)\n          .upload(filePath, file, {\n            upsert: true,\n            cacheControl: '3600'\n          });\n          \n        if (uploadError) {\n          throw uploadError;\n        }\n        \n        // Obtener URL pública del archivo\n        const { data: publicUrlData } = supabaseClient.storage\n          .from(STORAGE_BUCKET)\n          .getPublicUrl(filePath);\n          \n        // Actualizar el documento con la ruta del archivo\n        const { error: updateError } = await supabaseClient\n          .from(DOCUMENTS_TABLE)\n          .update({\n            file_path: filePath\n          })\n          .eq('id', documentId);\n          \n        if (updateError) {\n          logError(\n            `Error al actualizar ruta del documento: ${updateError.message}`,\n            'documentService.uploadDocument',\n            { error: updateError }\n          );\n        }\n        \n        // Construir y devolver el documento\n        const documentResult: Document = {\n          id: documentId,\n          application_id: application_id || undefined,\n          client_id: client_id || undefined,\n          file_name: fileName,\n          file_path: filePath,\n          file_type: fileType,\n          file_size: fileSize,\n          category,\n          uploaded_by_user_id: userId,\n          is_verified: false,\n          created_at: data.created_at\n        };\n        \n        return documentResult;\n      } catch (error) {\n        uploadError = error;\n        \n        // Esperar con backoff exponencial antes de reintentar\n        if (attempt < maxRetries - 1) {\n          const waitTime = Math.pow(2, attempt) * 1000;\n          console.log(`Reintentando subir documento en ${waitTime}ms...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n    \n    // Si llegamos aquí, todos los intentos fallaron\n    logError(\n      `Error al subir documento después de ${maxRetries} intentos: ${uploadError?.message || 'Error desconocido'}`,\n      'documentService.uploadDocument',\n      { error: uploadError, attempts: maxRetries }\n    );\n    \n    // Intentar eliminar el documento creado\n    try {\n      await supabaseClient\n        .from(DOCUMENTS_TABLE)\n        .delete()\n        .eq('id', documentId);\n    } catch (deleteError) {\n      console.warn(`No se pudo eliminar el documento huérfano: ${deleteError}`);\n    }\n    \n    throw createAppError(\n      ErrorType.UPLOAD,\n      'Error al subir el archivo al sistema',\n      { error: uploadError?.message }\n    );\n  } catch (error) {\n    // Si el error ya es un AppError, rethrow\n    if (error && (error as any).isAppError) {\n      throw error;\n    }\n    \n    logError(\n      `Error inesperado en uploadDocument: ${(error as any)?.message || 'Error desconocido'}`,\n      'documentService.uploadDocument',\n      { error }\n    );\n    \n    throw createAppError(\n      ErrorType.UNKNOWN,\n      'Error inesperado al subir documento',\n      { error: (error as any)?.message }\n    );\n  }\n};\n\n// Delete a document\nexport const deleteDocument = async (documentId: string) => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n    \n    // Get document to get file path\n    const { data: document, error: fetchError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .select('file_path')\n      .eq('id', documentId)\n      .single();\n\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const { error: storageError } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .remove([document.file_path]);\n\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error \n        ? storageError.message \n        : (typeof storageError === 'object' && storageError !== null && 'message' in storageError)\n          ? String((storageError as {message: string}).message)\n          : 'Error desconocido';\n      \n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const { error: deleteError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .delete()\n      .eq('id', documentId);\n\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async (filePath: string) => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    \n    const { data, error } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId: string, userId: string, isVerified: boolean = true) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .update({\n      is_verified: isVerified,\n      verified_by: userId,\n      verified_at: new Date().toISOString()\n    })\n    .eq('id', documentId)\n    .select();\n\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n\n  return data[0] as Document;\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async (applicationType: string) => {\n  const { data, error } = await supabase\n    .from('required_documents')\n    .select('*')\n    .eq('application_type', applicationType);\n\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n\n  return data;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}