{"ast":null,"code":"import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { checkTableExists } from '../utils/createTables';\nimport { logError, createAppError } from '../utils/errorUtils';\nimport { ErrorType } from '../utils/constants/errorTypes';\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async client => {\n  const supabaseClient = client || supabase;\n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const {\n      error\n    } = await supabaseClient.storage.from(STORAGE_BUCKET).list();\n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || errorMessage.includes('does not exist') || errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async applicationId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('application_id', applicationId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async clientId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('client_id', clientId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async id => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('id', id).single();\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Upload a document\nexport const uploadDocument = async ({\n  applicationId,\n  clientId,\n  file,\n  category,\n  userId\n}) => {\n  const supabase = getServiceClient();\n  try {\n    var _uploadError;\n    // Verificar si la tabla existe antes de intentar operaciones\n    const tableExists = await checkTableExists(DOCUMENTS_TABLE);\n    if (!tableExists) {\n      logError({\n        message: `La tabla ${DOCUMENTS_TABLE} no existe. Por favor, ejecute el script de creación de tablas.`,\n        type: ErrorType.DATABASE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: `Error de configuración: La tabla de documentos no está correctamente configurada.`,\n        type: ErrorType.DATABASE_ERROR\n      });\n    }\n\n    // Verificar si el bucket de storage existe\n    const {\n      data: buckets\n    } = await supabase.storage.listBuckets();\n    const bucketExists = buckets === null || buckets === void 0 ? void 0 : buckets.some(bucket => bucket.name === STORAGE_BUCKET);\n    if (!bucketExists) {\n      logError({\n        message: `El bucket ${STORAGE_BUCKET} no existe.`,\n        type: ErrorType.STORAGE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: `Error de configuración: El almacenamiento de documentos no está correctamente configurado.`,\n        type: ErrorType.STORAGE_ERROR\n      });\n    }\n\n    // Generar información del archivo\n    const fileName = file.name;\n    const fileType = file.type;\n    const fileSize = file.size;\n\n    // Crear registro del documento\n    const {\n      data,\n      error\n    } = await supabase.from(DOCUMENTS_TABLE).insert({\n      file_name: fileName,\n      file_type: fileType,\n      file_size: fileSize,\n      category,\n      application_id: applicationId,\n      client_id: clientId,\n      uploaded_by_user_id: userId,\n      is_verified: false\n    }).select('*').single();\n    if (error) {\n      // Verificar si es un error de RLS\n      if (error.message && error.message.includes('policy')) {\n        logError({\n          message: `Violación de política RLS al crear documento: ${error.message}`,\n          type: ErrorType.PERMISSION_ERROR,\n          module: 'documentService',\n          function: 'uploadDocument'\n        });\n        throw createAppError({\n          message: 'No tienes permisos para crear documentos para este cliente o aplicación',\n          type: ErrorType.PERMISSION_ERROR\n        });\n      }\n      logError({\n        message: `Error al crear documento: ${error.message}`,\n        type: ErrorType.DATABASE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: 'Error al crear documento en la base de datos',\n        type: ErrorType.DATABASE_ERROR\n      });\n    }\n    if (!data) {\n      logError({\n        message: 'No se retornaron datos al crear documento',\n        type: ErrorType.DATABASE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: 'Error al crear documento en la base de datos',\n        type: ErrorType.DATABASE_ERROR\n      });\n    }\n    const documentId = data.id;\n\n    // Construir nombre único para el archivo\n    const fileExtension = fileName.split('.').pop();\n    const uniqueFileName = `${documentId}.${fileExtension}`;\n    const filePath = `${clientId || applicationId}/${uniqueFileName}`;\n\n    // Intentar subir el archivo con reintentos\n    let uploadError = null;\n    const maxRetries = 3;\n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        // Subir el archivo al storage\n        const {\n          error: uploadError\n        } = await supabase.storage.from(STORAGE_BUCKET).upload(filePath, file, {\n          upsert: true,\n          cacheControl: '3600'\n        });\n        if (uploadError) {\n          throw uploadError;\n        }\n\n        // Obtener URL pública del archivo\n        const {\n          data: publicUrlData\n        } = supabase.storage.from(STORAGE_BUCKET).getPublicUrl(filePath);\n\n        // Actualizar el documento con la ruta del archivo\n        const {\n          error: updateError\n        } = await supabase.from(DOCUMENTS_TABLE).update({\n          file_path: filePath\n        }).eq('id', documentId);\n        if (updateError) {\n          logError({\n            message: `Error al actualizar ruta del documento: ${updateError.message}`,\n            type: ErrorType.DATABASE_ERROR,\n            module: 'documentService',\n            function: 'uploadDocument'\n          });\n        }\n\n        // Construir y devolver el documento\n        return {\n          id: documentId,\n          applicationId: applicationId || null,\n          clientId: clientId || null,\n          fileName,\n          filePath,\n          fileType,\n          fileSize,\n          category,\n          uploadedByUserId: userId,\n          isVerified: false,\n          createdAt: data.created_at,\n          publicUrl: publicUrlData.publicUrl\n        };\n      } catch (error) {\n        uploadError = error;\n\n        // Esperar con backoff exponencial antes de reintentar\n        if (attempt < maxRetries - 1) {\n          const waitTime = Math.pow(2, attempt) * 1000;\n          console.log(`Reintentando subir documento en ${waitTime}ms...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n\n    // Si llegamos aquí, todos los intentos fallaron\n    logError({\n      message: `Error al subir documento después de ${maxRetries} intentos: ${((_uploadError = uploadError) === null || _uploadError === void 0 ? void 0 : _uploadError.message) || 'Error desconocido'}`,\n      type: ErrorType.STORAGE_ERROR,\n      module: 'documentService',\n      function: 'uploadDocument'\n    });\n\n    // Intentar eliminar el documento creado\n    try {\n      await supabase.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    } catch (deleteError) {\n      console.warn(`No se pudo eliminar el documento huérfano: ${deleteError}`);\n    }\n    throw createAppError({\n      message: 'Error al subir el archivo al sistema',\n      type: ErrorType.STORAGE_ERROR\n    });\n  } catch (error) {\n    // Si el error ya es un AppError, rethrow\n    if (error && error.isAppError) {\n      throw error;\n    }\n    logError({\n      message: `Error inesperado en uploadDocument: ${(error === null || error === void 0 ? void 0 : error.message) || 'Error desconocido'}`,\n      type: ErrorType.UNEXPECTED_ERROR,\n      module: 'documentService',\n      function: 'uploadDocument',\n      error\n    });\n    throw createAppError({\n      message: 'Error inesperado al subir documento',\n      type: ErrorType.UNEXPECTED_ERROR\n    });\n  }\n};\n\n// Delete a document\nexport const deleteDocument = async documentId => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n\n    // Get document to get file path\n    const {\n      data: document,\n      error: fetchError\n    } = await supabase.from(DOCUMENTS_TABLE).select('file_path').eq('id', documentId).single();\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const {\n      error: storageError\n    } = await supabase.storage.from(STORAGE_BUCKET).remove([document.file_path]);\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error ? storageError.message : typeof storageError === 'object' && storageError !== null && 'message' in storageError ? String(storageError.message) : 'Error desconocido';\n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const {\n      error: deleteError\n    } = await supabase.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async filePath => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    const {\n      data,\n      error\n    } = await supabase.storage.from(STORAGE_BUCKET).createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId, userId, isVerified = true) => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).update({\n    is_verified: isVerified,\n    verified_by: userId,\n    verified_at: new Date().toISOString()\n  }).eq('id', documentId).select();\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n  return data[0];\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async applicationType => {\n  const {\n    data,\n    error\n  } = await supabase.from('required_documents').select('*').eq('application_type', applicationType);\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n  return data;\n};","map":{"version":3,"names":["supabase","TABLES","checkTableExists","logError","createAppError","ErrorType","DOCUMENTS_TABLE","DOCUMENTS","STORAGE_BUCKET","ensureStorageBucketExists","client","supabaseClient","error","storage","from","list","errorMessage","message","includes","console","log","Error","getApplicationDocuments","applicationId","data","select","eq","order","ascending","getClientDocuments","clientId","getDocumentById","id","single","uploadDocument","file","category","userId","getServiceClient","_uploadError","tableExists","type","DATABASE_ERROR","module","function","buckets","listBuckets","bucketExists","some","bucket","name","STORAGE_ERROR","fileName","fileType","fileSize","size","insert","file_name","file_type","file_size","application_id","client_id","uploaded_by_user_id","is_verified","PERMISSION_ERROR","documentId","fileExtension","split","pop","uniqueFileName","filePath","uploadError","maxRetries","attempt","upload","upsert","cacheControl","publicUrlData","getPublicUrl","updateError","update","file_path","uploadedByUserId","isVerified","createdAt","created_at","publicUrl","waitTime","Math","pow","Promise","resolve","setTimeout","delete","deleteError","warn","isAppError","UNEXPECTED_ERROR","deleteDocument","document","fetchError","storageError","remove","String","getDocumentUrl","createSignedUrl","signedUrl","verifyDocument","verified_by","verified_at","Date","toISOString","getRequiredDocuments","applicationType"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/documentService.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { checkTableExists } from '../utils/createTables';\nimport { logError, createAppError } from '../utils/errorUtils';\nimport { ErrorType } from '../utils/constants/errorTypes';\n\nexport interface Document {\n  id: string;\n  created_at: string;\n  file_name: string;\n  file_path: string;\n  file_type: string;\n  file_size: number;\n  category?: string;\n  application_id?: string;\n  client_id?: string;\n  uploaded_by_user_id?: string;\n  is_verified?: boolean;\n  verified_by?: string;\n  verified_at?: string;\n}\n\nexport interface DocumentUpload {\n  file: File;\n  application_id?: string;\n  client_id?: string;\n  userId: string;\n  documentName: string;\n  description?: string;\n  category?: string;\n  authClient?: SupabaseClient;\n}\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\nexport type UploadDocumentParams = DocumentUpload;\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async (client?: SupabaseClient) => {\n  const supabaseClient = client || supabase;\n  \n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const { error } = await supabaseClient.storage\n      .from(STORAGE_BUCKET)\n      .list();\n    \n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || \n          errorMessage.includes('does not exist') || \n          errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    \n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async (applicationId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('application_id', applicationId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async (clientId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('client_id', clientId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async (id: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n\n  return data as Document;\n};\n\n// Upload a document\nexport const uploadDocument = async ({\n  applicationId,\n  clientId,\n  file,\n  category,\n  userId\n}: DocumentUpload): Promise<Document> => {\n  const supabase = getServiceClient();\n  \n  try {\n    // Verificar si la tabla existe antes de intentar operaciones\n    const tableExists = await checkTableExists(DOCUMENTS_TABLE);\n    if (!tableExists) {\n      logError({\n        message: `La tabla ${DOCUMENTS_TABLE} no existe. Por favor, ejecute el script de creación de tablas.`,\n        type: ErrorType.DATABASE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: `Error de configuración: La tabla de documentos no está correctamente configurada.`,\n        type: ErrorType.DATABASE_ERROR\n      });\n    }\n    \n    // Verificar si el bucket de storage existe\n    const { data: buckets } = await supabase.storage.listBuckets();\n    const bucketExists = buckets?.some(bucket => bucket.name === STORAGE_BUCKET);\n    \n    if (!bucketExists) {\n      logError({\n        message: `El bucket ${STORAGE_BUCKET} no existe.`,\n        type: ErrorType.STORAGE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: `Error de configuración: El almacenamiento de documentos no está correctamente configurado.`,\n        type: ErrorType.STORAGE_ERROR\n      });\n    }\n    \n    // Generar información del archivo\n    const fileName = file.name;\n    const fileType = file.type;\n    const fileSize = file.size;\n    \n    // Crear registro del documento\n    const { data, error } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .insert({\n        file_name: fileName,\n        file_type: fileType,\n        file_size: fileSize,\n        category,\n        application_id: applicationId,\n        client_id: clientId,\n        uploaded_by_user_id: userId,\n        is_verified: false\n      })\n      .select('*')\n      .single();\n      \n    if (error) {\n      // Verificar si es un error de RLS\n      if (error.message && error.message.includes('policy')) {\n        logError({\n          message: `Violación de política RLS al crear documento: ${error.message}`,\n          type: ErrorType.PERMISSION_ERROR,\n          module: 'documentService',\n          function: 'uploadDocument'\n        });\n        throw createAppError({\n          message: 'No tienes permisos para crear documentos para este cliente o aplicación',\n          type: ErrorType.PERMISSION_ERROR\n        });\n      }\n      \n      logError({\n        message: `Error al crear documento: ${error.message}`,\n        type: ErrorType.DATABASE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: 'Error al crear documento en la base de datos',\n        type: ErrorType.DATABASE_ERROR\n      });\n    }\n    \n    if (!data) {\n      logError({\n        message: 'No se retornaron datos al crear documento',\n        type: ErrorType.DATABASE_ERROR,\n        module: 'documentService',\n        function: 'uploadDocument'\n      });\n      throw createAppError({\n        message: 'Error al crear documento en la base de datos',\n        type: ErrorType.DATABASE_ERROR\n      });\n    }\n    \n    const documentId = data.id;\n    \n    // Construir nombre único para el archivo\n    const fileExtension = fileName.split('.').pop();\n    const uniqueFileName = `${documentId}.${fileExtension}`;\n    const filePath = `${clientId || applicationId}/${uniqueFileName}`;\n    \n    // Intentar subir el archivo con reintentos\n    let uploadError: any = null;\n    const maxRetries = 3;\n    \n    for (let attempt = 0; attempt < maxRetries; attempt++) {\n      try {\n        // Subir el archivo al storage\n        const { error: uploadError } = await supabase.storage\n          .from(STORAGE_BUCKET)\n          .upload(filePath, file, {\n            upsert: true,\n            cacheControl: '3600'\n          });\n          \n        if (uploadError) {\n          throw uploadError;\n        }\n        \n        // Obtener URL pública del archivo\n        const { data: publicUrlData } = supabase.storage\n          .from(STORAGE_BUCKET)\n          .getPublicUrl(filePath);\n          \n        // Actualizar el documento con la ruta del archivo\n        const { error: updateError } = await supabase\n          .from(DOCUMENTS_TABLE)\n          .update({\n            file_path: filePath\n          })\n          .eq('id', documentId);\n          \n        if (updateError) {\n          logError({\n            message: `Error al actualizar ruta del documento: ${updateError.message}`,\n            type: ErrorType.DATABASE_ERROR,\n            module: 'documentService',\n            function: 'uploadDocument'\n          });\n        }\n        \n        // Construir y devolver el documento\n        return {\n          id: documentId,\n          applicationId: applicationId || null,\n          clientId: clientId || null,\n          fileName,\n          filePath,\n          fileType,\n          fileSize,\n          category,\n          uploadedByUserId: userId,\n          isVerified: false,\n          createdAt: data.created_at,\n          publicUrl: publicUrlData.publicUrl\n        };\n      } catch (error) {\n        uploadError = error;\n        \n        // Esperar con backoff exponencial antes de reintentar\n        if (attempt < maxRetries - 1) {\n          const waitTime = Math.pow(2, attempt) * 1000;\n          console.log(`Reintentando subir documento en ${waitTime}ms...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n    \n    // Si llegamos aquí, todos los intentos fallaron\n    logError({\n      message: `Error al subir documento después de ${maxRetries} intentos: ${uploadError?.message || 'Error desconocido'}`,\n      type: ErrorType.STORAGE_ERROR,\n      module: 'documentService',\n      function: 'uploadDocument'\n    });\n    \n    // Intentar eliminar el documento creado\n    try {\n      await supabase\n        .from(DOCUMENTS_TABLE)\n        .delete()\n        .eq('id', documentId);\n    } catch (deleteError) {\n      console.warn(`No se pudo eliminar el documento huérfano: ${deleteError}`);\n    }\n    \n    throw createAppError({\n      message: 'Error al subir el archivo al sistema',\n      type: ErrorType.STORAGE_ERROR\n    });\n  } catch (error) {\n    // Si el error ya es un AppError, rethrow\n    if (error && (error as any).isAppError) {\n      throw error;\n    }\n    \n    logError({\n      message: `Error inesperado en uploadDocument: ${(error as any)?.message || 'Error desconocido'}`,\n      type: ErrorType.UNEXPECTED_ERROR,\n      module: 'documentService',\n      function: 'uploadDocument',\n      error\n    });\n    \n    throw createAppError({\n      message: 'Error inesperado al subir documento',\n      type: ErrorType.UNEXPECTED_ERROR\n    });\n  }\n};\n\n// Delete a document\nexport const deleteDocument = async (documentId: string) => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n    \n    // Get document to get file path\n    const { data: document, error: fetchError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .select('file_path')\n      .eq('id', documentId)\n      .single();\n\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const { error: storageError } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .remove([document.file_path]);\n\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error \n        ? storageError.message \n        : (typeof storageError === 'object' && storageError !== null && 'message' in storageError)\n          ? String((storageError as {message: string}).message)\n          : 'Error desconocido';\n      \n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const { error: deleteError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .delete()\n      .eq('id', documentId);\n\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async (filePath: string) => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    \n    const { data, error } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId: string, userId: string, isVerified: boolean = true) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .update({\n      is_verified: isVerified,\n      verified_by: userId,\n      verified_at: new Date().toISOString()\n    })\n    .eq('id', documentId)\n    .select();\n\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n\n  return data[0] as Document;\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async (applicationType: string) => {\n  const { data, error } = await supabase\n    .from('required_documents')\n    .select('*')\n    .eq('application_type', applicationType);\n\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n\n  return data;\n}; "],"mappings":"AAAA,SAASA,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,MAAM,QAAQ,2BAA2B;AAElD,SAASC,gBAAgB,QAAQ,uBAAuB;AACxD,SAASC,QAAQ,EAAEC,cAAc,QAAQ,qBAAqB;AAC9D,SAASC,SAAS,QAAQ,+BAA+B;;AA6BzD;;AAGA,MAAMC,eAAe,GAAGL,MAAM,CAACM,SAAS;AACxC,MAAMC,cAAc,GAAG,WAAW;;AAElC;AACA,OAAO,MAAMC,yBAAyB,GAAG,MAAOC,MAAuB,IAAK;EAC1E,MAAMC,cAAc,GAAGD,MAAM,IAAIV,QAAQ;EAEzC,IAAI;IACF;IACA;IACA,MAAM;MAAEY;IAAM,CAAC,GAAG,MAAMD,cAAc,CAACE,OAAO,CAC3CC,IAAI,CAACN,cAAc,CAAC,CACpBO,IAAI,CAAC,CAAC;IAET,IAAIH,KAAK,EAAE;MACT;MACA;MACA,MAAMI,YAAY,GAAGJ,KAAK,CAACK,OAAO,IAAI,mBAAmB;MACzD,IAAID,YAAY,CAACE,QAAQ,CAAC,WAAW,CAAC,IAClCF,YAAY,CAACE,QAAQ,CAAC,gBAAgB,CAAC,IACvCF,YAAY,CAACE,QAAQ,CAAC,KAAK,CAAC,EAAE;QAChCC,OAAO,CAACC,GAAG,CAAC,mBAAmBZ,cAAc,kBAAkB,CAAC;QAChE,MAAM,IAAIa,KAAK,CAAC,gCAAgCb,cAAc,yCAAyC,CAAC;MAC1G,CAAC,MAAM;QACLW,OAAO,CAACP,KAAK,CAAC,mCAAmCJ,cAAc,IAAI,EAAEI,KAAK,CAAC;QAC3E,MAAM,IAAIS,KAAK,CAAC,iDAAiDL,YAAY,EAAE,CAAC;MAClF;IACF;IAEAG,OAAO,CAACC,GAAG,CAAC,mBAAmBZ,cAAc,4BAA4B,CAAC;IAC1E,OAAO,IAAI;EACb,CAAC,CAAC,OAAOI,KAAK,EAAE;IACdO,OAAO,CAACP,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;IAC3D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAMU,uBAAuB,GAAG,MAAOC,aAAqB,IAAK;EACtE,MAAM;IAAEC,IAAI;IAAEZ;EAAM,CAAC,GAAG,MAAMZ,QAAQ,CACnCc,IAAI,CAACR,eAAe,CAAC,CACrBmB,MAAM,CAAC,GAAG,CAAC,CACXC,EAAE,CAAC,gBAAgB,EAAEH,aAAa,CAAC,CACnCI,KAAK,CAAC,YAAY,EAAE;IAAEC,SAAS,EAAE;EAAM,CAAC,CAAC;EAE5C,IAAIhB,KAAK,EAAE;IACTO,OAAO,CAACP,KAAK,CAAC,4CAA4CW,aAAa,GAAG,EAAEX,KAAK,CAAC;IAClF,MAAMA,KAAK;EACb;EAEA,OAAOY,IAAI;AACb,CAAC;;AAED;AACA,OAAO,MAAMK,kBAAkB,GAAG,MAAOC,QAAgB,IAAK;EAC5D,MAAM;IAAEN,IAAI;IAAEZ;EAAM,CAAC,GAAG,MAAMZ,QAAQ,CACnCc,IAAI,CAACR,eAAe,CAAC,CACrBmB,MAAM,CAAC,GAAG,CAAC,CACXC,EAAE,CAAC,WAAW,EAAEI,QAAQ,CAAC,CACzBH,KAAK,CAAC,YAAY,EAAE;IAAEC,SAAS,EAAE;EAAM,CAAC,CAAC;EAE5C,IAAIhB,KAAK,EAAE;IACTO,OAAO,CAACP,KAAK,CAAC,uCAAuCkB,QAAQ,GAAG,EAAElB,KAAK,CAAC;IACxE,MAAMA,KAAK;EACb;EAEA,OAAOY,IAAI;AACb,CAAC;;AAED;AACA,OAAO,MAAMO,eAAe,GAAG,MAAOC,EAAU,IAAK;EACnD,MAAM;IAAER,IAAI;IAAEZ;EAAM,CAAC,GAAG,MAAMZ,QAAQ,CACnCc,IAAI,CAACR,eAAe,CAAC,CACrBmB,MAAM,CAAC,GAAG,CAAC,CACXC,EAAE,CAAC,IAAI,EAAEM,EAAE,CAAC,CACZC,MAAM,CAAC,CAAC;EAEX,IAAIrB,KAAK,EAAE;IACTO,OAAO,CAACP,KAAK,CAAC,mCAAmCoB,EAAE,GAAG,EAAEpB,KAAK,CAAC;IAC9D,MAAMA,KAAK;EACb;EAEA,OAAOY,IAAI;AACb,CAAC;;AAED;AACA,OAAO,MAAMU,cAAc,GAAG,MAAAA,CAAO;EACnCX,aAAa;EACbO,QAAQ;EACRK,IAAI;EACJC,QAAQ;EACRC;AACc,CAAC,KAAwB;EACvC,MAAMrC,QAAQ,GAAGsC,gBAAgB,CAAC,CAAC;EAEnC,IAAI;IAAA,IAAAC,YAAA;IACF;IACA,MAAMC,WAAW,GAAG,MAAMtC,gBAAgB,CAACI,eAAe,CAAC;IAC3D,IAAI,CAACkC,WAAW,EAAE;MAChBrC,QAAQ,CAAC;QACPc,OAAO,EAAE,YAAYX,eAAe,iEAAiE;QACrGmC,IAAI,EAAEpC,SAAS,CAACqC,cAAc;QAC9BC,MAAM,EAAE,iBAAiB;QACzBC,QAAQ,EAAE;MACZ,CAAC,CAAC;MACF,MAAMxC,cAAc,CAAC;QACnBa,OAAO,EAAE,mFAAmF;QAC5FwB,IAAI,EAAEpC,SAAS,CAACqC;MAClB,CAAC,CAAC;IACJ;;IAEA;IACA,MAAM;MAAElB,IAAI,EAAEqB;IAAQ,CAAC,GAAG,MAAM7C,QAAQ,CAACa,OAAO,CAACiC,WAAW,CAAC,CAAC;IAC9D,MAAMC,YAAY,GAAGF,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEG,IAAI,CAACC,MAAM,IAAIA,MAAM,CAACC,IAAI,KAAK1C,cAAc,CAAC;IAE5E,IAAI,CAACuC,YAAY,EAAE;MACjB5C,QAAQ,CAAC;QACPc,OAAO,EAAE,aAAaT,cAAc,aAAa;QACjDiC,IAAI,EAAEpC,SAAS,CAAC8C,aAAa;QAC7BR,MAAM,EAAE,iBAAiB;QACzBC,QAAQ,EAAE;MACZ,CAAC,CAAC;MACF,MAAMxC,cAAc,CAAC;QACnBa,OAAO,EAAE,4FAA4F;QACrGwB,IAAI,EAAEpC,SAAS,CAAC8C;MAClB,CAAC,CAAC;IACJ;;IAEA;IACA,MAAMC,QAAQ,GAAGjB,IAAI,CAACe,IAAI;IAC1B,MAAMG,QAAQ,GAAGlB,IAAI,CAACM,IAAI;IAC1B,MAAMa,QAAQ,GAAGnB,IAAI,CAACoB,IAAI;;IAE1B;IACA,MAAM;MAAE/B,IAAI;MAAEZ;IAAM,CAAC,GAAG,MAAMZ,QAAQ,CACnCc,IAAI,CAACR,eAAe,CAAC,CACrBkD,MAAM,CAAC;MACNC,SAAS,EAAEL,QAAQ;MACnBM,SAAS,EAAEL,QAAQ;MACnBM,SAAS,EAAEL,QAAQ;MACnBlB,QAAQ;MACRwB,cAAc,EAAErC,aAAa;MAC7BsC,SAAS,EAAE/B,QAAQ;MACnBgC,mBAAmB,EAAEzB,MAAM;MAC3B0B,WAAW,EAAE;IACf,CAAC,CAAC,CACDtC,MAAM,CAAC,GAAG,CAAC,CACXQ,MAAM,CAAC,CAAC;IAEX,IAAIrB,KAAK,EAAE;MACT;MACA,IAAIA,KAAK,CAACK,OAAO,IAAIL,KAAK,CAACK,OAAO,CAACC,QAAQ,CAAC,QAAQ,CAAC,EAAE;QACrDf,QAAQ,CAAC;UACPc,OAAO,EAAE,iDAAiDL,KAAK,CAACK,OAAO,EAAE;UACzEwB,IAAI,EAAEpC,SAAS,CAAC2D,gBAAgB;UAChCrB,MAAM,EAAE,iBAAiB;UACzBC,QAAQ,EAAE;QACZ,CAAC,CAAC;QACF,MAAMxC,cAAc,CAAC;UACnBa,OAAO,EAAE,yEAAyE;UAClFwB,IAAI,EAAEpC,SAAS,CAAC2D;QAClB,CAAC,CAAC;MACJ;MAEA7D,QAAQ,CAAC;QACPc,OAAO,EAAE,6BAA6BL,KAAK,CAACK,OAAO,EAAE;QACrDwB,IAAI,EAAEpC,SAAS,CAACqC,cAAc;QAC9BC,MAAM,EAAE,iBAAiB;QACzBC,QAAQ,EAAE;MACZ,CAAC,CAAC;MACF,MAAMxC,cAAc,CAAC;QACnBa,OAAO,EAAE,8CAA8C;QACvDwB,IAAI,EAAEpC,SAAS,CAACqC;MAClB,CAAC,CAAC;IACJ;IAEA,IAAI,CAAClB,IAAI,EAAE;MACTrB,QAAQ,CAAC;QACPc,OAAO,EAAE,2CAA2C;QACpDwB,IAAI,EAAEpC,SAAS,CAACqC,cAAc;QAC9BC,MAAM,EAAE,iBAAiB;QACzBC,QAAQ,EAAE;MACZ,CAAC,CAAC;MACF,MAAMxC,cAAc,CAAC;QACnBa,OAAO,EAAE,8CAA8C;QACvDwB,IAAI,EAAEpC,SAAS,CAACqC;MAClB,CAAC,CAAC;IACJ;IAEA,MAAMuB,UAAU,GAAGzC,IAAI,CAACQ,EAAE;;IAE1B;IACA,MAAMkC,aAAa,GAAGd,QAAQ,CAACe,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC;IAC/C,MAAMC,cAAc,GAAG,GAAGJ,UAAU,IAAIC,aAAa,EAAE;IACvD,MAAMI,QAAQ,GAAG,GAAGxC,QAAQ,IAAIP,aAAa,IAAI8C,cAAc,EAAE;;IAEjE;IACA,IAAIE,WAAgB,GAAG,IAAI;IAC3B,MAAMC,UAAU,GAAG,CAAC;IAEpB,KAAK,IAAIC,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAGD,UAAU,EAAEC,OAAO,EAAE,EAAE;MACrD,IAAI;QACF;QACA,MAAM;UAAE7D,KAAK,EAAE2D;QAAY,CAAC,GAAG,MAAMvE,QAAQ,CAACa,OAAO,CAClDC,IAAI,CAACN,cAAc,CAAC,CACpBkE,MAAM,CAACJ,QAAQ,EAAEnC,IAAI,EAAE;UACtBwC,MAAM,EAAE,IAAI;UACZC,YAAY,EAAE;QAChB,CAAC,CAAC;QAEJ,IAAIL,WAAW,EAAE;UACf,MAAMA,WAAW;QACnB;;QAEA;QACA,MAAM;UAAE/C,IAAI,EAAEqD;QAAc,CAAC,GAAG7E,QAAQ,CAACa,OAAO,CAC7CC,IAAI,CAACN,cAAc,CAAC,CACpBsE,YAAY,CAACR,QAAQ,CAAC;;QAEzB;QACA,MAAM;UAAE1D,KAAK,EAAEmE;QAAY,CAAC,GAAG,MAAM/E,QAAQ,CAC1Cc,IAAI,CAACR,eAAe,CAAC,CACrB0E,MAAM,CAAC;UACNC,SAAS,EAAEX;QACb,CAAC,CAAC,CACD5C,EAAE,CAAC,IAAI,EAAEuC,UAAU,CAAC;QAEvB,IAAIc,WAAW,EAAE;UACf5E,QAAQ,CAAC;YACPc,OAAO,EAAE,2CAA2C8D,WAAW,CAAC9D,OAAO,EAAE;YACzEwB,IAAI,EAAEpC,SAAS,CAACqC,cAAc;YAC9BC,MAAM,EAAE,iBAAiB;YACzBC,QAAQ,EAAE;UACZ,CAAC,CAAC;QACJ;;QAEA;QACA,OAAO;UACLZ,EAAE,EAAEiC,UAAU;UACd1C,aAAa,EAAEA,aAAa,IAAI,IAAI;UACpCO,QAAQ,EAAEA,QAAQ,IAAI,IAAI;UAC1BsB,QAAQ;UACRkB,QAAQ;UACRjB,QAAQ;UACRC,QAAQ;UACRlB,QAAQ;UACR8C,gBAAgB,EAAE7C,MAAM;UACxB8C,UAAU,EAAE,KAAK;UACjBC,SAAS,EAAE5D,IAAI,CAAC6D,UAAU;UAC1BC,SAAS,EAAET,aAAa,CAACS;QAC3B,CAAC;MACH,CAAC,CAAC,OAAO1E,KAAK,EAAE;QACd2D,WAAW,GAAG3D,KAAK;;QAEnB;QACA,IAAI6D,OAAO,GAAGD,UAAU,GAAG,CAAC,EAAE;UAC5B,MAAMe,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEhB,OAAO,CAAC,GAAG,IAAI;UAC5CtD,OAAO,CAACC,GAAG,CAAC,mCAAmCmE,QAAQ,OAAO,CAAC;UAC/D,MAAM,IAAIG,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEJ,QAAQ,CAAC,CAAC;QAC7D;MACF;IACF;;IAEA;IACApF,QAAQ,CAAC;MACPc,OAAO,EAAE,uCAAuCuD,UAAU,cAAc,EAAAjC,YAAA,GAAAgC,WAAW,cAAAhC,YAAA,uBAAXA,YAAA,CAAatB,OAAO,KAAI,mBAAmB,EAAE;MACrHwB,IAAI,EAAEpC,SAAS,CAAC8C,aAAa;MAC7BR,MAAM,EAAE,iBAAiB;MACzBC,QAAQ,EAAE;IACZ,CAAC,CAAC;;IAEF;IACA,IAAI;MACF,MAAM5C,QAAQ,CACXc,IAAI,CAACR,eAAe,CAAC,CACrBuF,MAAM,CAAC,CAAC,CACRnE,EAAE,CAAC,IAAI,EAAEuC,UAAU,CAAC;IACzB,CAAC,CAAC,OAAO6B,WAAW,EAAE;MACpB3E,OAAO,CAAC4E,IAAI,CAAC,8CAA8CD,WAAW,EAAE,CAAC;IAC3E;IAEA,MAAM1F,cAAc,CAAC;MACnBa,OAAO,EAAE,sCAAsC;MAC/CwB,IAAI,EAAEpC,SAAS,CAAC8C;IAClB,CAAC,CAAC;EACJ,CAAC,CAAC,OAAOvC,KAAK,EAAE;IACd;IACA,IAAIA,KAAK,IAAKA,KAAK,CAASoF,UAAU,EAAE;MACtC,MAAMpF,KAAK;IACb;IAEAT,QAAQ,CAAC;MACPc,OAAO,EAAE,uCAAuC,CAACL,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAUK,OAAO,KAAI,mBAAmB,EAAE;MAChGwB,IAAI,EAAEpC,SAAS,CAAC4F,gBAAgB;MAChCtD,MAAM,EAAE,iBAAiB;MACzBC,QAAQ,EAAE,gBAAgB;MAC1BhC;IACF,CAAC,CAAC;IAEF,MAAMR,cAAc,CAAC;MACnBa,OAAO,EAAE,qCAAqC;MAC9CwB,IAAI,EAAEpC,SAAS,CAAC4F;IAClB,CAAC,CAAC;EACJ;AACF,CAAC;;AAED;AACA,OAAO,MAAMC,cAAc,GAAG,MAAOjC,UAAkB,IAAK;EAC1D,IAAI;IACF;IACA,MAAMxD,yBAAyB,CAAC,CAAC;;IAEjC;IACA,MAAM;MAAEe,IAAI,EAAE2E,QAAQ;MAAEvF,KAAK,EAAEwF;IAAW,CAAC,GAAG,MAAMpG,QAAQ,CACzDc,IAAI,CAACR,eAAe,CAAC,CACrBmB,MAAM,CAAC,WAAW,CAAC,CACnBC,EAAE,CAAC,IAAI,EAAEuC,UAAU,CAAC,CACpBhC,MAAM,CAAC,CAAC;IAEX,IAAImE,UAAU,EAAE;MACdjF,OAAO,CAACP,KAAK,CAAC,2BAA2BqD,UAAU,gBAAgB,EAAEmC,UAAU,CAAC;MAChF,MAAMA,UAAU;IAClB;;IAEA;IACA,MAAM;MAAExF,KAAK,EAAEyF;IAAa,CAAC,GAAG,MAAMrG,QAAQ,CAACa,OAAO,CACnDC,IAAI,CAACN,cAAc,CAAC,CACpB8F,MAAM,CAAC,CAACH,QAAQ,CAAClB,SAAS,CAAC,CAAC;IAE/B,IAAIoB,YAAY,EAAE;MAChBlF,OAAO,CAACP,KAAK,CAAC,oCAAoCqD,UAAU,GAAG,EAAEoC,YAAY,CAAC;MAC9E;MACA,MAAMrF,YAAY,GAAGqF,YAAY,YAAYhF,KAAK,GAC9CgF,YAAY,CAACpF,OAAO,GACnB,OAAOoF,YAAY,KAAK,QAAQ,IAAIA,YAAY,KAAK,IAAI,IAAI,SAAS,IAAIA,YAAY,GACrFE,MAAM,CAAEF,YAAY,CAAuBpF,OAAO,CAAC,GACnD,mBAAmB;MAEzB,MAAM,IAAII,KAAK,CAAC,+CAA+CL,YAAY,EAAE,CAAC;IAChF;;IAEA;IACA,MAAM;MAAEJ,KAAK,EAAEkF;IAAY,CAAC,GAAG,MAAM9F,QAAQ,CAC1Cc,IAAI,CAACR,eAAe,CAAC,CACrBuF,MAAM,CAAC,CAAC,CACRnE,EAAE,CAAC,IAAI,EAAEuC,UAAU,CAAC;IAEvB,IAAI6B,WAAW,EAAE;MACf3E,OAAO,CAACP,KAAK,CAAC,kCAAkCqD,UAAU,GAAG,EAAE6B,WAAW,CAAC;MAC3E,MAAMA,WAAW;IACnB;IAEA,OAAO,IAAI;EACb,CAAC,CAAC,OAAOlF,KAAK,EAAE;IACdO,OAAO,CAACP,KAAK,CAAC,+BAA+BqD,UAAU,GAAG,EAAErD,KAAK,CAAC;IAClE,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAM4F,cAAc,GAAG,MAAOlC,QAAgB,IAAK;EACxD,IAAI;IACF;IACA,MAAM7D,yBAAyB,CAAC,CAAC;IAEjC,MAAM;MAAEe,IAAI;MAAEZ;IAAM,CAAC,GAAG,MAAMZ,QAAQ,CAACa,OAAO,CAC3CC,IAAI,CAACN,cAAc,CAAC,CACpBiG,eAAe,CAACnC,QAAQ,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;;IAEvC,IAAI1D,KAAK,EAAE;MACTO,OAAO,CAACP,KAAK,CAAC,kCAAkC0D,QAAQ,GAAG,EAAE1D,KAAK,CAAC;MACnE,MAAMA,KAAK;IACb;IAEA,OAAOY,IAAI,CAACkF,SAAS;EACvB,CAAC,CAAC,OAAO9F,KAAK,EAAE;IACdO,OAAO,CAACP,KAAK,CAAC,+BAA+B0D,QAAQ,GAAG,EAAE1D,KAAK,CAAC;IAChE,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAM+F,cAAc,GAAG,MAAAA,CAAO1C,UAAkB,EAAE5B,MAAc,EAAE8C,UAAmB,GAAG,IAAI,KAAK;EACtG,MAAM;IAAE3D,IAAI;IAAEZ;EAAM,CAAC,GAAG,MAAMZ,QAAQ,CACnCc,IAAI,CAACR,eAAe,CAAC,CACrB0E,MAAM,CAAC;IACNjB,WAAW,EAAEoB,UAAU;IACvByB,WAAW,EAAEvE,MAAM;IACnBwE,WAAW,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;EACtC,CAAC,CAAC,CACDrF,EAAE,CAAC,IAAI,EAAEuC,UAAU,CAAC,CACpBxC,MAAM,CAAC,CAAC;EAEX,IAAIb,KAAK,EAAE;IACTO,OAAO,CAACP,KAAK,CAAC,4BAA4BqD,UAAU,GAAG,EAAErD,KAAK,CAAC;IAC/D,MAAMA,KAAK;EACb;EAEA,OAAOY,IAAI,CAAC,CAAC,CAAC;AAChB,CAAC;;AAED;AACA,OAAO,MAAMwF,oBAAoB,GAAG,MAAOC,eAAuB,IAAK;EACrE,MAAM;IAAEzF,IAAI;IAAEZ;EAAM,CAAC,GAAG,MAAMZ,QAAQ,CACnCc,IAAI,CAAC,oBAAoB,CAAC,CAC1BW,MAAM,CAAC,GAAG,CAAC,CACXC,EAAE,CAAC,kBAAkB,EAAEuF,eAAe,CAAC;EAE1C,IAAIrG,KAAK,EAAE;IACTO,OAAO,CAACP,KAAK,CAAC,yCAAyCqG,eAAe,GAAG,EAAErG,KAAK,CAAC;IACjF,MAAMA,KAAK;EACb;EAEA,OAAOY,IAAI;AACb,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}