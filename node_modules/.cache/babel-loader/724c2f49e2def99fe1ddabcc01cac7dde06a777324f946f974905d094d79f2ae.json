{"ast":null,"code":"import{TABLES}from'../utils/constants/tables';import{executeQuery}from'../utils/databaseUtils';/**\n * Obtiene estadísticas generales para el dashboard\n */export const getGeneralDashboardStats=async()=>{try{var _totalAppResult$,_amountResult$,_amountResult$2,_amountResult$3,_categoryResult$,_categoryResult$2,_categoryResult$3,_categoryResult$4;// Total de aplicaciones\nconst totalApplicationsQuery=`SELECT COUNT(*) as total FROM ${TABLES.APPLICATIONS}`;const totalAppResult=await executeQuery(totalApplicationsQuery);const totalApplications=parseInt(((_totalAppResult$=totalAppResult[0])===null||_totalAppResult$===void 0?void 0:_totalAppResult$.total)||'0');// Aplicaciones por estado\nconst applicationsByStatusQuery=`\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      GROUP BY status\n    `;const statusResult=await executeQuery(applicationsByStatusQuery);const applicationsByStatus=statusResult.map(row=>({status:row.status,count:parseInt(row.count)}));// Estadísticas de montos\nconst amountStatsQuery=`\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n    `;const amountResult=await executeQuery(amountStatsQuery);const avgAmount=parseFloat(((_amountResult$=amountResult[0])===null||_amountResult$===void 0?void 0:_amountResult$.avg_amount)||'0');const minAmount=parseFloat(((_amountResult$2=amountResult[0])===null||_amountResult$2===void 0?void 0:_amountResult$2.min_amount)||'0');const maxAmount=parseFloat(((_amountResult$3=amountResult[0])===null||_amountResult$3===void 0?void 0:_amountResult$3.max_amount)||'0');// Aplicaciones recientes\nlet recentApplications=[];try{const recentApplicationsQuery=`\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;recentApplications=await executeQuery(recentApplicationsQuery);// Asegurarse de que application_type esté presente en todos los registros\nrecentApplications=recentApplications.map(app=>{if(!app.application_type){// Si no tiene application_type, intentar determinar por otros campos\nif(app.status&&app.status.toLowerCase().includes('simul')){app.application_type='product_simulations';}else if(app.status&&app.status.toLowerCase().includes('solicit')){app.application_type='selected_plans';}}return app;});}catch(error){console.error('Error al obtener aplicaciones recientes:',error);// Proporcionar datos de muestra si falla la consulta\nrecentApplications=[{id:'1',created_at:new Date().toISOString(),client_name:'Usuario de Muestra',status:'pending',amount:'10000',company_name:'Empresa Ejemplo',application_type:'selected_plans'},{id:'2',created_at:new Date().toISOString(),client_name:'Usuario de Muestra',status:'approved',amount:'15000',company_name:'Empresa Ejemplo',application_type:'product_simulations'}];}// Aplicaciones por mes (últimos 6 meses)\nconst applicationsByMonthQuery=`\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE created_at >= NOW() - INTERVAL '6 months'\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;const monthResult=await executeQuery(applicationsByMonthQuery);const applicationsByMonth=monthResult.map(row=>({month:row.month,count:parseInt(row.count)}));// Totales por categoría principal\nconst totalByMajorCategoryQuery=`\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'Aprobado por Asesor')) as approved,\n        COUNT(*) FILTER (WHERE status IN ('rejected', 'RECHAZADO')) as rejected,\n        COUNT(*) FILTER (WHERE status IN ('pending', 'new', 'Solicitud', 'Simulación')) as pending,\n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n    `;const categoryResult=await executeQuery(totalByMajorCategoryQuery);const totalApproved=parseInt(((_categoryResult$=categoryResult[0])===null||_categoryResult$===void 0?void 0:_categoryResult$.approved)||'0');const totalRejected=parseInt(((_categoryResult$2=categoryResult[0])===null||_categoryResult$2===void 0?void 0:_categoryResult$2.rejected)||'0');const totalPending=parseInt(((_categoryResult$3=categoryResult[0])===null||_categoryResult$3===void 0?void 0:_categoryResult$3.pending)||'0');const pendingApproval=parseInt(((_categoryResult$4=categoryResult[0])===null||_categoryResult$4===void 0?void 0:_categoryResult$4.pending_approval)||'0');// Total clients - use a try-catch block to handle the case where the table doesn't exist\nlet totalClients=0;try{var _totalClientsResult$;// First attempt: try to get clients count from clients table\nconst totalClientsQuery=`SELECT COUNT(*) as total FROM ${TABLES.CLIENTS}`;const totalClientsResult=await executeQuery(totalClientsQuery);totalClients=parseInt(((_totalClientsResult$=totalClientsResult[0])===null||_totalClientsResult$===void 0?void 0:_totalClientsResult$.total)||'0');}catch(error){// Fallback: if clients table doesn't exist, count distinct client names from applications\ntry{var _clientNamesResult$;const clientNamesQuery=`SELECT COUNT(DISTINCT client_name) as total FROM ${TABLES.APPLICATIONS}`;const clientNamesResult=await executeQuery(clientNamesQuery);totalClients=parseInt(((_clientNamesResult$=clientNamesResult[0])===null||_clientNamesResult$===void 0?void 0:_clientNamesResult$.total)||'0');}catch(innerError){console.error('Error counting clients from applications table:',innerError);// If that also fails, default to 0\ntotalClients=0;}}return{totalApplications,applicationsByStatus,avgAmount,minAmount,maxAmount,recentApplications,applicationsByMonth,totalApproved,totalRejected,totalPending,pendingApproval,totalClients};}catch(error){console.error('Error al obtener estadísticas del dashboard:',error);throw error;}};/**\n * Obtiene estadísticas específicas para un asesor\n * @param advisorId ID del asesor\n */export const getAdvisorDashboardStats=async advisorId=>{try{var _advisorAppResult$,_companiesResult$,_conversionResult$,_conversionResult$2,_timeResult$;// Obtenemos las estadísticas generales primero\nconst baseStats=await getGeneralDashboardStats();// Estadísticas específicas del asesor\n// Total de aplicaciones del asesor\nconst advisorApplicationsQuery=`\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;const advisorAppResult=await executeQuery(advisorApplicationsQuery);const totalAdvisorApplications=parseInt(((_advisorAppResult$=advisorAppResult[0])===null||_advisorAppResult$===void 0?void 0:_advisorAppResult$.total)||'0');// Aplicaciones por estado del asesor\nconst advisorStatusQuery=`\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      GROUP BY status\n    `;const advisorStatusResult=await executeQuery(advisorStatusQuery);const advisorApplicationsByStatus=advisorStatusResult.map(row=>({status:row.status,count:parseInt(row.count)}));// Total de clientes del asesor\nlet totalClients=0;try{var _clientsResult$;// First attempt: try to get clients from clients table\nconst clientsQuery=`\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE advisor_id = '${advisorId}'\n      `;const clientsResult=await executeQuery(clientsQuery);totalClients=parseInt(((_clientsResult$=clientsResult[0])===null||_clientsResult$===void 0?void 0:_clientsResult$.total)||'0');}catch(error){// Fallback: count distinct client names from applications\ntry{var _clientNamesResult$2;const clientNamesQuery=`\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE assigned_to = '${advisorId}'\n        `;const clientNamesResult=await executeQuery(clientNamesQuery);totalClients=parseInt(((_clientNamesResult$2=clientNamesResult[0])===null||_clientNamesResult$2===void 0?void 0:_clientNamesResult$2.total)||'0');}catch(innerError){console.error(`Error counting clients for advisor ${advisorId}:`,innerError);// If that also fails, default to 0\ntotalClients=0;}}// Total de empresas asignadas al asesor\nconst companiesQuery=`\n      SELECT COUNT(DISTINCT company_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;const companiesResult=await executeQuery(companiesQuery);const totalCompanies=parseInt(((_companiesResult$=companiesResult[0])===null||_companiesResult$===void 0?void 0:_companiesResult$.total)||'0');// Tasa de conversión (aprobados / total)\nconst conversionRateQuery=`\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'completed')) as approved,\n        COUNT(*) as total\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;const conversionResult=await executeQuery(conversionRateQuery);const approved=parseInt(((_conversionResult$=conversionResult[0])===null||_conversionResult$===void 0?void 0:_conversionResult$.approved)||'0');const total=parseInt(((_conversionResult$2=conversionResult[0])===null||_conversionResult$2===void 0?void 0:_conversionResult$2.total)||'0');const conversionRate=total>0?approved/total*100:0;// Tiempo promedio hasta aprobación\nconst avgTimeQuery=`\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_advisor - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      AND approval_date_advisor IS NOT NULL\n    `;const timeResult=await executeQuery(avgTimeQuery);const avgTimeToApproval=parseFloat(((_timeResult$=timeResult[0])===null||_timeResult$===void 0?void 0:_timeResult$.avg_days)||'0');// Aplicaciones recientes del asesor\nlet recentAdvisorApps=[];try{const recentAdvisorAppsQuery=`\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${advisorId}'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;recentAdvisorApps=await executeQuery(recentAdvisorAppsQuery);// Asegurarse de que application_type esté presente en todos los registros\nrecentAdvisorApps=recentAdvisorApps.map(app=>{if(!app.application_type){// Si no tiene application_type, intentar determinar por otros campos\nif(app.status&&app.status.toLowerCase().includes('simul')){app.application_type='product_simulations';}else if(app.status&&app.status.toLowerCase().includes('solicit')){app.application_type='selected_plans';}}return app;});}catch(error){console.error(`Error al obtener aplicaciones recientes del asesor ${advisorId}:`,error);// Datos de muestra en caso de error\nrecentAdvisorApps=[{id:'1',created_at:new Date().toISOString(),client_name:'Cliente de Asesor',status:'pending',amount:'12000',company_name:'Empresa Asignada',application_type:'selected_plans'}];}return{...baseStats,totalApplications:totalAdvisorApplications,applicationsByStatus:advisorApplicationsByStatus,recentApplications:recentAdvisorApps,totalClients,totalCompanies,conversionRate,avgTimeToApproval};}catch(error){console.error(`Error al obtener estadísticas del asesor ${advisorId}:`,error);throw error;}};/**\n * Obtiene estadísticas específicas para una empresa\n * @param companyId ID de la empresa\n */export const getCompanyDashboardStats=async companyId=>{try{var _companyAppResult$,_advisorsResult$,_timeResult$2;// Obtenemos las estadísticas generales primero\nconst baseStats=await getGeneralDashboardStats();// Estadísticas específicas de la empresa\n// Total de aplicaciones de la empresa\nconst companyApplicationsQuery=`\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;const companyAppResult=await executeQuery(companyApplicationsQuery);const totalCompanyApplications=parseInt(((_companyAppResult$=companyAppResult[0])===null||_companyAppResult$===void 0?void 0:_companyAppResult$.total)||'0');// Aplicaciones por estado de la empresa\nconst companyStatusQuery=`\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      GROUP BY status\n    `;const companyStatusResult=await executeQuery(companyStatusQuery);const companyApplicationsByStatus=companyStatusResult.map(row=>({status:row.status,count:parseInt(row.count)}));// Total de asesores asignados a la empresa\nconst advisorsQuery=`\n      SELECT COUNT(DISTINCT assigned_to) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;const advisorsResult=await executeQuery(advisorsQuery);const totalAdvisors=parseInt(((_advisorsResult$=advisorsResult[0])===null||_advisorsResult$===void 0?void 0:_advisorsResult$.total)||'0');// Total de clientes de la empresa\nlet totalClientsCompany=0;try{var _clientsResult$2;// First attempt: try to get clients from clients table\nconst clientsQuery=`\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE company_id = '${companyId}'\n      `;const clientsResult=await executeQuery(clientsQuery);totalClientsCompany=parseInt(((_clientsResult$2=clientsResult[0])===null||_clientsResult$2===void 0?void 0:_clientsResult$2.total)||'0');}catch(error){// Fallback: count distinct client names from applications\ntry{var _clientNamesResult$3;const clientNamesQuery=`\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE company_id = '${companyId}'\n        `;const clientNamesResult=await executeQuery(clientNamesQuery);totalClientsCompany=parseInt(((_clientNamesResult$3=clientNamesResult[0])===null||_clientNamesResult$3===void 0?void 0:_clientNamesResult$3.total)||'0');}catch(innerError){console.error(`Error counting clients for company ${companyId}:`,innerError);// If that also fails, default to 0\ntotalClientsCompany=0;}}// Tiempo promedio de aprobación\nconst avgTimeQuery=`\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_company - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      AND approval_date_company IS NOT NULL\n    `;const timeResult=await executeQuery(avgTimeQuery);const avgApprovalTime=parseFloat(((_timeResult$2=timeResult[0])===null||_timeResult$2===void 0?void 0:_timeResult$2.avg_days)||'0');// Aplicaciones recientes de la empresa\nlet recentCompanyApps=[];try{const recentCompanyAppsQuery=`\n        SELECT id, created_at, client_name, status, amount, assigned_to, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;recentCompanyApps=await executeQuery(recentCompanyAppsQuery);// Asegurarse de que application_type esté presente en todos los registros\nrecentCompanyApps=recentCompanyApps.map(app=>{if(!app.application_type){// Si no tiene application_type, intentar determinar por otros campos\nif(app.status&&app.status.toLowerCase().includes('simul')){app.application_type='product_simulations';}else if(app.status&&app.status.toLowerCase().includes('solicit')){app.application_type='selected_plans';}}return app;});}catch(error){console.error(`Error al obtener aplicaciones recientes de la empresa ${companyId}:`,error);// Datos de muestra en caso de error\nrecentCompanyApps=[{id:'1',created_at:new Date().toISOString(),client_name:'Cliente de Empresa',status:'pending',amount:'15000',assigned_to:'Asesor Asignado',application_type:'selected_plans'}];}return{...baseStats,totalApplications:totalCompanyApplications,applicationsByStatus:companyApplicationsByStatus,recentApplications:recentCompanyApps,totalAdvisors,totalClientsCompany,avgApprovalTime};}catch(error){console.error(`Error al obtener estadísticas de la empresa ${companyId}:`,error);throw error;}};/**\n * Obtiene estadísticas de aplicaciones pendientes de aprobación\n * @param userId ID del usuario (asesor o admin de empresa)\n * @param isCompanyAdmin Indica si el usuario es un admin de empresa\n */export const getPendingApprovalStats=async(userId,isCompanyAdmin)=>{try{var _result$;let query='';if(isCompanyAdmin){var _companyResult$;// Obtener ID de la compañía del admin\nconst companyQuery=`\n        SELECT company_id FROM ${TABLES.COMPANY_ADMINS} WHERE id = '${userId}'\n      `;const companyResult=await executeQuery(companyQuery);const companyId=(_companyResult$=companyResult[0])===null||_companyResult$===void 0?void 0:_companyResult$.company_id;if(!companyId){throw new Error('No se encontró la compañía para este administrador');}// Aplicaciones pendientes de aprobación por la compañía\nquery=`\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND approved_by_advisor = true\n        AND approved_by_company = false\n      `;}else{// Aplicaciones pendientes de aprobación por el asesor\nquery=`\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;}const result=await executeQuery(query);return{pendingCount:parseInt(((_result$=result[0])===null||_result$===void 0?void 0:_result$.pending_count)||'0')};}catch(error){console.error('Error al obtener estadísticas de aprobaciones pendientes:',error);throw error;}};","map":{"version":3,"names":["TABLES","executeQuery","getGeneralDashboardStats","_totalAppResult$","_amountResult$","_amountResult$2","_amountResult$3","_categoryResult$","_categoryResult$2","_categoryResult$3","_categoryResult$4","totalApplicationsQuery","APPLICATIONS","totalAppResult","totalApplications","parseInt","total","applicationsByStatusQuery","statusResult","applicationsByStatus","map","row","status","count","amountStatsQuery","amountResult","avgAmount","parseFloat","avg_amount","minAmount","min_amount","maxAmount","max_amount","recentApplications","recentApplicationsQuery","app","application_type","toLowerCase","includes","error","console","id","created_at","Date","toISOString","client_name","amount","company_name","applicationsByMonthQuery","monthResult","applicationsByMonth","month","totalByMajorCategoryQuery","categoryResult","totalApproved","approved","totalRejected","rejected","totalPending","pending","pendingApproval","pending_approval","totalClients","_totalClientsResult$","totalClientsQuery","CLIENTS","totalClientsResult","_clientNamesResult$","clientNamesQuery","clientNamesResult","innerError","getAdvisorDashboardStats","advisorId","_advisorAppResult$","_companiesResult$","_conversionResult$","_conversionResult$2","_timeResult$","baseStats","advisorApplicationsQuery","advisorAppResult","totalAdvisorApplications","advisorStatusQuery","advisorStatusResult","advisorApplicationsByStatus","_clientsResult$","clientsQuery","clientsResult","_clientNamesResult$2","companiesQuery","companiesResult","totalCompanies","conversionRateQuery","conversionResult","conversionRate","avgTimeQuery","timeResult","avgTimeToApproval","avg_days","recentAdvisorApps","recentAdvisorAppsQuery","getCompanyDashboardStats","companyId","_companyAppResult$","_advisorsResult$","_timeResult$2","companyApplicationsQuery","companyAppResult","totalCompanyApplications","companyStatusQuery","companyStatusResult","companyApplicationsByStatus","advisorsQuery","advisorsResult","totalAdvisors","totalClientsCompany","_clientsResult$2","_clientNamesResult$3","avgApprovalTime","recentCompanyApps","recentCompanyAppsQuery","assigned_to","getPendingApprovalStats","userId","isCompanyAdmin","_result$","query","_companyResult$","companyQuery","COMPANY_ADMINS","companyResult","company_id","Error","result","pendingCount","pending_count"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/dashboardService.ts"],"sourcesContent":["import { TABLES } from '../utils/constants/tables';\nimport { executeQuery } from '../utils/databaseUtils';\n\nexport interface DashboardStats {\n  totalApplications: number;\n  applicationsByStatus: {\n    status: string;\n    count: number;\n  }[];\n  avgAmount: number;\n  minAmount: number;\n  maxAmount: number;\n  recentApplications: any[];\n  applicationsByMonth: {\n    month: string;\n    count: number;\n  }[];\n  totalApproved: number;\n  totalRejected: number;\n  totalPending: number;\n  pendingApproval: number;\n  totalClients: number;\n}\n\nexport interface AdvisorStats extends DashboardStats {\n  totalClients: number;\n  totalCompanies: number;\n  conversionRate: number;\n  avgTimeToApproval: number;\n}\n\nexport interface CompanyStats extends DashboardStats {\n  totalAdvisors: number;\n  totalClientsCompany: number;\n  avgApprovalTime: number;\n}\n\n/**\n * Obtiene estadísticas generales para el dashboard\n */\nexport const getGeneralDashboardStats = async (): Promise<DashboardStats> => {\n  try {\n    // Total de aplicaciones\n    const totalApplicationsQuery = `SELECT COUNT(*) as total FROM ${TABLES.APPLICATIONS}`;\n    const totalAppResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = parseInt(totalAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      GROUP BY status\n    `;\n    const statusResult = await executeQuery(applicationsByStatusQuery);\n    const applicationsByStatus = statusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Estadísticas de montos\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(amountResult[0]?.avg_amount || '0');\n    const minAmount = parseFloat(amountResult[0]?.min_amount || '0');\n    const maxAmount = parseFloat(amountResult[0]?.max_amount || '0');\n\n    // Aplicaciones recientes\n    let recentApplications = [];\n    try {\n      const recentApplicationsQuery = `\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentApplications = await executeQuery(recentApplicationsQuery);\n      \n      // Asegurarse de que application_type esté presente en todos los registros\n      recentApplications = recentApplications.map((app: any) => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error('Error al obtener aplicaciones recientes:', error);\n      // Proporcionar datos de muestra si falla la consulta\n      recentApplications = [\n        { id: '1', created_at: new Date().toISOString(), client_name: 'Usuario de Muestra', status: 'pending', amount: '10000', company_name: 'Empresa Ejemplo', application_type: 'selected_plans' },\n        { id: '2', created_at: new Date().toISOString(), client_name: 'Usuario de Muestra', status: 'approved', amount: '15000', company_name: 'Empresa Ejemplo', application_type: 'product_simulations' }\n      ];\n    }\n\n    // Aplicaciones por mes (últimos 6 meses)\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE created_at >= NOW() - INTERVAL '6 months'\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    const monthResult = await executeQuery(applicationsByMonthQuery);\n    const applicationsByMonth = monthResult.map((row: any) => ({\n      month: row.month,\n      count: parseInt(row.count)\n    }));\n\n    // Totales por categoría principal\n    const totalByMajorCategoryQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'Aprobado por Asesor')) as approved,\n        COUNT(*) FILTER (WHERE status IN ('rejected', 'RECHAZADO')) as rejected,\n        COUNT(*) FILTER (WHERE status IN ('pending', 'new', 'Solicitud', 'Simulación')) as pending,\n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n    `;\n    const categoryResult = await executeQuery(totalByMajorCategoryQuery);\n    const totalApproved = parseInt(categoryResult[0]?.approved || '0');\n    const totalRejected = parseInt(categoryResult[0]?.rejected || '0');\n    const totalPending = parseInt(categoryResult[0]?.pending || '0');\n    const pendingApproval = parseInt(categoryResult[0]?.pending_approval || '0');\n\n    // Total clients - use a try-catch block to handle the case where the table doesn't exist\n    let totalClients = 0;\n    try {\n      // First attempt: try to get clients count from clients table\n      const totalClientsQuery = `SELECT COUNT(*) as total FROM ${TABLES.CLIENTS}`;\n      const totalClientsResult = await executeQuery(totalClientsQuery);\n      totalClients = parseInt(totalClientsResult[0]?.total || '0');\n    } catch (error) {\n      // Fallback: if clients table doesn't exist, count distinct client names from applications\n      try {\n        const clientNamesQuery = `SELECT COUNT(DISTINCT client_name) as total FROM ${TABLES.APPLICATIONS}`;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClients = parseInt(clientNamesResult[0]?.total || '0');\n      } catch (innerError) {\n        console.error('Error counting clients from applications table:', innerError);\n        // If that also fails, default to 0\n        totalClients = 0;\n      }\n    }\n\n    return {\n      totalApplications,\n      applicationsByStatus,\n      avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para un asesor\n * @param advisorId ID del asesor\n */\nexport const getAdvisorDashboardStats = async (advisorId: string): Promise<AdvisorStats> => {\n  try {\n    // Obtenemos las estadísticas generales primero\n    const baseStats = await getGeneralDashboardStats();\n\n    // Estadísticas específicas del asesor\n    // Total de aplicaciones del asesor\n    const advisorApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const advisorAppResult = await executeQuery(advisorApplicationsQuery);\n    const totalAdvisorApplications = parseInt(advisorAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado del asesor\n    const advisorStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      GROUP BY status\n    `;\n    const advisorStatusResult = await executeQuery(advisorStatusQuery);\n    const advisorApplicationsByStatus = advisorStatusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de clientes del asesor\n    let totalClients = 0;\n    try {\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE advisor_id = '${advisorId}'\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClients = parseInt(clientsResult[0]?.total || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE assigned_to = '${advisorId}'\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClients = parseInt(clientNamesResult[0]?.total || '0');\n      } catch (innerError) {\n        console.error(`Error counting clients for advisor ${advisorId}:`, innerError);\n        // If that also fails, default to 0\n        totalClients = 0;\n      }\n    }\n\n    // Total de empresas asignadas al asesor\n    const companiesQuery = `\n      SELECT COUNT(DISTINCT company_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const companiesResult = await executeQuery(companiesQuery);\n    const totalCompanies = parseInt(companiesResult[0]?.total || '0');\n\n    // Tasa de conversión (aprobados / total)\n    const conversionRateQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'completed')) as approved,\n        COUNT(*) as total\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const conversionResult = await executeQuery(conversionRateQuery);\n    const approved = parseInt(conversionResult[0]?.approved || '0');\n    const total = parseInt(conversionResult[0]?.total || '0');\n    const conversionRate = total > 0 ? (approved / total) * 100 : 0;\n\n    // Tiempo promedio hasta aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_advisor - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      AND approval_date_advisor IS NOT NULL\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgTimeToApproval = parseFloat(timeResult[0]?.avg_days || '0');\n\n    // Aplicaciones recientes del asesor\n    let recentAdvisorApps = [];\n    try {\n      const recentAdvisorAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${advisorId}'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentAdvisorApps = await executeQuery(recentAdvisorAppsQuery);\n      \n      // Asegurarse de que application_type esté presente en todos los registros\n      recentAdvisorApps = recentAdvisorApps.map((app: any) => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes del asesor ${advisorId}:`, error);\n      // Datos de muestra en caso de error\n      recentAdvisorApps = [\n        { id: '1', created_at: new Date().toISOString(), client_name: 'Cliente de Asesor', status: 'pending', amount: '12000', company_name: 'Empresa Asignada', application_type: 'selected_plans' }\n      ];\n    }\n\n    return {\n      ...baseStats,\n      totalApplications: totalAdvisorApplications,\n      applicationsByStatus: advisorApplicationsByStatus,\n      recentApplications: recentAdvisorApps,\n      totalClients,\n      totalCompanies,\n      conversionRate,\n      avgTimeToApproval\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas del asesor ${advisorId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para una empresa\n * @param companyId ID de la empresa\n */\nexport const getCompanyDashboardStats = async (companyId: string): Promise<CompanyStats> => {\n  try {\n    // Obtenemos las estadísticas generales primero\n    const baseStats = await getGeneralDashboardStats();\n\n    // Estadísticas específicas de la empresa\n    // Total de aplicaciones de la empresa\n    const companyApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const companyAppResult = await executeQuery(companyApplicationsQuery);\n    const totalCompanyApplications = parseInt(companyAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado de la empresa\n    const companyStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      GROUP BY status\n    `;\n    const companyStatusResult = await executeQuery(companyStatusQuery);\n    const companyApplicationsByStatus = companyStatusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de asesores asignados a la empresa\n    const advisorsQuery = `\n      SELECT COUNT(DISTINCT assigned_to) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const advisorsResult = await executeQuery(advisorsQuery);\n    const totalAdvisors = parseInt(advisorsResult[0]?.total || '0');\n\n    // Total de clientes de la empresa\n    let totalClientsCompany = 0;\n    try {\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE company_id = '${companyId}'\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClientsCompany = parseInt(clientsResult[0]?.total || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE company_id = '${companyId}'\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClientsCompany = parseInt(clientNamesResult[0]?.total || '0');\n      } catch (innerError) {\n        console.error(`Error counting clients for company ${companyId}:`, innerError);\n        // If that also fails, default to 0\n        totalClientsCompany = 0;\n      }\n    }\n\n    // Tiempo promedio de aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_company - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      AND approval_date_company IS NOT NULL\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgApprovalTime = parseFloat(timeResult[0]?.avg_days || '0');\n\n    // Aplicaciones recientes de la empresa\n    let recentCompanyApps = [];\n    try {\n      const recentCompanyAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, assigned_to, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentCompanyApps = await executeQuery(recentCompanyAppsQuery);\n      \n      // Asegurarse de que application_type esté presente en todos los registros\n      recentCompanyApps = recentCompanyApps.map((app: any) => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes de la empresa ${companyId}:`, error);\n      // Datos de muestra en caso de error\n      recentCompanyApps = [\n        { id: '1', created_at: new Date().toISOString(), client_name: 'Cliente de Empresa', status: 'pending', amount: '15000', assigned_to: 'Asesor Asignado', application_type: 'selected_plans' }\n      ];\n    }\n\n    return {\n      ...baseStats,\n      totalApplications: totalCompanyApplications,\n      applicationsByStatus: companyApplicationsByStatus,\n      recentApplications: recentCompanyApps,\n      totalAdvisors,\n      totalClientsCompany,\n      avgApprovalTime\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas de la empresa ${companyId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas de aplicaciones pendientes de aprobación\n * @param userId ID del usuario (asesor o admin de empresa)\n * @param isCompanyAdmin Indica si el usuario es un admin de empresa\n */\nexport const getPendingApprovalStats = async (userId: string, isCompanyAdmin: boolean): Promise<any> => {\n  try {\n    let query = '';\n    \n    if (isCompanyAdmin) {\n      // Obtener ID de la compañía del admin\n      const companyQuery = `\n        SELECT company_id FROM ${TABLES.COMPANY_ADMINS} WHERE id = '${userId}'\n      `;\n      const companyResult = await executeQuery(companyQuery);\n      const companyId = companyResult[0]?.company_id;\n      \n      if (!companyId) {\n        throw new Error('No se encontró la compañía para este administrador');\n      }\n      \n      // Aplicaciones pendientes de aprobación por la compañía\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND approved_by_advisor = true\n        AND approved_by_company = false\n      `;\n    } else {\n      // Aplicaciones pendientes de aprobación por el asesor\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;\n    }\n    \n    const result = await executeQuery(query);\n    return {\n      pendingCount: parseInt(result[0]?.pending_count || '0')\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas de aprobaciones pendientes:', error);\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}