{"ast":null,"code":"/**\n * Ejecuta una consulta SQL directa\n * @param query Consulta SQL a ejecutar\n * @returns Resultado de la consulta\n */\nexport const executeQuery = async query => {\n  try {\n    const url = 'http://localhost:3100/query';\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        query\n      })\n    });\n    if (!response.ok) {\n      const errorText = await response.text();\n      // Try to parse error as JSON if possible\n      let errorDetail;\n      try {\n        errorDetail = JSON.parse(errorText);\n      } catch {\n        errorDetail = errorText;\n      }\n      throw new Error(`Error al ejecutar la consulta: ${response.statusText}. Detalles: ${JSON.stringify(errorDetail)}`);\n    }\n    const result = await response.json();\n    return result.data || [];\n  } catch (error) {\n    // Check if error is about missing relation/table\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    if (errorMessage.includes('relation') && errorMessage.includes('does not exist')) {\n      console.error('Error ejecutando consulta - tabla no existe:', errorMessage);\n      throw new Error(`Tabla no encontrada: ${errorMessage}`);\n    }\n    console.error('Error ejecutando consulta:', error);\n    throw error;\n  }\n};\n\n/**\n * Escapa caracteres especiales en string para prevenir inyecci칩n SQL\n * @param value String a escapar\n * @returns String escapado\n */\nexport const escapeSqlString = value => {\n  if (!value) return '';\n\n  // Reemplazar comillas simples por dos comillas simples (est치ndar SQL)\n  return value.replace(/'/g, \"''\");\n};\n\n/**\n * Formatea una fecha para SQL\n * @param date Fecha a formatear\n * @returns String formateado para SQL\n */\nexport const formatDateForSql = date => {\n  return date.toISOString();\n};\n\n/**\n * Convierte un objeto a una cadena de condiciones SQL WHERE\n * @param conditions Objeto con condiciones {columna: valor}\n * @returns String con condiciones SQL\n */\nexport const objectToSqlWhere = conditions => {\n  const clauses = [];\n  for (const [key, value] of Object.entries(conditions)) {\n    if (value === undefined || value === null) continue;\n    if (typeof value === 'string') {\n      clauses.push(`${key} = '${escapeSqlString(value)}'`);\n    } else if (typeof value === 'number' || typeof value === 'boolean') {\n      clauses.push(`${key} = ${value}`);\n    } else if (value instanceof Date) {\n      clauses.push(`${key} = '${formatDateForSql(value)}'`);\n    } else if (Array.isArray(value)) {\n      const formattedValues = value.map(v => typeof v === 'string' ? `'${escapeSqlString(v)}'` : v);\n      clauses.push(`${key} IN (${formattedValues.join(',')})`);\n    }\n  }\n  return clauses.length > 0 ? clauses.join(' AND ') : '1=1';\n};","map":{"version":3,"names":["executeQuery","query","url","response","fetch","method","headers","body","JSON","stringify","ok","errorText","text","errorDetail","parse","Error","statusText","result","json","data","error","errorMessage","message","String","includes","console","escapeSqlString","value","replace","formatDateForSql","date","toISOString","objectToSqlWhere","conditions","clauses","key","Object","entries","undefined","push","Date","Array","isArray","formattedValues","map","v","join","length"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/databaseUtils.ts"],"sourcesContent":["/**\n * Ejecuta una consulta SQL directa\n * @param query Consulta SQL a ejecutar\n * @returns Resultado de la consulta\n */\nexport const executeQuery = async (query: string): Promise<any[]> => {\n  try {\n    const url = 'http://localhost:3100/query';\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ query }),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      // Try to parse error as JSON if possible\n      let errorDetail;\n      try {\n        errorDetail = JSON.parse(errorText);\n      } catch {\n        errorDetail = errorText;\n      }\n      \n      throw new Error(`Error al ejecutar la consulta: ${response.statusText}. Detalles: ${JSON.stringify(errorDetail)}`);\n    }\n\n    const result = await response.json();\n    return result.data || [];\n  } catch (error) {\n    // Check if error is about missing relation/table\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    if (errorMessage.includes('relation') && errorMessage.includes('does not exist')) {\n      console.error('Error ejecutando consulta - tabla no existe:', errorMessage);\n      throw new Error(`Tabla no encontrada: ${errorMessage}`);\n    }\n    \n    console.error('Error ejecutando consulta:', error);\n    throw error;\n  }\n};\n\n/**\n * Escapa caracteres especiales en string para prevenir inyecci칩n SQL\n * @param value String a escapar\n * @returns String escapado\n */\nexport const escapeSqlString = (value: string): string => {\n  if (!value) return '';\n  \n  // Reemplazar comillas simples por dos comillas simples (est치ndar SQL)\n  return value.replace(/'/g, \"''\");\n};\n\n/**\n * Formatea una fecha para SQL\n * @param date Fecha a formatear\n * @returns String formateado para SQL\n */\nexport const formatDateForSql = (date: Date): string => {\n  return date.toISOString();\n};\n\n/**\n * Convierte un objeto a una cadena de condiciones SQL WHERE\n * @param conditions Objeto con condiciones {columna: valor}\n * @returns String con condiciones SQL\n */\nexport const objectToSqlWhere = (conditions: Record<string, any>): string => {\n  const clauses = [];\n  \n  for (const [key, value] of Object.entries(conditions)) {\n    if (value === undefined || value === null) continue;\n    \n    if (typeof value === 'string') {\n      clauses.push(`${key} = '${escapeSqlString(value)}'`);\n    } else if (typeof value === 'number' || typeof value === 'boolean') {\n      clauses.push(`${key} = ${value}`);\n    } else if (value instanceof Date) {\n      clauses.push(`${key} = '${formatDateForSql(value)}'`);\n    } else if (Array.isArray(value)) {\n      const formattedValues = value.map(v => \n        typeof v === 'string' ? `'${escapeSqlString(v)}'` : v\n      );\n      clauses.push(`${key} IN (${formattedValues.join(',')})`);\n    }\n  }\n  \n  return clauses.length > 0 ? clauses.join(' AND ') : '1=1';\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}