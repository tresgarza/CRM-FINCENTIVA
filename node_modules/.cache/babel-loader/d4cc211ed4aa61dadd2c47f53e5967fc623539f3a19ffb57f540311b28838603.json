{"ast":null,"code":"import{TABLES}from'../utils/constants/tables';import{executeQuery}from'../utils/databaseUtils';/**\n * Obtiene estadísticas generales para el dashboard\n */export const getGeneralDashboardStats=async function(){let filters=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{dateFrom,dateTo,companyId,advisorId,includeSimulations=false}=filters;// Construir la parte de la consulta para los filtros de fecha\nlet dateFilter='';if(dateFrom){dateFilter+=` AND created_at >= '${dateFrom}'`;}if(dateTo){dateFilter+=` AND created_at <= '${dateTo}'`;}// Filtro por compañía si se proporciona\nlet companyFilter='';if(companyId){companyFilter=` AND company_id = '${companyId}'`;}// Filtro por asesor si se proporciona\nlet advisorFilter='';if(advisorId){advisorFilter=` AND assigned_to = '${advisorId}'`;}// Filtro para excluir simulaciones por defecto\nlet simulationFilter='';if(!includeSimulations){simulationFilter=` AND application_type != 'product_simulations'`;}try{var _totalApplicationsDat,_amountStatsData$,_amountStatsData$2,_amountStatsData$3;// 1. Total de aplicaciones\nconst totalApplicationsQuery=`\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n    `;let totalApplicationsData;try{totalApplicationsData=await executeQuery(totalApplicationsQuery);}catch(error){console.error('Error al obtener total de aplicaciones:',error);totalApplicationsData=[{total:0}];// Valor por defecto si falla\n}const totalApplications=((_totalApplicationsDat=totalApplicationsData[0])===null||_totalApplicationsDat===void 0?void 0:_totalApplicationsDat.total)||0;// 2. Aplicaciones por estado\nconst applicationsByStatusQuery=`\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n      GROUP BY status\n    `;let applicationsByStatusData;try{applicationsByStatusData=await executeQuery(applicationsByStatusQuery);}catch(error){console.error('Error al obtener aplicaciones por estado:',error);applicationsByStatusData=[];// Valor por defecto si falla\n}const applicationsByStatus={};applicationsByStatusData.forEach(item=>{applicationsByStatus[item.status]=parseInt(item.count);});const pendingApplications=applicationsByStatus['pending']||0;const approvedApplications=applicationsByStatus['approved']||0;const rejectedApplications=applicationsByStatus['rejected']||0;// 3. Promedio, mínimo y máximo de montos\nconst amountStatsQuery=`\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n    `;let amountStatsData;try{amountStatsData=await executeQuery(amountStatsQuery);}catch(error){console.error('Error al obtener estadísticas de montos:',error);amountStatsData=[{avg_amount:0,min_amount:0,max_amount:0}];// Valor por defecto si falla\n}const averageAmount=parseFloat((_amountStatsData$=amountStatsData[0])===null||_amountStatsData$===void 0?void 0:_amountStatsData$.avg_amount)||0;const minAmount=parseFloat((_amountStatsData$2=amountStatsData[0])===null||_amountStatsData$2===void 0?void 0:_amountStatsData$2.min_amount)||0;const maxAmount=parseFloat((_amountStatsData$3=amountStatsData[0])===null||_amountStatsData$3===void 0?void 0:_amountStatsData$3.max_amount)||0;// 4. Aplicaciones recientes\nconst recentApplicationsQuery=`\n      SELECT id, client_name, company_name, created_at, status, amount, application_type\n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n      AND application_type = 'selected_plans'\n      ORDER BY created_at DESC \n      LIMIT 5\n    `;let recentApplicationsData;try{recentApplicationsData=await executeQuery(recentApplicationsQuery);}catch(error){console.error('Error al obtener aplicaciones recientes:',error);recentApplicationsData=[];// Valor por defecto si falla\n}// 5. Aplicaciones por mes (para gráfico de líneas)\nconst applicationsByMonthQuery=`\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n      GROUP BY month \n      ORDER BY month\n    `;let applicationsByMonthData;try{applicationsByMonthData=await executeQuery(applicationsByMonthQuery);}catch(error){console.error('Error al obtener aplicaciones por mes:',error);applicationsByMonthData=[];// Valor por defecto si falla\n}const applicationsByMonth={};applicationsByMonthData.forEach(item=>{applicationsByMonth[item.month]=parseInt(item.count);});// 6. Rendimiento de asesores (solo para superadmin o filtrado por compañía)\nlet advisorsPerformance=[];if(!advisorId){// Solo si no estamos filtrando por un asesor específico\nconst advisorsPerformanceQuery=`\n        SELECT \n          a.assigned_to as advisor_id, \n          u.name as advisor_name,\n          COUNT(*) as total_applications,\n          SUM(CASE WHEN a.status = 'approved' THEN 1 ELSE 0 END) as approved_applications,\n          SUM(CASE WHEN a.status = 'rejected' THEN 1 ELSE 0 END) as rejected_applications\n        FROM ${TABLES.APPLICATIONS} a\n        LEFT JOIN ${TABLES.ADVISORS} u ON a.assigned_to = u.id\n        WHERE 1=1 ${dateFilter} ${companyFilter} ${simulationFilter}\n        GROUP BY a.assigned_to, u.name\n        ORDER BY total_applications DESC\n      `;try{const advisorsData=await executeQuery(advisorsPerformanceQuery);advisorsPerformance=advisorsData.map(advisor=>({advisorId:advisor.advisor_id,advisorName:advisor.advisor_name||'Desconocido',totalApplications:parseInt(advisor.total_applications)||0,approvedApplications:parseInt(advisor.approved_applications)||0,rejectedApplications:parseInt(advisor.rejected_applications)||0,approvalRate:advisor.total_applications>0?parseInt(advisor.approved_applications)/parseInt(advisor.total_applications)*100:0}));}catch(error){console.error('Error al obtener rendimiento de asesores:',error);// Continuamos incluso si esta consulta falla\n}}// 7. Total de clientes\nlet totalClients=0;const totalClientsQuery=`\n      SELECT COUNT(DISTINCT source_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE source_id IS NOT NULL ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n    `;try{var _totalClientsData$;const totalClientsData=await executeQuery(totalClientsQuery);totalClients=parseInt((_totalClientsData$=totalClientsData[0])===null||_totalClientsData$===void 0?void 0:_totalClientsData$.total)||0;}catch(error){console.error('Error al obtener total de clientes:',error);// Continuamos incluso si esta consulta falla\n}return{totalApplications:parseInt(totalApplications),pendingApplications,approvedApplications,rejectedApplications,averageAmount,minAmount,maxAmount,recentApplications:recentApplicationsData,applicationsByStatus,applicationsByMonth,advisorsPerformance,totalClients};}catch(error){console.error('Error obteniendo estadísticas del dashboard:',error);// En caso de error, devolvemos datos vacíos para evitar que la UI se rompa\nreturn{totalApplications:0,pendingApplications:0,approvedApplications:0,rejectedApplications:0,averageAmount:0,minAmount:0,maxAmount:0,recentApplications:[],applicationsByStatus:{},applicationsByMonth:{},totalClients:0};}};/**\n * Obtiene estadísticas específicas para un asesor\n * @param advisorId ID del asesor\n * @param includeSimulations Si es true, incluye las simulaciones en las estadísticas\n */export const getAdvisorDashboardStats=async function(advisorId){let includeSimulations=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;try{var _advisorAppResult$,_amountResult$,_amountResult$2,_amountResult$3,_companiesResult$,_conversionResult$,_conversionResult$2,_totalApprovedResult$,_totalRejectedResult$,_totalPendingResult$,_pendingApprovalResul,_timeResult$;// Filtro para excluir simulaciones por defecto\nlet simulationFilter='';if(!includeSimulations){simulationFilter=` AND application_type != 'product_simulations'`;}// No obtener estadísticas generales, sino filtrar todo por el asesor\n// Total de aplicaciones del asesor\nconst advisorApplicationsQuery=`\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;const advisorAppResult=await executeQuery(advisorApplicationsQuery);const totalAdvisorApplications=parseInt(((_advisorAppResult$=advisorAppResult[0])===null||_advisorAppResult$===void 0?void 0:_advisorAppResult$.total)||'0');// Aplicaciones por estado del asesor\nconst advisorStatusQuery=`\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n      GROUP BY status\n    `;const advisorStatusResult=await executeQuery(advisorStatusQuery);const advisorApplicationsByStatus=advisorStatusResult.map(row=>({status:row.status,count:parseInt(row.count)}));// Estadísticas de montos específicas del asesor\nconst amountStatsQuery=`\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n      AND assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;const amountResult=await executeQuery(amountStatsQuery);const avgAmount=parseFloat(((_amountResult$=amountResult[0])===null||_amountResult$===void 0?void 0:_amountResult$.avg_amount)||'0');const minAmount=parseFloat(((_amountResult$2=amountResult[0])===null||_amountResult$2===void 0?void 0:_amountResult$2.min_amount)||'0');const maxAmount=parseFloat(((_amountResult$3=amountResult[0])===null||_amountResult$3===void 0?void 0:_amountResult$3.max_amount)||'0');// Calcular aplicaciones por mes para este asesor\nconst monthlyQuery=`\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month,\n        COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;let applicationsByMonth=[];try{const monthlyResult=await executeQuery(monthlyQuery);applicationsByMonth=monthlyResult.map(row=>({month:row.month,count:parseInt(row.count)}));}catch(error){console.error(`Error al obtener aplicaciones por mes para asesor ${advisorId}:`,error);applicationsByMonth=[];}// Total de clientes del asesor\nlet totalClients=0;try{var _clientsResult$;// First attempt: try to get clients from clients table\nconst clientsQuery=`\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE advisor_id = '${advisorId}'\n      `;const clientsResult=await executeQuery(clientsQuery);totalClients=parseInt(((_clientsResult$=clientsResult[0])===null||_clientsResult$===void 0?void 0:_clientsResult$.total)||'0');}catch(error){// Fallback: count distinct client names from applications\ntry{var _clientNamesResult$;const clientNamesQuery=`\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE assigned_to = '${advisorId}'\n          ${simulationFilter}\n        `;const clientNamesResult=await executeQuery(clientNamesQuery);totalClients=parseInt(((_clientNamesResult$=clientNamesResult[0])===null||_clientNamesResult$===void 0?void 0:_clientNamesResult$.total)||'0');}catch(innerError){console.error(`Error counting clients for advisor ${advisorId}:`,innerError);// If that also fails, default to 0\ntotalClients=0;}}// Total de empresas asignadas al asesor\nconst companiesQuery=`\n      SELECT COUNT(DISTINCT company_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;const companiesResult=await executeQuery(companiesQuery);const totalCompanies=parseInt(((_companiesResult$=companiesResult[0])===null||_companiesResult$===void 0?void 0:_companiesResult$.total)||'0');// Tasa de conversión (aprobados / total)\nconst conversionRateQuery=`\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'completed')) as approved,\n        COUNT(*) as total\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;const conversionResult=await executeQuery(conversionRateQuery);const approved=parseInt(((_conversionResult$=conversionResult[0])===null||_conversionResult$===void 0?void 0:_conversionResult$.approved)||'0');const total=parseInt(((_conversionResult$2=conversionResult[0])===null||_conversionResult$2===void 0?void 0:_conversionResult$2.total)||'0');const conversionRate=total>0?approved/total*100:0;// Calcular totales específicos para cada estado\nconst totalApprovedQuery=`\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('approved', 'APROBADO', 'completed')\n      ${simulationFilter}\n    `;const totalApprovedResult=await executeQuery(totalApprovedQuery);const totalApproved=parseInt(((_totalApprovedResult$=totalApprovedResult[0])===null||_totalApprovedResult$===void 0?void 0:_totalApprovedResult$.count)||'0');const totalRejectedQuery=`\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('rejected', 'RECHAZADO')\n      ${simulationFilter}\n    `;const totalRejectedResult=await executeQuery(totalRejectedQuery);const totalRejected=parseInt(((_totalRejectedResult$=totalRejectedResult[0])===null||_totalRejectedResult$===void 0?void 0:_totalRejectedResult$.count)||'0');const totalPendingQuery=`\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('pending', 'PENDIENTE', 'review', 'REVISION')\n      ${simulationFilter}\n    `;const totalPendingResult=await executeQuery(totalPendingQuery);const totalPending=parseInt(((_totalPendingResult$=totalPendingResult[0])===null||_totalPendingResult$===void 0?void 0:_totalPendingResult$.count)||'0');const pendingApprovalQuery=`\n      SELECT \n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;const pendingApprovalResult=await executeQuery(pendingApprovalQuery);const pendingApproval=parseInt(((_pendingApprovalResul=pendingApprovalResult[0])===null||_pendingApprovalResul===void 0?void 0:_pendingApprovalResul.pending_approval)||'0');// Tiempo promedio hasta aprobación\nconst avgTimeQuery=`\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_advisor - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      AND approval_date_advisor IS NOT NULL\n      ${simulationFilter}\n    `;const timeResult=await executeQuery(avgTimeQuery);const avgTimeToApproval=parseFloat(((_timeResult$=timeResult[0])===null||_timeResult$===void 0?void 0:_timeResult$.avg_days)||'0');// Aplicaciones recientes del asesor\nlet recentAdvisorApps=[];try{const recentAdvisorAppsQuery=`\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${advisorId}'\n        AND application_type = 'selected_plans'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;recentAdvisorApps=await executeQuery(recentAdvisorAppsQuery);// Asegurarse de que application_type esté presente en todos los registros\nrecentAdvisorApps=recentAdvisorApps.map(app=>{if(!app.application_type){// Si no tiene application_type, intentar determinar por otros campos\nif(app.status&&app.status.toLowerCase().includes('simul')){app.application_type='product_simulations';}else if(app.status&&app.status.toLowerCase().includes('solicit')){app.application_type='selected_plans';}}return app;});}catch(error){console.error(`Error al obtener aplicaciones recientes del asesor ${advisorId}:`,error);recentAdvisorApps=[];}return{totalApplications:totalAdvisorApplications,applicationsByStatus:advisorApplicationsByStatus,averageAmount:avgAmount,minAmount,maxAmount,recentApplications:recentAdvisorApps,applicationsByMonth,totalApproved,totalRejected,totalPending,pendingApproval,totalClients,totalCompanies,conversionRate,avgTimeToApproval,advisorId,advisorName:'',// This would be populated from user data\npendingApplications:totalPending,approvedApplications:totalApproved,rejectedApplications:totalRejected};}catch(error){console.error(`Error al obtener estadísticas del asesor ${advisorId}:`,error);throw error;}};/**\n * Obtiene estadísticas específicas para una empresa\n * @param companyId ID de la empresa\n * @param includeSimulations Si es true, incluye las simulaciones en las estadísticas\n */export const getCompanyDashboardStats=async function(companyId){let includeSimulations=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;try{var _companyAppResult$,_advisorsResult$,_clientNamesResult$2,_timeResult$2,_baseStats$pendingApp;// Filtro para excluir simulaciones por defecto\nlet simulationFilter='';if(!includeSimulations){simulationFilter=` AND application_type != 'product_simulations'`;}// Obtenemos las estadísticas generales primero con el mismo filtro\nconst baseStats=await getGeneralDashboardStats({companyId,includeSimulations});// Estadísticas específicas de la empresa\n// Total de aplicaciones de la empresa\nconst companyApplicationsQuery=`\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n    `;const companyAppResult=await executeQuery(companyApplicationsQuery);const totalCompanyApplications=parseInt(((_companyAppResult$=companyAppResult[0])===null||_companyAppResult$===void 0?void 0:_companyAppResult$.total)||'0');// Aplicaciones por estado de la empresa\nconst companyStatusQuery=`\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n      GROUP BY status\n    `;const companyStatusResult=await executeQuery(companyStatusQuery);const companyApplicationsByStatus=companyStatusResult.map(row=>({status:row.status,count:parseInt(row.count)}));// Total de asesores asignados a la empresa\nconst advisorsQuery=`\n      SELECT COUNT(DISTINCT assigned_to) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n    `;const advisorsResult=await executeQuery(advisorsQuery);const totalAdvisors=parseInt(((_advisorsResult$=advisorsResult[0])===null||_advisorsResult$===void 0?void 0:_advisorsResult$.total)||'0');// Total de clientes de la empresa\nconst clientNamesQuery=`\n      SELECT COUNT(DISTINCT client_name) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n    `;const clientNamesResult=await executeQuery(clientNamesQuery);const totalClientsCompany=parseInt(((_clientNamesResult$2=clientNamesResult[0])===null||_clientNamesResult$2===void 0?void 0:_clientNamesResult$2.total)||'0');// Tiempo promedio de aprobación\nconst avgTimeQuery=`\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_company - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      AND approval_date_company IS NOT NULL\n      ${simulationFilter}\n    `;const timeResult=await executeQuery(avgTimeQuery);const avgApprovalTime=parseFloat(((_timeResult$2=timeResult[0])===null||_timeResult$2===void 0?void 0:_timeResult$2.avg_days)||'0');// Aplicaciones recientes de la empresa\nlet recentCompanyApps=[];try{const recentCompanyAppsQuery=`\n        SELECT id, created_at, client_name, status, amount, assigned_to, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND application_type = 'selected_plans'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;recentCompanyApps=await executeQuery(recentCompanyAppsQuery);// Asegurarse de que application_type esté presente en todos los registros\nrecentCompanyApps=recentCompanyApps.map(app=>{if(!app.application_type){// Si no tiene application_type, intentar determinar por otros campos\nif(app.status&&app.status.toLowerCase().includes('simul')){app.application_type='product_simulations';}else if(app.status&&app.status.toLowerCase().includes('solicit')){app.application_type='selected_plans';}}return app;});}catch(error){console.error(`Error al obtener aplicaciones recientes de la empresa ${companyId}:`,error);// Datos de muestra en caso de error\nrecentCompanyApps=[{id:'1',created_at:new Date().toISOString(),client_name:'Cliente de Empresa',status:'pending',amount:'15000',assigned_to:'Asesor Asignado',application_type:'selected_plans'}];}return{...baseStats,totalApplications:totalCompanyApplications,applicationsByStatus:companyApplicationsByStatus,recentApplications:recentCompanyApps,totalAdvisors,totalClientsCompany,avgApprovalTime,pendingApplications:parseInt(((_baseStats$pendingApp=baseStats.pendingApplications)===null||_baseStats$pendingApp===void 0?void 0:_baseStats$pendingApp.toString())||'0'),applicationsByMonth:Array.isArray(baseStats.applicationsByMonth)?baseStats.applicationsByMonth:Object.entries(baseStats.applicationsByMonth||{}).map(_ref=>{let[month,count]=_ref;return{month,count:Number(count)};})};}catch(error){console.error(`Error al obtener estadísticas de la empresa ${companyId}:`,error);throw error;}};/**\n * Obtiene estadísticas de aplicaciones pendientes de aprobación\n * @param userId ID del usuario (asesor o admin de empresa)\n * @param isCompanyAdmin Indica si el usuario es un admin de empresa\n */export const getPendingApprovalStats=async(userId,isCompanyAdmin)=>{try{var _result$;let query='';if(isCompanyAdmin){var _companyResult$;// Obtener ID de la compañía del admin\nconst companyQuery=`\n        SELECT company_id FROM ${TABLES.COMPANY_ADMINS} WHERE id = '${userId}'\n      `;const companyResult=await executeQuery(companyQuery);const companyId=(_companyResult$=companyResult[0])===null||_companyResult$===void 0?void 0:_companyResult$.company_id;if(!companyId){throw new Error('No se encontró la compañía para este administrador');}// Aplicaciones pendientes de aprobación por la compañía\nquery=`\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND approved_by_advisor = true\n        AND approved_by_company = false\n      `;}else{// Aplicaciones pendientes de aprobación por el asesor\nquery=`\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;}const result=await executeQuery(query);return{pendingCount:parseInt(((_result$=result[0])===null||_result$===void 0?void 0:_result$.pending_count)||'0')};}catch(error){console.error('Error al obtener estadísticas de aprobaciones pendientes:',error);throw error;}};","map":{"version":3,"names":["TABLES","executeQuery","getGeneralDashboardStats","filters","arguments","length","undefined","dateFrom","dateTo","companyId","advisorId","includeSimulations","dateFilter","companyFilter","advisorFilter","simulationFilter","_totalApplicationsDat","_amountStatsData$","_amountStatsData$2","_amountStatsData$3","totalApplicationsQuery","APPLICATIONS","totalApplicationsData","error","console","total","totalApplications","applicationsByStatusQuery","applicationsByStatusData","applicationsByStatus","forEach","item","status","parseInt","count","pendingApplications","approvedApplications","rejectedApplications","amountStatsQuery","amountStatsData","avg_amount","min_amount","max_amount","averageAmount","parseFloat","minAmount","maxAmount","recentApplicationsQuery","recentApplicationsData","applicationsByMonthQuery","applicationsByMonthData","applicationsByMonth","month","advisorsPerformance","advisorsPerformanceQuery","ADVISORS","advisorsData","map","advisor","advisor_id","advisorName","advisor_name","total_applications","approved_applications","rejected_applications","approvalRate","totalClients","totalClientsQuery","_totalClientsData$","totalClientsData","recentApplications","getAdvisorDashboardStats","_advisorAppResult$","_amountResult$","_amountResult$2","_amountResult$3","_companiesResult$","_conversionResult$","_conversionResult$2","_totalApprovedResult$","_totalRejectedResult$","_totalPendingResult$","_pendingApprovalResul","_timeResult$","advisorApplicationsQuery","advisorAppResult","totalAdvisorApplications","advisorStatusQuery","advisorStatusResult","advisorApplicationsByStatus","row","amountResult","avgAmount","monthlyQuery","monthlyResult","_clientsResult$","clientsQuery","CLIENTS","clientsResult","_clientNamesResult$","clientNamesQuery","clientNamesResult","innerError","companiesQuery","companiesResult","totalCompanies","conversionRateQuery","conversionResult","approved","conversionRate","totalApprovedQuery","totalApprovedResult","totalApproved","totalRejectedQuery","totalRejectedResult","totalRejected","totalPendingQuery","totalPendingResult","totalPending","pendingApprovalQuery","pendingApprovalResult","pendingApproval","pending_approval","avgTimeQuery","timeResult","avgTimeToApproval","avg_days","recentAdvisorApps","recentAdvisorAppsQuery","app","application_type","toLowerCase","includes","getCompanyDashboardStats","_companyAppResult$","_advisorsResult$","_clientNamesResult$2","_timeResult$2","_baseStats$pendingApp","baseStats","companyApplicationsQuery","companyAppResult","totalCompanyApplications","companyStatusQuery","companyStatusResult","companyApplicationsByStatus","advisorsQuery","advisorsResult","totalAdvisors","totalClientsCompany","avgApprovalTime","recentCompanyApps","recentCompanyAppsQuery","id","created_at","Date","toISOString","client_name","amount","assigned_to","toString","Array","isArray","Object","entries","_ref","Number","getPendingApprovalStats","userId","isCompanyAdmin","_result$","query","_companyResult$","companyQuery","COMPANY_ADMINS","companyResult","company_id","Error","result","pendingCount","pending_count"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/dashboardService.ts"],"sourcesContent":["import { TABLES } from '../utils/constants/tables';\nimport { executeQuery } from '../utils/databaseUtils';\n\ninterface DashboardStatsFilter {\n  dateFrom?: string;\n  dateTo?: string;\n  companyId?: string;\n  advisorId?: string;\n  includeSimulations?: boolean; // Nuevo parámetro para controlar si se incluyen simulaciones\n}\n\ninterface AdvisorPerformanceStats {\n  advisorId: string;\n  advisorName: string;\n  totalApplications: number;\n  approvedApplications: number;\n  rejectedApplications: number;\n  approvalRate: number;\n}\n\nexport interface DashboardStats {\n  totalApplications: number;\n  pendingApplications: number;\n  approvedApplications: number;\n  rejectedApplications: number;\n  averageAmount: number;\n  minAmount: number;\n  maxAmount: number;\n  recentApplications: any[];\n  applicationsByStatus: Record<string, number>;\n  applicationsByMonth: Record<string, number>;\n  advisorsPerformance?: AdvisorPerformanceStats[];\n  totalClients: number;\n}\n\nexport interface AdvisorStats extends Omit<DashboardStats, 'applicationsByMonth' | 'applicationsByStatus'> {\n  advisorId: string;\n  advisorName: string;\n  applicationsByMonth: Array<{month: string, count: number}>;\n  applicationsByStatus: Array<{status: string, count: number}>;\n  totalApproved: number;\n  totalRejected: number;\n  totalPending: number;\n  pendingApproval: number;\n  totalCompanies: number;\n  conversionRate: number;\n  avgTimeToApproval: number;\n}\n\nexport interface CompanyStats extends Omit<DashboardStats, 'applicationsByMonth' | 'applicationsByStatus'> {\n  totalAdvisors: number;\n  totalClientsCompany: number;\n  avgApprovalTime: number;\n  pendingApplications: number;\n  applicationsByStatus: Array<{status: string, count: number}>;\n  applicationsByMonth: Array<{month: string, count: number}>;\n}\n\n/**\n * Obtiene estadísticas generales para el dashboard\n */\nexport const getGeneralDashboardStats = async (filters: DashboardStatsFilter = {}): Promise<DashboardStats> => {\n  const { dateFrom, dateTo, companyId, advisorId, includeSimulations = false } = filters;\n  \n  // Construir la parte de la consulta para los filtros de fecha\n  let dateFilter = '';\n  if (dateFrom) {\n    dateFilter += ` AND created_at >= '${dateFrom}'`;\n  }\n  if (dateTo) {\n    dateFilter += ` AND created_at <= '${dateTo}'`;\n  }\n  \n  // Filtro por compañía si se proporciona\n  let companyFilter = '';\n  if (companyId) {\n    companyFilter = ` AND company_id = '${companyId}'`;\n  }\n  \n  // Filtro por asesor si se proporciona\n  let advisorFilter = '';\n  if (advisorId) {\n    advisorFilter = ` AND assigned_to = '${advisorId}'`;\n  }\n  \n  // Filtro para excluir simulaciones por defecto\n  let simulationFilter = '';\n  if (!includeSimulations) {\n    simulationFilter = ` AND application_type != 'product_simulations'`;\n  }\n\n  try {\n    // 1. Total de aplicaciones\n    const totalApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n    `;\n    \n    let totalApplicationsData;\n    try {\n      totalApplicationsData = await executeQuery(totalApplicationsQuery);\n    } catch (error) {\n      console.error('Error al obtener total de aplicaciones:', error);\n      totalApplicationsData = [{ total: 0 }]; // Valor por defecto si falla\n    }\n    \n    const totalApplications = totalApplicationsData[0]?.total || 0;\n    \n    // 2. Aplicaciones por estado\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n      GROUP BY status\n    `;\n    \n    let applicationsByStatusData;\n    try {\n      applicationsByStatusData = await executeQuery(applicationsByStatusQuery);\n    } catch (error) {\n      console.error('Error al obtener aplicaciones por estado:', error);\n      applicationsByStatusData = []; // Valor por defecto si falla\n    }\n    \n    const applicationsByStatus: Record<string, number> = {};\n    applicationsByStatusData.forEach((item: any) => {\n      applicationsByStatus[item.status] = parseInt(item.count);\n    });\n    \n    const pendingApplications = applicationsByStatus['pending'] || 0;\n    const approvedApplications = applicationsByStatus['approved'] || 0;\n    const rejectedApplications = applicationsByStatus['rejected'] || 0;\n    \n    // 3. Promedio, mínimo y máximo de montos\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n    `;\n    \n    let amountStatsData;\n    try {\n      amountStatsData = await executeQuery(amountStatsQuery);\n    } catch (error) {\n      console.error('Error al obtener estadísticas de montos:', error);\n      amountStatsData = [{ avg_amount: 0, min_amount: 0, max_amount: 0 }]; // Valor por defecto si falla\n    }\n    \n    const averageAmount = parseFloat(amountStatsData[0]?.avg_amount) || 0;\n    const minAmount = parseFloat(amountStatsData[0]?.min_amount) || 0;\n    const maxAmount = parseFloat(amountStatsData[0]?.max_amount) || 0;\n    \n    // 4. Aplicaciones recientes\n    const recentApplicationsQuery = `\n      SELECT id, client_name, company_name, created_at, status, amount, application_type\n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n      AND application_type = 'selected_plans'\n      ORDER BY created_at DESC \n      LIMIT 5\n    `;\n    \n    let recentApplicationsData;\n    try {\n      recentApplicationsData = await executeQuery(recentApplicationsQuery);\n    } catch (error) {\n      console.error('Error al obtener aplicaciones recientes:', error);\n      recentApplicationsData = []; // Valor por defecto si falla\n    }\n    \n    // 5. Aplicaciones por mes (para gráfico de líneas)\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE 1=1 ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n      GROUP BY month \n      ORDER BY month\n    `;\n    \n    let applicationsByMonthData;\n    try {\n      applicationsByMonthData = await executeQuery(applicationsByMonthQuery);\n    } catch (error) {\n      console.error('Error al obtener aplicaciones por mes:', error);\n      applicationsByMonthData = []; // Valor por defecto si falla\n    }\n    \n    const applicationsByMonth: Record<string, number> = {};\n    applicationsByMonthData.forEach((item: any) => {\n      applicationsByMonth[item.month] = parseInt(item.count);\n    });\n    \n    // 6. Rendimiento de asesores (solo para superadmin o filtrado por compañía)\n    let advisorsPerformance: AdvisorPerformanceStats[] = [];\n    \n    if (!advisorId) { // Solo si no estamos filtrando por un asesor específico\n      const advisorsPerformanceQuery = `\n        SELECT \n          a.assigned_to as advisor_id, \n          u.name as advisor_name,\n          COUNT(*) as total_applications,\n          SUM(CASE WHEN a.status = 'approved' THEN 1 ELSE 0 END) as approved_applications,\n          SUM(CASE WHEN a.status = 'rejected' THEN 1 ELSE 0 END) as rejected_applications\n        FROM ${TABLES.APPLICATIONS} a\n        LEFT JOIN ${TABLES.ADVISORS} u ON a.assigned_to = u.id\n        WHERE 1=1 ${dateFilter} ${companyFilter} ${simulationFilter}\n        GROUP BY a.assigned_to, u.name\n        ORDER BY total_applications DESC\n      `;\n      \n      try {\n        const advisorsData = await executeQuery(advisorsPerformanceQuery);\n        advisorsPerformance = advisorsData.map((advisor: any) => ({\n          advisorId: advisor.advisor_id,\n          advisorName: advisor.advisor_name || 'Desconocido',\n          totalApplications: parseInt(advisor.total_applications) || 0,\n          approvedApplications: parseInt(advisor.approved_applications) || 0,\n          rejectedApplications: parseInt(advisor.rejected_applications) || 0,\n          approvalRate: advisor.total_applications > 0 \n            ? (parseInt(advisor.approved_applications) / parseInt(advisor.total_applications)) * 100 \n            : 0\n        }));\n      } catch (error) {\n        console.error('Error al obtener rendimiento de asesores:', error);\n        // Continuamos incluso si esta consulta falla\n      }\n    }\n    \n    // 7. Total de clientes\n    let totalClients = 0;\n    const totalClientsQuery = `\n      SELECT COUNT(DISTINCT source_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE source_id IS NOT NULL ${dateFilter} ${companyFilter} ${advisorFilter} ${simulationFilter}\n    `;\n    \n    try {\n      const totalClientsData = await executeQuery(totalClientsQuery);\n      totalClients = parseInt(totalClientsData[0]?.total) || 0;\n    } catch (error) {\n      console.error('Error al obtener total de clientes:', error);\n      // Continuamos incluso si esta consulta falla\n    }\n    \n    return {\n      totalApplications: parseInt(totalApplications),\n      pendingApplications,\n      approvedApplications,\n      rejectedApplications,\n      averageAmount,\n      minAmount,\n      maxAmount,\n      recentApplications: recentApplicationsData,\n      applicationsByStatus,\n      applicationsByMonth,\n      advisorsPerformance,\n      totalClients\n    };\n    \n  } catch (error) {\n    console.error('Error obteniendo estadísticas del dashboard:', error);\n    // En caso de error, devolvemos datos vacíos para evitar que la UI se rompa\n    return {\n      totalApplications: 0,\n      pendingApplications: 0,\n      approvedApplications: 0,\n      rejectedApplications: 0,\n      averageAmount: 0,\n      minAmount: 0,\n      maxAmount: 0,\n      recentApplications: [],\n      applicationsByStatus: {},\n      applicationsByMonth: {},\n      totalClients: 0\n    };\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para un asesor\n * @param advisorId ID del asesor\n * @param includeSimulations Si es true, incluye las simulaciones en las estadísticas\n */\nexport const getAdvisorDashboardStats = async (advisorId: string, includeSimulations: boolean = false): Promise<AdvisorStats> => {\n  try {\n    // Filtro para excluir simulaciones por defecto\n    let simulationFilter = '';\n    if (!includeSimulations) {\n      simulationFilter = ` AND application_type != 'product_simulations'`;\n    }\n    \n    // No obtener estadísticas generales, sino filtrar todo por el asesor\n    \n    // Total de aplicaciones del asesor\n    const advisorApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const advisorAppResult = await executeQuery(advisorApplicationsQuery);\n    const totalAdvisorApplications = parseInt(advisorAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado del asesor\n    const advisorStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n      GROUP BY status\n    `;\n    const advisorStatusResult = await executeQuery(advisorStatusQuery);\n    const advisorApplicationsByStatus = advisorStatusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Estadísticas de montos específicas del asesor\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n      AND assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(amountResult[0]?.avg_amount || '0');\n    const minAmount = parseFloat(amountResult[0]?.min_amount || '0');\n    const maxAmount = parseFloat(amountResult[0]?.max_amount || '0');\n\n    // Calcular aplicaciones por mes para este asesor\n    const monthlyQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month,\n        COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    \n    let applicationsByMonth: {month: string, count: number}[] = [];\n    try {\n      const monthlyResult = await executeQuery(monthlyQuery);\n      applicationsByMonth = monthlyResult.map((row: any) => ({\n        month: row.month,\n        count: parseInt(row.count)\n      }));\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones por mes para asesor ${advisorId}:`, error);\n      applicationsByMonth = [];\n    }\n\n    // Total de clientes del asesor\n    let totalClients = 0;\n    try {\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE advisor_id = '${advisorId}'\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClients = parseInt(clientsResult[0]?.total || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE assigned_to = '${advisorId}'\n          ${simulationFilter}\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClients = parseInt(clientNamesResult[0]?.total || '0');\n      } catch (innerError) {\n        console.error(`Error counting clients for advisor ${advisorId}:`, innerError);\n        // If that also fails, default to 0\n        totalClients = 0;\n      }\n    }\n\n    // Total de empresas asignadas al asesor\n    const companiesQuery = `\n      SELECT COUNT(DISTINCT company_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const companiesResult = await executeQuery(companiesQuery);\n    const totalCompanies = parseInt(companiesResult[0]?.total || '0');\n\n    // Tasa de conversión (aprobados / total)\n    const conversionRateQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'completed')) as approved,\n        COUNT(*) as total\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const conversionResult = await executeQuery(conversionRateQuery);\n    const approved = parseInt(conversionResult[0]?.approved || '0');\n    const total = parseInt(conversionResult[0]?.total || '0');\n    const conversionRate = total > 0 ? (approved / total) * 100 : 0;\n\n    // Calcular totales específicos para cada estado\n    const totalApprovedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('approved', 'APROBADO', 'completed')\n      ${simulationFilter}\n    `;\n    const totalApprovedResult = await executeQuery(totalApprovedQuery);\n    const totalApproved = parseInt(totalApprovedResult[0]?.count || '0');\n\n    const totalRejectedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('rejected', 'RECHAZADO')\n      ${simulationFilter}\n    `;\n    const totalRejectedResult = await executeQuery(totalRejectedQuery);\n    const totalRejected = parseInt(totalRejectedResult[0]?.count || '0');\n\n    const totalPendingQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('pending', 'PENDIENTE', 'review', 'REVISION')\n      ${simulationFilter}\n    `;\n    const totalPendingResult = await executeQuery(totalPendingQuery);\n    const totalPending = parseInt(totalPendingResult[0]?.count || '0');\n\n    const pendingApprovalQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ${simulationFilter}\n    `;\n    const pendingApprovalResult = await executeQuery(pendingApprovalQuery);\n    const pendingApproval = parseInt(pendingApprovalResult[0]?.pending_approval || '0');\n\n    // Tiempo promedio hasta aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_advisor - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      AND approval_date_advisor IS NOT NULL\n      ${simulationFilter}\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgTimeToApproval = parseFloat(timeResult[0]?.avg_days || '0');\n\n    // Aplicaciones recientes del asesor\n    let recentAdvisorApps = [];\n    try {\n      const recentAdvisorAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${advisorId}'\n        AND application_type = 'selected_plans'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentAdvisorApps = await executeQuery(recentAdvisorAppsQuery);\n      \n      // Asegurarse de que application_type esté presente en todos los registros\n      recentAdvisorApps = recentAdvisorApps.map((app: any) => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes del asesor ${advisorId}:`, error);\n      recentAdvisorApps = [];\n    }\n\n    return {\n      totalApplications: totalAdvisorApplications,\n      applicationsByStatus: advisorApplicationsByStatus,\n      averageAmount: avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications: recentAdvisorApps,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients,\n      totalCompanies,\n      conversionRate,\n      avgTimeToApproval,\n      advisorId,\n      advisorName: '',  // This would be populated from user data\n      pendingApplications: totalPending,\n      approvedApplications: totalApproved,\n      rejectedApplications: totalRejected\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas del asesor ${advisorId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para una empresa\n * @param companyId ID de la empresa\n * @param includeSimulations Si es true, incluye las simulaciones en las estadísticas\n */\nexport const getCompanyDashboardStats = async (companyId: string, includeSimulations: boolean = false): Promise<CompanyStats> => {\n  try {\n    // Filtro para excluir simulaciones por defecto\n    let simulationFilter = '';\n    if (!includeSimulations) {\n      simulationFilter = ` AND application_type != 'product_simulations'`;\n    }\n    \n    // Obtenemos las estadísticas generales primero con el mismo filtro\n    const baseStats = await getGeneralDashboardStats({ companyId, includeSimulations });\n\n    // Estadísticas específicas de la empresa\n    // Total de aplicaciones de la empresa\n    const companyApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n    `;\n    const companyAppResult = await executeQuery(companyApplicationsQuery);\n    const totalCompanyApplications = parseInt(companyAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado de la empresa\n    const companyStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n      GROUP BY status\n    `;\n    const companyStatusResult = await executeQuery(companyStatusQuery);\n    const companyApplicationsByStatus = companyStatusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de asesores asignados a la empresa\n    const advisorsQuery = `\n      SELECT COUNT(DISTINCT assigned_to) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n    `;\n    const advisorsResult = await executeQuery(advisorsQuery);\n    const totalAdvisors = parseInt(advisorsResult[0]?.total || '0');\n\n    // Total de clientes de la empresa\n    const clientNamesQuery = `\n      SELECT COUNT(DISTINCT client_name) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      ${simulationFilter}\n    `;\n    const clientNamesResult = await executeQuery(clientNamesQuery);\n    const totalClientsCompany = parseInt(clientNamesResult[0]?.total || '0');\n\n    // Tiempo promedio de aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_company - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      AND approval_date_company IS NOT NULL\n      ${simulationFilter}\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgApprovalTime = parseFloat(timeResult[0]?.avg_days || '0');\n\n    // Aplicaciones recientes de la empresa\n    let recentCompanyApps = [];\n    try {\n      const recentCompanyAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, assigned_to, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND application_type = 'selected_plans'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentCompanyApps = await executeQuery(recentCompanyAppsQuery);\n      \n      // Asegurarse de que application_type esté presente en todos los registros\n      recentCompanyApps = recentCompanyApps.map((app: any) => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes de la empresa ${companyId}:`, error);\n      // Datos de muestra en caso de error\n      recentCompanyApps = [\n        { id: '1', created_at: new Date().toISOString(), client_name: 'Cliente de Empresa', status: 'pending', amount: '15000', assigned_to: 'Asesor Asignado', application_type: 'selected_plans' }\n      ];\n    }\n\n    return {\n      ...baseStats,\n      totalApplications: totalCompanyApplications,\n      applicationsByStatus: companyApplicationsByStatus,\n      recentApplications: recentCompanyApps,\n      totalAdvisors,\n      totalClientsCompany,\n      avgApprovalTime,\n      pendingApplications: parseInt(baseStats.pendingApplications?.toString() || '0'),\n      applicationsByMonth: Array.isArray(baseStats.applicationsByMonth) \n        ? baseStats.applicationsByMonth \n        : Object.entries(baseStats.applicationsByMonth || {}).map(([month, count]) => ({\n            month,\n            count: Number(count)\n          }))\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas de la empresa ${companyId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas de aplicaciones pendientes de aprobación\n * @param userId ID del usuario (asesor o admin de empresa)\n * @param isCompanyAdmin Indica si el usuario es un admin de empresa\n */\nexport const getPendingApprovalStats = async (userId: string, isCompanyAdmin: boolean): Promise<any> => {\n  try {\n    let query = '';\n    \n    if (isCompanyAdmin) {\n      // Obtener ID de la compañía del admin\n      const companyQuery = `\n        SELECT company_id FROM ${TABLES.COMPANY_ADMINS} WHERE id = '${userId}'\n      `;\n      const companyResult = await executeQuery(companyQuery);\n      const companyId = companyResult[0]?.company_id;\n      \n      if (!companyId) {\n        throw new Error('No se encontró la compañía para este administrador');\n      }\n      \n      // Aplicaciones pendientes de aprobación por la compañía\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND approved_by_advisor = true\n        AND approved_by_company = false\n      `;\n    } else {\n      // Aplicaciones pendientes de aprobación por el asesor\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;\n    }\n    \n    const result = await executeQuery(query);\n    return {\n      pendingCount: parseInt(result[0]?.pending_count || '0')\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas de aprobaciones pendientes:', error);\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}