{"ast":null,"code":"import { TABLES } from '../utils/constants/tables';\nimport { executeQuery } from '../utils/databaseUtils';\n/**\n * Obtiene estadísticas generales para el dashboard\n */\nexport const getGeneralDashboardStats = async () => {\n  try {\n    var _totalAppResult$, _amountResult$, _amountResult$2, _amountResult$3, _totalApprovedResult$, _totalRejectedResult$, _totalPendingResult$, _pendingApprovalResul;\n    // Total de aplicaciones\n    const totalApplicationsQuery = `SELECT COUNT(*) as total FROM ${TABLES.APPLICATIONS}`;\n    const totalAppResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = parseInt(((_totalAppResult$ = totalAppResult[0]) === null || _totalAppResult$ === void 0 ? void 0 : _totalAppResult$.total) || '0');\n\n    // Aplicaciones por estado\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      GROUP BY status\n    `;\n    const statusResult = await executeQuery(applicationsByStatusQuery);\n    const applicationsByStatus = statusResult.map(row => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Estadísticas de montos\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(((_amountResult$ = amountResult[0]) === null || _amountResult$ === void 0 ? void 0 : _amountResult$.avg_amount) || '0');\n    const minAmount = parseFloat(((_amountResult$2 = amountResult[0]) === null || _amountResult$2 === void 0 ? void 0 : _amountResult$2.min_amount) || '0');\n    const maxAmount = parseFloat(((_amountResult$3 = amountResult[0]) === null || _amountResult$3 === void 0 ? void 0 : _amountResult$3.max_amount) || '0');\n\n    // Aplicaciones recientes\n    let recentApplications = [];\n    try {\n      const recentApplicationsQuery = `\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentApplications = await executeQuery(recentApplicationsQuery);\n\n      // Asegurarse de que application_type esté presente en todos los registros\n      recentApplications = recentApplications.map(app => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error('Error al obtener aplicaciones recientes:', error);\n      // Proporcionar datos de muestra si falla la consulta\n      recentApplications = [{\n        id: '1',\n        created_at: new Date().toISOString(),\n        client_name: 'Usuario de Muestra',\n        status: 'pending',\n        amount: '10000',\n        company_name: 'Empresa Ejemplo',\n        application_type: 'selected_plans'\n      }, {\n        id: '2',\n        created_at: new Date().toISOString(),\n        client_name: 'Usuario de Muestra',\n        status: 'approved',\n        amount: '15000',\n        company_name: 'Empresa Ejemplo',\n        application_type: 'product_simulations'\n      }];\n    }\n\n    // Aplicaciones por mes\n    let applicationsByMonth = [];\n    try {\n      const monthlyQuery = `\n        SELECT \n          TO_CHAR(created_at, 'YYYY-MM') as month,\n          COUNT(*) as count\n        FROM ${TABLES.APPLICATIONS}\n        GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n        ORDER BY month\n      `;\n      const monthlyResult = await executeQuery(monthlyQuery);\n      applicationsByMonth = monthlyResult.map(row => ({\n        month: row.month,\n        count: parseInt(row.count)\n      }));\n    } catch (error) {\n      console.error('Error al obtener aplicaciones por mes:', error);\n      applicationsByMonth = [];\n    }\n\n    // Calcular totales por status\n    const totalApprovedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE status IN ('approved', 'APROBADO', 'completed')\n    `;\n    const totalApprovedResult = await executeQuery(totalApprovedQuery);\n    const totalApproved = parseInt(((_totalApprovedResult$ = totalApprovedResult[0]) === null || _totalApprovedResult$ === void 0 ? void 0 : _totalApprovedResult$.count) || '0');\n    const totalRejectedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE status IN ('rejected', 'RECHAZADO')\n    `;\n    const totalRejectedResult = await executeQuery(totalRejectedQuery);\n    const totalRejected = parseInt(((_totalRejectedResult$ = totalRejectedResult[0]) === null || _totalRejectedResult$ === void 0 ? void 0 : _totalRejectedResult$.count) || '0');\n    const totalPendingQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE status IN ('pending', 'PENDIENTE', 'review', 'REVISION')\n    `;\n    const totalPendingResult = await executeQuery(totalPendingQuery);\n    const totalPending = parseInt(((_totalPendingResult$ = totalPendingResult[0]) === null || _totalPendingResult$ === void 0 ? void 0 : _totalPendingResult$.count) || '0');\n    const pendingApprovalQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n    `;\n    const pendingApprovalResult = await executeQuery(pendingApprovalQuery);\n    const pendingApproval = parseInt(((_pendingApprovalResul = pendingApprovalResult[0]) === null || _pendingApprovalResul === void 0 ? void 0 : _pendingApprovalResul.pending_approval) || '0');\n\n    // Total de clientes\n    let totalClients = 0;\n    try {\n      var _clientsResult$;\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS}\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClients = parseInt(((_clientsResult$ = clientsResult[0]) === null || _clientsResult$ === void 0 ? void 0 : _clientsResult$.total) || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        var _clientNamesResult$;\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS}\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClients = parseInt(((_clientNamesResult$ = clientNamesResult[0]) === null || _clientNamesResult$ === void 0 ? void 0 : _clientNamesResult$.total) || '0');\n      } catch (innerError) {\n        console.error('Error counting clients:', innerError);\n        // If that also fails, default to 0\n        totalClients = 0;\n      }\n    }\n    return {\n      totalApplications,\n      applicationsByStatus,\n      avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para un asesor\n * @param advisorId ID del asesor\n */\nexport const getAdvisorDashboardStats = async advisorId => {\n  try {\n    var _advisorAppResult$, _amountResult$4, _amountResult$5, _amountResult$6, _companiesResult$, _conversionResult$, _conversionResult$2, _totalApprovedResult$2, _totalRejectedResult$2, _totalPendingResult$2, _pendingApprovalResul2, _timeResult$;\n    // No obtener estadísticas generales, sino filtrar todo por el asesor\n\n    // Total de aplicaciones del asesor\n    const advisorApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const advisorAppResult = await executeQuery(advisorApplicationsQuery);\n    const totalAdvisorApplications = parseInt(((_advisorAppResult$ = advisorAppResult[0]) === null || _advisorAppResult$ === void 0 ? void 0 : _advisorAppResult$.total) || '0');\n\n    // Aplicaciones por estado del asesor\n    const advisorStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      GROUP BY status\n    `;\n    const advisorStatusResult = await executeQuery(advisorStatusQuery);\n    const advisorApplicationsByStatus = advisorStatusResult.map(row => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Estadísticas de montos específicas del asesor\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n      AND assigned_to = '${advisorId}'\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(((_amountResult$4 = amountResult[0]) === null || _amountResult$4 === void 0 ? void 0 : _amountResult$4.avg_amount) || '0');\n    const minAmount = parseFloat(((_amountResult$5 = amountResult[0]) === null || _amountResult$5 === void 0 ? void 0 : _amountResult$5.min_amount) || '0');\n    const maxAmount = parseFloat(((_amountResult$6 = amountResult[0]) === null || _amountResult$6 === void 0 ? void 0 : _amountResult$6.max_amount) || '0');\n\n    // Calcular aplicaciones por mes para este asesor\n    const monthlyQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month,\n        COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    let applicationsByMonth = [];\n    try {\n      const monthlyResult = await executeQuery(monthlyQuery);\n      applicationsByMonth = monthlyResult.map(row => ({\n        month: row.month,\n        count: parseInt(row.count)\n      }));\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones por mes para asesor ${advisorId}:`, error);\n      applicationsByMonth = [];\n    }\n\n    // Total de clientes del asesor\n    let totalClients = 0;\n    try {\n      var _clientsResult$2;\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE advisor_id = '${advisorId}'\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClients = parseInt(((_clientsResult$2 = clientsResult[0]) === null || _clientsResult$2 === void 0 ? void 0 : _clientsResult$2.total) || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        var _clientNamesResult$2;\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE assigned_to = '${advisorId}'\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClients = parseInt(((_clientNamesResult$2 = clientNamesResult[0]) === null || _clientNamesResult$2 === void 0 ? void 0 : _clientNamesResult$2.total) || '0');\n      } catch (innerError) {\n        console.error(`Error counting clients for advisor ${advisorId}:`, innerError);\n        // If that also fails, default to 0\n        totalClients = 0;\n      }\n    }\n\n    // Total de empresas asignadas al asesor\n    const companiesQuery = `\n      SELECT COUNT(DISTINCT company_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const companiesResult = await executeQuery(companiesQuery);\n    const totalCompanies = parseInt(((_companiesResult$ = companiesResult[0]) === null || _companiesResult$ === void 0 ? void 0 : _companiesResult$.total) || '0');\n\n    // Tasa de conversión (aprobados / total)\n    const conversionRateQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'completed')) as approved,\n        COUNT(*) as total\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const conversionResult = await executeQuery(conversionRateQuery);\n    const approved = parseInt(((_conversionResult$ = conversionResult[0]) === null || _conversionResult$ === void 0 ? void 0 : _conversionResult$.approved) || '0');\n    const total = parseInt(((_conversionResult$2 = conversionResult[0]) === null || _conversionResult$2 === void 0 ? void 0 : _conversionResult$2.total) || '0');\n    const conversionRate = total > 0 ? approved / total * 100 : 0;\n\n    // Calcular totales específicos para cada estado\n    const totalApprovedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('approved', 'APROBADO', 'completed')\n    `;\n    const totalApprovedResult = await executeQuery(totalApprovedQuery);\n    const totalApproved = parseInt(((_totalApprovedResult$2 = totalApprovedResult[0]) === null || _totalApprovedResult$2 === void 0 ? void 0 : _totalApprovedResult$2.count) || '0');\n    const totalRejectedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('rejected', 'RECHAZADO')\n    `;\n    const totalRejectedResult = await executeQuery(totalRejectedQuery);\n    const totalRejected = parseInt(((_totalRejectedResult$2 = totalRejectedResult[0]) === null || _totalRejectedResult$2 === void 0 ? void 0 : _totalRejectedResult$2.count) || '0');\n    const totalPendingQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('pending', 'PENDIENTE', 'review', 'REVISION')\n    `;\n    const totalPendingResult = await executeQuery(totalPendingQuery);\n    const totalPending = parseInt(((_totalPendingResult$2 = totalPendingResult[0]) === null || _totalPendingResult$2 === void 0 ? void 0 : _totalPendingResult$2.count) || '0');\n    const pendingApprovalQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n    `;\n    const pendingApprovalResult = await executeQuery(pendingApprovalQuery);\n    const pendingApproval = parseInt(((_pendingApprovalResul2 = pendingApprovalResult[0]) === null || _pendingApprovalResul2 === void 0 ? void 0 : _pendingApprovalResul2.pending_approval) || '0');\n\n    // Tiempo promedio hasta aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_advisor - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      AND approval_date_advisor IS NOT NULL\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgTimeToApproval = parseFloat(((_timeResult$ = timeResult[0]) === null || _timeResult$ === void 0 ? void 0 : _timeResult$.avg_days) || '0');\n\n    // Aplicaciones recientes del asesor\n    let recentAdvisorApps = [];\n    try {\n      const recentAdvisorAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${advisorId}'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentAdvisorApps = await executeQuery(recentAdvisorAppsQuery);\n\n      // Asegurarse de que application_type esté presente en todos los registros\n      recentAdvisorApps = recentAdvisorApps.map(app => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes del asesor ${advisorId}:`, error);\n      recentAdvisorApps = [];\n    }\n    return {\n      totalApplications: totalAdvisorApplications,\n      applicationsByStatus: advisorApplicationsByStatus,\n      avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications: recentAdvisorApps,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients,\n      totalCompanies,\n      conversionRate,\n      avgTimeToApproval\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas del asesor ${advisorId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para una empresa\n * @param companyId ID de la empresa\n */\nexport const getCompanyDashboardStats = async companyId => {\n  try {\n    var _companyAppResult$, _advisorsResult$, _timeResult$2;\n    // Obtenemos las estadísticas generales primero\n    const baseStats = await getGeneralDashboardStats();\n\n    // Estadísticas específicas de la empresa\n    // Total de aplicaciones de la empresa\n    const companyApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const companyAppResult = await executeQuery(companyApplicationsQuery);\n    const totalCompanyApplications = parseInt(((_companyAppResult$ = companyAppResult[0]) === null || _companyAppResult$ === void 0 ? void 0 : _companyAppResult$.total) || '0');\n\n    // Aplicaciones por estado de la empresa\n    const companyStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      GROUP BY status\n    `;\n    const companyStatusResult = await executeQuery(companyStatusQuery);\n    const companyApplicationsByStatus = companyStatusResult.map(row => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de asesores asignados a la empresa\n    const advisorsQuery = `\n      SELECT COUNT(DISTINCT assigned_to) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const advisorsResult = await executeQuery(advisorsQuery);\n    const totalAdvisors = parseInt(((_advisorsResult$ = advisorsResult[0]) === null || _advisorsResult$ === void 0 ? void 0 : _advisorsResult$.total) || '0');\n\n    // Total de clientes de la empresa\n    let totalClientsCompany = 0;\n    try {\n      var _clientsResult$3;\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE company_id = '${companyId}'\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClientsCompany = parseInt(((_clientsResult$3 = clientsResult[0]) === null || _clientsResult$3 === void 0 ? void 0 : _clientsResult$3.total) || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        var _clientNamesResult$3;\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE company_id = '${companyId}'\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClientsCompany = parseInt(((_clientNamesResult$3 = clientNamesResult[0]) === null || _clientNamesResult$3 === void 0 ? void 0 : _clientNamesResult$3.total) || '0');\n      } catch (innerError) {\n        console.error(`Error counting clients for company ${companyId}:`, innerError);\n        // If that also fails, default to 0\n        totalClientsCompany = 0;\n      }\n    }\n\n    // Tiempo promedio de aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_company - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      AND approval_date_company IS NOT NULL\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgApprovalTime = parseFloat(((_timeResult$2 = timeResult[0]) === null || _timeResult$2 === void 0 ? void 0 : _timeResult$2.avg_days) || '0');\n\n    // Aplicaciones recientes de la empresa\n    let recentCompanyApps = [];\n    try {\n      const recentCompanyAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, assigned_to, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentCompanyApps = await executeQuery(recentCompanyAppsQuery);\n\n      // Asegurarse de que application_type esté presente en todos los registros\n      recentCompanyApps = recentCompanyApps.map(app => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes de la empresa ${companyId}:`, error);\n      // Datos de muestra en caso de error\n      recentCompanyApps = [{\n        id: '1',\n        created_at: new Date().toISOString(),\n        client_name: 'Cliente de Empresa',\n        status: 'pending',\n        amount: '15000',\n        assigned_to: 'Asesor Asignado',\n        application_type: 'selected_plans'\n      }];\n    }\n    return {\n      ...baseStats,\n      totalApplications: totalCompanyApplications,\n      applicationsByStatus: companyApplicationsByStatus,\n      recentApplications: recentCompanyApps,\n      totalAdvisors,\n      totalClientsCompany,\n      avgApprovalTime\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas de la empresa ${companyId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas de aplicaciones pendientes de aprobación\n * @param userId ID del usuario (asesor o admin de empresa)\n * @param isCompanyAdmin Indica si el usuario es un admin de empresa\n */\nexport const getPendingApprovalStats = async (userId, isCompanyAdmin) => {\n  try {\n    var _result$;\n    let query = '';\n    if (isCompanyAdmin) {\n      var _companyResult$;\n      // Obtener ID de la compañía del admin\n      const companyQuery = `\n        SELECT company_id FROM ${TABLES.COMPANY_ADMINS} WHERE id = '${userId}'\n      `;\n      const companyResult = await executeQuery(companyQuery);\n      const companyId = (_companyResult$ = companyResult[0]) === null || _companyResult$ === void 0 ? void 0 : _companyResult$.company_id;\n      if (!companyId) {\n        throw new Error('No se encontró la compañía para este administrador');\n      }\n\n      // Aplicaciones pendientes de aprobación por la compañía\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND approved_by_advisor = true\n        AND approved_by_company = false\n      `;\n    } else {\n      // Aplicaciones pendientes de aprobación por el asesor\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;\n    }\n    const result = await executeQuery(query);\n    return {\n      pendingCount: parseInt(((_result$ = result[0]) === null || _result$ === void 0 ? void 0 : _result$.pending_count) || '0')\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas de aprobaciones pendientes:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["TABLES","executeQuery","getGeneralDashboardStats","_totalAppResult$","_amountResult$","_amountResult$2","_amountResult$3","_totalApprovedResult$","_totalRejectedResult$","_totalPendingResult$","_pendingApprovalResul","totalApplicationsQuery","APPLICATIONS","totalAppResult","totalApplications","parseInt","total","applicationsByStatusQuery","statusResult","applicationsByStatus","map","row","status","count","amountStatsQuery","amountResult","avgAmount","parseFloat","avg_amount","minAmount","min_amount","maxAmount","max_amount","recentApplications","recentApplicationsQuery","app","application_type","toLowerCase","includes","error","console","id","created_at","Date","toISOString","client_name","amount","company_name","applicationsByMonth","monthlyQuery","monthlyResult","month","totalApprovedQuery","totalApprovedResult","totalApproved","totalRejectedQuery","totalRejectedResult","totalRejected","totalPendingQuery","totalPendingResult","totalPending","pendingApprovalQuery","pendingApprovalResult","pendingApproval","pending_approval","totalClients","_clientsResult$","clientsQuery","CLIENTS","clientsResult","_clientNamesResult$","clientNamesQuery","clientNamesResult","innerError","getAdvisorDashboardStats","advisorId","_advisorAppResult$","_amountResult$4","_amountResult$5","_amountResult$6","_companiesResult$","_conversionResult$","_conversionResult$2","_totalApprovedResult$2","_totalRejectedResult$2","_totalPendingResult$2","_pendingApprovalResul2","_timeResult$","advisorApplicationsQuery","advisorAppResult","totalAdvisorApplications","advisorStatusQuery","advisorStatusResult","advisorApplicationsByStatus","_clientsResult$2","_clientNamesResult$2","companiesQuery","companiesResult","totalCompanies","conversionRateQuery","conversionResult","approved","conversionRate","avgTimeQuery","timeResult","avgTimeToApproval","avg_days","recentAdvisorApps","recentAdvisorAppsQuery","getCompanyDashboardStats","companyId","_companyAppResult$","_advisorsResult$","_timeResult$2","baseStats","companyApplicationsQuery","companyAppResult","totalCompanyApplications","companyStatusQuery","companyStatusResult","companyApplicationsByStatus","advisorsQuery","advisorsResult","totalAdvisors","totalClientsCompany","_clientsResult$3","_clientNamesResult$3","avgApprovalTime","recentCompanyApps","recentCompanyAppsQuery","assigned_to","getPendingApprovalStats","userId","isCompanyAdmin","_result$","query","_companyResult$","companyQuery","COMPANY_ADMINS","companyResult","company_id","Error","result","pendingCount","pending_count"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/dashboardService.ts"],"sourcesContent":["import { TABLES } from '../utils/constants/tables';\nimport { executeQuery } from '../utils/databaseUtils';\n\nexport interface DashboardStats {\n  totalApplications: number;\n  applicationsByStatus: {\n    status: string;\n    count: number;\n  }[];\n  avgAmount: number;\n  minAmount: number;\n  maxAmount: number;\n  recentApplications: any[];\n  applicationsByMonth: {\n    month: string;\n    count: number;\n  }[];\n  totalApproved: number;\n  totalRejected: number;\n  totalPending: number;\n  pendingApproval: number;\n  totalClients: number;\n}\n\nexport interface AdvisorStats extends DashboardStats {\n  totalClients: number;\n  totalCompanies: number;\n  conversionRate: number;\n  avgTimeToApproval: number;\n  totalApproved: number;\n  totalRejected: number;\n  totalPending: number;\n  pendingApproval: number;\n  applicationsByMonth: {\n    month: string;\n    count: number;\n  }[];\n}\n\nexport interface CompanyStats extends DashboardStats {\n  totalAdvisors: number;\n  totalClientsCompany: number;\n  avgApprovalTime: number;\n}\n\n/**\n * Obtiene estadísticas generales para el dashboard\n */\nexport const getGeneralDashboardStats = async (): Promise<DashboardStats> => {\n  try {\n    // Total de aplicaciones\n    const totalApplicationsQuery = `SELECT COUNT(*) as total FROM ${TABLES.APPLICATIONS}`;\n    const totalAppResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = parseInt(totalAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      GROUP BY status\n    `;\n    const statusResult = await executeQuery(applicationsByStatusQuery);\n    const applicationsByStatus = statusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Estadísticas de montos\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(amountResult[0]?.avg_amount || '0');\n    const minAmount = parseFloat(amountResult[0]?.min_amount || '0');\n    const maxAmount = parseFloat(amountResult[0]?.max_amount || '0');\n\n    // Aplicaciones recientes\n    let recentApplications = [];\n    try {\n      const recentApplicationsQuery = `\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentApplications = await executeQuery(recentApplicationsQuery);\n      \n      // Asegurarse de que application_type esté presente en todos los registros\n      recentApplications = recentApplications.map((app: any) => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error('Error al obtener aplicaciones recientes:', error);\n      // Proporcionar datos de muestra si falla la consulta\n      recentApplications = [\n        { id: '1', created_at: new Date().toISOString(), client_name: 'Usuario de Muestra', status: 'pending', amount: '10000', company_name: 'Empresa Ejemplo', application_type: 'selected_plans' },\n        { id: '2', created_at: new Date().toISOString(), client_name: 'Usuario de Muestra', status: 'approved', amount: '15000', company_name: 'Empresa Ejemplo', application_type: 'product_simulations' }\n      ];\n    }\n\n    // Aplicaciones por mes\n    let applicationsByMonth: {month: string, count: number}[] = [];\n    try {\n      const monthlyQuery = `\n        SELECT \n          TO_CHAR(created_at, 'YYYY-MM') as month,\n          COUNT(*) as count\n        FROM ${TABLES.APPLICATIONS}\n        GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n        ORDER BY month\n      `;\n      const monthlyResult = await executeQuery(monthlyQuery);\n      applicationsByMonth = monthlyResult.map((row: any) => ({\n        month: row.month,\n        count: parseInt(row.count)\n      }));\n    } catch (error) {\n      console.error('Error al obtener aplicaciones por mes:', error);\n      applicationsByMonth = [];\n    }\n\n    // Calcular totales por status\n    const totalApprovedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE status IN ('approved', 'APROBADO', 'completed')\n    `;\n    const totalApprovedResult = await executeQuery(totalApprovedQuery);\n    const totalApproved = parseInt(totalApprovedResult[0]?.count || '0');\n\n    const totalRejectedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE status IN ('rejected', 'RECHAZADO')\n    `;\n    const totalRejectedResult = await executeQuery(totalRejectedQuery);\n    const totalRejected = parseInt(totalRejectedResult[0]?.count || '0');\n\n    const totalPendingQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE status IN ('pending', 'PENDIENTE', 'review', 'REVISION')\n    `;\n    const totalPendingResult = await executeQuery(totalPendingQuery);\n    const totalPending = parseInt(totalPendingResult[0]?.count || '0');\n\n    const pendingApprovalQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n    `;\n    const pendingApprovalResult = await executeQuery(pendingApprovalQuery);\n    const pendingApproval = parseInt(pendingApprovalResult[0]?.pending_approval || '0');\n\n    // Total de clientes\n    let totalClients = 0;\n    try {\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS}\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClients = parseInt(clientsResult[0]?.total || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS}\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClients = parseInt(clientNamesResult[0]?.total || '0');\n      } catch (innerError) {\n        console.error('Error counting clients:', innerError);\n        // If that also fails, default to 0\n        totalClients = 0;\n      }\n    }\n\n    return {\n      totalApplications,\n      applicationsByStatus,\n      avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para un asesor\n * @param advisorId ID del asesor\n */\nexport const getAdvisorDashboardStats = async (advisorId: string): Promise<AdvisorStats> => {\n  try {\n    // No obtener estadísticas generales, sino filtrar todo por el asesor\n    \n    // Total de aplicaciones del asesor\n    const advisorApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const advisorAppResult = await executeQuery(advisorApplicationsQuery);\n    const totalAdvisorApplications = parseInt(advisorAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado del asesor\n    const advisorStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      GROUP BY status\n    `;\n    const advisorStatusResult = await executeQuery(advisorStatusQuery);\n    const advisorApplicationsByStatus = advisorStatusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Estadísticas de montos específicas del asesor\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n      AND assigned_to = '${advisorId}'\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(amountResult[0]?.avg_amount || '0');\n    const minAmount = parseFloat(amountResult[0]?.min_amount || '0');\n    const maxAmount = parseFloat(amountResult[0]?.max_amount || '0');\n\n    // Calcular aplicaciones por mes para este asesor\n    const monthlyQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month,\n        COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    \n    let applicationsByMonth: {month: string, count: number}[] = [];\n    try {\n      const monthlyResult = await executeQuery(monthlyQuery);\n      applicationsByMonth = monthlyResult.map((row: any) => ({\n        month: row.month,\n        count: parseInt(row.count)\n      }));\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones por mes para asesor ${advisorId}:`, error);\n      applicationsByMonth = [];\n    }\n\n    // Total de clientes del asesor\n    let totalClients = 0;\n    try {\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE advisor_id = '${advisorId}'\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClients = parseInt(clientsResult[0]?.total || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE assigned_to = '${advisorId}'\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClients = parseInt(clientNamesResult[0]?.total || '0');\n      } catch (innerError) {\n        console.error(`Error counting clients for advisor ${advisorId}:`, innerError);\n        // If that also fails, default to 0\n        totalClients = 0;\n      }\n    }\n\n    // Total de empresas asignadas al asesor\n    const companiesQuery = `\n      SELECT COUNT(DISTINCT company_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const companiesResult = await executeQuery(companiesQuery);\n    const totalCompanies = parseInt(companiesResult[0]?.total || '0');\n\n    // Tasa de conversión (aprobados / total)\n    const conversionRateQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'completed')) as approved,\n        COUNT(*) as total\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const conversionResult = await executeQuery(conversionRateQuery);\n    const approved = parseInt(conversionResult[0]?.approved || '0');\n    const total = parseInt(conversionResult[0]?.total || '0');\n    const conversionRate = total > 0 ? (approved / total) * 100 : 0;\n\n    // Calcular totales específicos para cada estado\n    const totalApprovedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('approved', 'APROBADO', 'completed')\n    `;\n    const totalApprovedResult = await executeQuery(totalApprovedQuery);\n    const totalApproved = parseInt(totalApprovedResult[0]?.count || '0');\n\n    const totalRejectedQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('rejected', 'RECHAZADO')\n    `;\n    const totalRejectedResult = await executeQuery(totalRejectedQuery);\n    const totalRejected = parseInt(totalRejectedResult[0]?.count || '0');\n\n    const totalPendingQuery = `\n      SELECT COUNT(*) as count\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      AND status IN ('pending', 'PENDIENTE', 'review', 'REVISION')\n    `;\n    const totalPendingResult = await executeQuery(totalPendingQuery);\n    const totalPending = parseInt(totalPendingResult[0]?.count || '0');\n\n    const pendingApprovalQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n    `;\n    const pendingApprovalResult = await executeQuery(pendingApprovalQuery);\n    const pendingApproval = parseInt(pendingApprovalResult[0]?.pending_approval || '0');\n\n    // Tiempo promedio hasta aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_advisor - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      AND approval_date_advisor IS NOT NULL\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgTimeToApproval = parseFloat(timeResult[0]?.avg_days || '0');\n\n    // Aplicaciones recientes del asesor\n    let recentAdvisorApps = [];\n    try {\n      const recentAdvisorAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${advisorId}'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentAdvisorApps = await executeQuery(recentAdvisorAppsQuery);\n      \n      // Asegurarse de que application_type esté presente en todos los registros\n      recentAdvisorApps = recentAdvisorApps.map((app: any) => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes del asesor ${advisorId}:`, error);\n      recentAdvisorApps = [];\n    }\n\n    return {\n      totalApplications: totalAdvisorApplications,\n      applicationsByStatus: advisorApplicationsByStatus,\n      avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications: recentAdvisorApps,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients,\n      totalCompanies,\n      conversionRate,\n      avgTimeToApproval\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas del asesor ${advisorId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para una empresa\n * @param companyId ID de la empresa\n */\nexport const getCompanyDashboardStats = async (companyId: string): Promise<CompanyStats> => {\n  try {\n    // Obtenemos las estadísticas generales primero\n    const baseStats = await getGeneralDashboardStats();\n\n    // Estadísticas específicas de la empresa\n    // Total de aplicaciones de la empresa\n    const companyApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const companyAppResult = await executeQuery(companyApplicationsQuery);\n    const totalCompanyApplications = parseInt(companyAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado de la empresa\n    const companyStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      GROUP BY status\n    `;\n    const companyStatusResult = await executeQuery(companyStatusQuery);\n    const companyApplicationsByStatus = companyStatusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de asesores asignados a la empresa\n    const advisorsQuery = `\n      SELECT COUNT(DISTINCT assigned_to) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const advisorsResult = await executeQuery(advisorsQuery);\n    const totalAdvisors = parseInt(advisorsResult[0]?.total || '0');\n\n    // Total de clientes de la empresa\n    let totalClientsCompany = 0;\n    try {\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE company_id = '${companyId}'\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClientsCompany = parseInt(clientsResult[0]?.total || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE company_id = '${companyId}'\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClientsCompany = parseInt(clientNamesResult[0]?.total || '0');\n      } catch (innerError) {\n        console.error(`Error counting clients for company ${companyId}:`, innerError);\n        // If that also fails, default to 0\n        totalClientsCompany = 0;\n      }\n    }\n\n    // Tiempo promedio de aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_company - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      AND approval_date_company IS NOT NULL\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgApprovalTime = parseFloat(timeResult[0]?.avg_days || '0');\n\n    // Aplicaciones recientes de la empresa\n    let recentCompanyApps = [];\n    try {\n      const recentCompanyAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, assigned_to, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentCompanyApps = await executeQuery(recentCompanyAppsQuery);\n      \n      // Asegurarse de que application_type esté presente en todos los registros\n      recentCompanyApps = recentCompanyApps.map((app: any) => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes de la empresa ${companyId}:`, error);\n      // Datos de muestra en caso de error\n      recentCompanyApps = [\n        { id: '1', created_at: new Date().toISOString(), client_name: 'Cliente de Empresa', status: 'pending', amount: '15000', assigned_to: 'Asesor Asignado', application_type: 'selected_plans' }\n      ];\n    }\n\n    return {\n      ...baseStats,\n      totalApplications: totalCompanyApplications,\n      applicationsByStatus: companyApplicationsByStatus,\n      recentApplications: recentCompanyApps,\n      totalAdvisors,\n      totalClientsCompany,\n      avgApprovalTime\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas de la empresa ${companyId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas de aplicaciones pendientes de aprobación\n * @param userId ID del usuario (asesor o admin de empresa)\n * @param isCompanyAdmin Indica si el usuario es un admin de empresa\n */\nexport const getPendingApprovalStats = async (userId: string, isCompanyAdmin: boolean): Promise<any> => {\n  try {\n    let query = '';\n    \n    if (isCompanyAdmin) {\n      // Obtener ID de la compañía del admin\n      const companyQuery = `\n        SELECT company_id FROM ${TABLES.COMPANY_ADMINS} WHERE id = '${userId}'\n      `;\n      const companyResult = await executeQuery(companyQuery);\n      const companyId = companyResult[0]?.company_id;\n      \n      if (!companyId) {\n        throw new Error('No se encontró la compañía para este administrador');\n      }\n      \n      // Aplicaciones pendientes de aprobación por la compañía\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND approved_by_advisor = true\n        AND approved_by_company = false\n      `;\n    } else {\n      // Aplicaciones pendientes de aprobación por el asesor\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;\n    }\n    \n    const result = await executeQuery(query);\n    return {\n      pendingCount: parseInt(result[0]?.pending_count || '0')\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas de aprobaciones pendientes:', error);\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}