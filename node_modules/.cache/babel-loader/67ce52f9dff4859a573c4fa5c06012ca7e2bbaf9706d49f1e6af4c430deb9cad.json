{"ast":null,"code":"import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Get all documents for an application\nexport const getApplicationDocuments = async applicationId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('application_id', applicationId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async clientId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('client_id', clientId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async id => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('id', id).single();\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Upload a document\nexport const uploadDocument = async upload => {\n  const {\n    file,\n    application_id,\n    client_id,\n    userId,\n    documentName,\n    description,\n    category\n  } = upload;\n  if (!application_id && !client_id) {\n    throw new Error(\"Either application_id or client_id must be provided\");\n  }\n\n  // Generate a unique file path\n  const timestamp = new Date().getTime();\n  const fileExtension = file.name.split('.').pop();\n  const prefix = application_id ? `applications/${application_id}` : `clients/${client_id}`;\n  const filePath = `${prefix}/${timestamp}-${file.name}`;\n\n  // Upload file to storage\n  const {\n    data: storageData,\n    error: storageError\n  } = await supabase.storage.from(STORAGE_BUCKET).upload(filePath, file, {\n    cacheControl: '3600',\n    upsert: false\n  });\n  if (storageError) {\n    console.error('Error uploading file:', storageError);\n    throw storageError;\n  }\n\n  // Create document record in database\n  const documentRecord = {\n    file_name: documentName,\n    file_path: filePath,\n    file_type: file.type,\n    file_size: file.size,\n    uploaded_by_user_id: userId,\n    category\n  };\n  if (application_id) {\n    Object.assign(documentRecord, {\n      application_id\n    });\n  }\n  if (client_id) {\n    Object.assign(documentRecord, {\n      client_id\n    });\n  }\n  if (description) {\n    Object.assign(documentRecord, {\n      description\n    });\n  }\n  const {\n    data: documentData,\n    error: documentError\n  } = await supabase.from(DOCUMENTS_TABLE).insert([documentRecord]).select();\n  if (documentError) {\n    console.error('Error creating document record:', documentError);\n\n    // Delete the uploaded file if document record creation failed\n    await supabase.storage.from(STORAGE_BUCKET).remove([filePath]);\n    throw documentError;\n  }\n  return documentData[0];\n};\n\n// Delete a document\nexport const deleteDocument = async documentId => {\n  // Get document to get file path\n  const {\n    data: document,\n    error: fetchError\n  } = await supabase.from(DOCUMENTS_TABLE).select('file_path').eq('id', documentId).single();\n  if (fetchError) {\n    console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n    throw fetchError;\n  }\n\n  // Delete file from storage\n  const {\n    error: storageError\n  } = await supabase.storage.from(STORAGE_BUCKET).remove([document.file_path]);\n  if (storageError) {\n    console.error(`Error deleting file for document ${documentId}:`, storageError);\n    throw storageError;\n  }\n\n  // Delete document record\n  const {\n    error: deleteError\n  } = await supabase.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n  if (deleteError) {\n    console.error(`Error deleting document record ${documentId}:`, deleteError);\n    throw deleteError;\n  }\n  return true;\n};\n\n// Get document download URL\nexport const getDocumentUrl = async filePath => {\n  const {\n    data,\n    error\n  } = await supabase.storage.from(STORAGE_BUCKET).createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n  if (error) {\n    console.error(`Error getting URL for document ${filePath}:`, error);\n    throw error;\n  }\n  return data.signedUrl;\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId, userId, isVerified = true) => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).update({\n    is_verified: isVerified,\n    verified_by: userId,\n    verified_at: new Date().toISOString()\n  }).eq('id', documentId).select();\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n  return data[0];\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async applicationType => {\n  const {\n    data,\n    error\n  } = await supabase.from('required_documents').select('*').eq('application_type', applicationType);\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n  return data;\n};","map":{"version":3,"names":["supabase","TABLES","DOCUMENTS_TABLE","DOCUMENTS","STORAGE_BUCKET","getApplicationDocuments","applicationId","data","error","from","select","eq","order","ascending","console","getClientDocuments","clientId","getDocumentById","id","single","uploadDocument","upload","file","application_id","client_id","userId","documentName","description","category","Error","timestamp","Date","getTime","fileExtension","name","split","pop","prefix","filePath","storageData","storageError","storage","cacheControl","upsert","documentRecord","file_name","file_path","file_type","type","file_size","size","uploaded_by_user_id","Object","assign","documentData","documentError","insert","remove","deleteDocument","documentId","document","fetchError","deleteError","delete","getDocumentUrl","createSignedUrl","signedUrl","verifyDocument","isVerified","update","is_verified","verified_by","verified_at","toISOString","getRequiredDocuments","applicationType"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/documentService.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\n\nexport interface Document {\n  id: string;\n  created_at: string;\n  file_name: string;\n  file_path: string;\n  file_type: string;\n  file_size: number;\n  category?: string;\n  application_id?: string;\n  client_id?: string;\n  uploaded_by_user_id?: string;\n  is_verified?: boolean;\n  verified_by?: string;\n  verified_at?: string;\n}\n\nexport interface DocumentUpload {\n  file: File;\n  application_id?: string;\n  client_id?: string;\n  userId: string;\n  documentName: string;\n  description?: string;\n  category?: string;\n}\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Get all documents for an application\nexport const getApplicationDocuments = async (applicationId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('application_id', applicationId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async (clientId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('client_id', clientId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async (id: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n\n  return data as Document;\n};\n\n// Upload a document\nexport const uploadDocument = async (upload: DocumentUpload) => {\n  const { file, application_id, client_id, userId, documentName, description, category } = upload;\n  \n  if (!application_id && !client_id) {\n    throw new Error(\"Either application_id or client_id must be provided\");\n  }\n  \n  // Generate a unique file path\n  const timestamp = new Date().getTime();\n  const fileExtension = file.name.split('.').pop();\n  const prefix = application_id ? `applications/${application_id}` : `clients/${client_id}`;\n  const filePath = `${prefix}/${timestamp}-${file.name}`;\n\n  // Upload file to storage\n  const { data: storageData, error: storageError } = await supabase.storage\n    .from(STORAGE_BUCKET)\n    .upload(filePath, file, {\n      cacheControl: '3600',\n      upsert: false\n    });\n\n  if (storageError) {\n    console.error('Error uploading file:', storageError);\n    throw storageError;\n  }\n\n  // Create document record in database\n  const documentRecord = {\n    file_name: documentName,\n    file_path: filePath,\n    file_type: file.type,\n    file_size: file.size,\n    uploaded_by_user_id: userId,\n    category\n  };\n  \n  if (application_id) {\n    Object.assign(documentRecord, { application_id });\n  }\n  \n  if (client_id) {\n    Object.assign(documentRecord, { client_id });\n  }\n  \n  if (description) {\n    Object.assign(documentRecord, { description });\n  }\n\n  const { data: documentData, error: documentError } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .insert([documentRecord])\n    .select();\n\n  if (documentError) {\n    console.error('Error creating document record:', documentError);\n    \n    // Delete the uploaded file if document record creation failed\n    await supabase.storage\n      .from(STORAGE_BUCKET)\n      .remove([filePath]);\n      \n    throw documentError;\n  }\n\n  return documentData[0] as Document;\n};\n\n// Delete a document\nexport const deleteDocument = async (documentId: string) => {\n  // Get document to get file path\n  const { data: document, error: fetchError } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('file_path')\n    .eq('id', documentId)\n    .single();\n\n  if (fetchError) {\n    console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n    throw fetchError;\n  }\n\n  // Delete file from storage\n  const { error: storageError } = await supabase.storage\n    .from(STORAGE_BUCKET)\n    .remove([document.file_path]);\n\n  if (storageError) {\n    console.error(`Error deleting file for document ${documentId}:`, storageError);\n    throw storageError;\n  }\n\n  // Delete document record\n  const { error: deleteError } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .delete()\n    .eq('id', documentId);\n\n  if (deleteError) {\n    console.error(`Error deleting document record ${documentId}:`, deleteError);\n    throw deleteError;\n  }\n\n  return true;\n};\n\n// Get document download URL\nexport const getDocumentUrl = async (filePath: string) => {\n  const { data, error } = await supabase.storage\n    .from(STORAGE_BUCKET)\n    .createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n  if (error) {\n    console.error(`Error getting URL for document ${filePath}:`, error);\n    throw error;\n  }\n\n  return data.signedUrl;\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId: string, userId: string, isVerified: boolean = true) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .update({\n      is_verified: isVerified,\n      verified_by: userId,\n      verified_at: new Date().toISOString()\n    })\n    .eq('id', documentId)\n    .select();\n\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n\n  return data[0] as Document;\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async (applicationType: string) => {\n  const { data, error } = await supabase\n    .from('required_documents')\n    .select('*')\n    .eq('application_type', applicationType);\n\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n\n  return data;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}