{"ast":null,"code":"import{executeQuery}from'../utils/databaseUtils';import{TABLES}from'../utils/constants/tables';// Nombre de la tabla definido como constante para evitar errores de escritura\nconst CLIENTS_TABLE=TABLES.CLIENTS||'clients';// Get all clients with filters\nexport const getClients=async filters=>{try{// Construir la consulta base\nlet query=`SELECT * FROM ${CLIENTS_TABLE} WHERE 1=1`;// Crear una consulta para el conteo total filtrado\nlet countQuery=`SELECT COUNT(*) as total FROM ${CLIENTS_TABLE} WHERE 1=1`;// Aplicar filtros si existen\nif(filters){let filterClause='';// Filtro por búsqueda\nif(filters.searchQuery){filterClause+=` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;}// Filtro por asesor\nif(filters.advisor_id){filterClause+=` AND advisor_id = '${filters.advisor_id}'`;}// Filtro por empresa\nif(filters.company_id){filterClause+=` AND company_id = '${filters.company_id}'`;}// Filtro por fecha\nif(filters.dateFrom){filterClause+=` AND created_at >= '${filters.dateFrom}'`;}if(filters.dateTo){filterClause+=` AND created_at <= '${filters.dateTo}'`;}// Aplicar los mismos filtros a ambas consultas\nquery+=filterClause;countQuery+=filterClause;}// Agregar ordenamiento\nquery+=` ORDER BY created_at DESC`;// Agregar paginación si se especifica\nif((filters===null||filters===void 0?void 0:filters.page)!==undefined&&filters!==null&&filters!==void 0&&filters.pageSize){const offset=filters.page*filters.pageSize;query+=` LIMIT ${filters.pageSize} OFFSET ${offset}`;}// Ejecutar las consultas\nconst clients=await executeQuery(query);const totalCountResult=await executeQuery(countQuery);// Extraer el valor del conteo total\nconst totalCount=totalCountResult&&totalCountResult.length>0?parseInt(totalCountResult[0].total):0;// Devolver un objeto con clients y totalCount\nreturn{clients:clients||[],totalCount};}catch(error){console.error('Error al obtener clientes:',error);// Si la tabla no existe o hay otro error, devolver un objeto con arrays vacíos\nreturn{clients:[],totalCount:0};}};// Get a single client by ID\nexport const getClientById=async id=>{try{const query=`SELECT * FROM ${CLIENTS_TABLE} WHERE id = '${id}'`;const data=await executeQuery(query);if(data&&data.length>0){return data[0];}throw new Error('Cliente no encontrado');}catch(error){console.error(`Error al obtener cliente con ID ${id}:`,error);throw error;}};/**\n * Escapa caracteres especiales en cadenas SQL\n */function escapeSQLString(str){return str.replace(/'/g,\"''\");}// Get applications for a specific client\nexport const getClientApplications=async clientId=>{try{const query=`\n      SELECT * FROM ${TABLES.APPLICATIONS} \n      WHERE client_id = '${clientId}' OR source_id = '${clientId}'\n      ORDER BY created_at DESC\n    `;return await executeQuery(query);}catch(error){console.error(`Error al obtener aplicaciones del cliente ${clientId}:`,error);throw error;}};// Create a new client\nexport const createClient=async client=>{try{// Construir lista de campos y valores\nconst fields=Object.keys(client).join(', ');const values=Object.values(client).map(value=>typeof value==='string'?`'${escapeSQLString(value)}'`:value).join(', ');const query=`\n      INSERT INTO ${CLIENTS_TABLE} (${fields})\n      VALUES (${values})\n      RETURNING *\n    `;const data=await executeQuery(query);if(data&&data.length>0){return data[0];}throw new Error('Error al crear el cliente');}catch(error){console.error('Error al crear cliente:',error);throw error;}};// Update an existing client\nexport const updateClient=async(id,updates)=>{try{// Construir lista de cambios\nconst setClause=Object.entries(updates).map(_ref=>{let[key,value]=_ref;return`${key} = ${typeof value==='string'?`'${escapeSQLString(value)}'`:value}`;}).join(', ');const query=`\n      UPDATE ${CLIENTS_TABLE}\n      SET ${setClause}\n      WHERE id = '${id}'\n      RETURNING *\n    `;const data=await executeQuery(query);if(data&&data.length>0){return data[0];}throw new Error('Cliente no encontrado');}catch(error){console.error(`Error al actualizar cliente con ID ${id}:`,error);throw error;}};// Delete a client\nexport const deleteClient=async id=>{try{const query=`\n      DELETE FROM ${CLIENTS_TABLE}\n      WHERE id = '${id}'\n      RETURNING id\n    `;const data=await executeQuery(query);if(data&&data.length>0){return true;}throw new Error('Cliente no encontrado');}catch(error){console.error(`Error al eliminar cliente con ID ${id}:`,error);throw error;}};// Check if a client with the given email or RFC already exists\nexport const checkClientExists=async(email,rfc)=>{try{let query=`\n      SELECT id, email, rfc FROM ${CLIENTS_TABLE}\n      WHERE email = '${escapeSQLString(email)}'\n    `;if(rfc){query+=` OR rfc = '${escapeSQLString(rfc)}'`;}const data=await executeQuery(query);if(data&&data.length>0){return{exists:true,client:data[0]};}return{exists:false};}catch(error){console.error('Error al verificar existencia de cliente:',error);throw error;}};// Get total count of clients with filters\nexport const getClientCount=async filters=>{try{let query=`SELECT COUNT(*) as count FROM ${CLIENTS_TABLE} WHERE 1=1`;// Aplicar filtros si existen\nif(filters){// Filtro por búsqueda\nif(filters.searchQuery){query+=` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;}// Filtro por asesor\nif(filters.advisor_id){query+=` AND advisor_id = '${filters.advisor_id}'`;}// Filtro por empresa\nif(filters.company_id){query+=` AND company_id = '${filters.company_id}'`;}}const data=await executeQuery(query);if(data&&data.length>0){return parseInt(data[0].count)||0;}return 0;}catch(error){console.error('Error al obtener conteo de clientes:',error);return 0;}};","map":{"version":3,"names":["executeQuery","TABLES","CLIENTS_TABLE","CLIENTS","getClients","filters","query","countQuery","filterClause","searchQuery","advisor_id","company_id","dateFrom","dateTo","page","undefined","pageSize","offset","clients","totalCountResult","totalCount","length","parseInt","total","error","console","getClientById","id","data","Error","escapeSQLString","str","replace","getClientApplications","clientId","APPLICATIONS","createClient","client","fields","Object","keys","join","values","map","value","updateClient","updates","setClause","entries","_ref","key","deleteClient","checkClientExists","email","rfc","exists","getClientCount","count"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/clientService.ts"],"sourcesContent":["import { executeQuery } from '../utils/databaseUtils';\nimport { TABLES } from '../utils/constants/tables';\n\nexport interface Client {\n  id: string;\n  created_at: string;\n  name: string;\n  email: string;\n  phone: string;\n  address?: string;\n  city?: string;\n  state?: string;\n  postal_code?: string;\n  birth_date?: string;\n  rfc?: string;\n  curp?: string;\n  company_id?: string;\n  advisor_id?: string;\n}\n\nexport interface ClientFilter {\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n  page?: number;\n  pageSize?: number;\n}\n\nexport interface ClientResult {\n  clients: Client[];\n  totalCount: number;\n}\n\n// Nombre de la tabla definido como constante para evitar errores de escritura\nconst CLIENTS_TABLE = TABLES.CLIENTS || 'clients';\n\n// Get all clients with filters\nexport const getClients = async (filters?: ClientFilter): Promise<ClientResult> => {\n  try {\n    // Construir la consulta base\n    let query = `SELECT * FROM ${CLIENTS_TABLE} WHERE 1=1`;\n\n    // Crear una consulta para el conteo total filtrado\n    let countQuery = `SELECT COUNT(*) as total FROM ${CLIENTS_TABLE} WHERE 1=1`;\n\n    // Aplicar filtros si existen\n    if (filters) {\n      let filterClause = '';\n      \n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        filterClause += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n\n      // Filtro por asesor\n      if (filters.advisor_id) {\n        filterClause += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n\n      // Filtro por empresa\n      if (filters.company_id) {\n        filterClause += ` AND company_id = '${filters.company_id}'`;\n      }\n\n      // Filtro por fecha\n      if (filters.dateFrom) {\n        filterClause += ` AND created_at >= '${filters.dateFrom}'`;\n      }\n      if (filters.dateTo) {\n        filterClause += ` AND created_at <= '${filters.dateTo}'`;\n      }\n      \n      // Aplicar los mismos filtros a ambas consultas\n      query += filterClause;\n      countQuery += filterClause;\n    }\n\n    // Agregar ordenamiento\n    query += ` ORDER BY created_at DESC`;\n\n    // Agregar paginación si se especifica\n    if (filters?.page !== undefined && filters?.pageSize) {\n      const offset = filters.page * filters.pageSize;\n      query += ` LIMIT ${filters.pageSize} OFFSET ${offset}`;\n    }\n\n    // Ejecutar las consultas\n    const clients = await executeQuery(query);\n    const totalCountResult = await executeQuery(countQuery);\n    \n    // Extraer el valor del conteo total\n    const totalCount = totalCountResult && totalCountResult.length > 0 \n      ? parseInt(totalCountResult[0].total) \n      : 0;\n    \n    // Devolver un objeto con clients y totalCount\n    return {\n      clients: clients || [],\n      totalCount\n    };\n  } catch (error) {\n    console.error('Error al obtener clientes:', error);\n    // Si la tabla no existe o hay otro error, devolver un objeto con arrays vacíos\n    return {\n      clients: [],\n      totalCount: 0\n    };\n  }\n};\n\n// Get a single client by ID\nexport const getClientById = async (id: string) => {\n  try {\n    const query = `SELECT * FROM ${CLIENTS_TABLE} WHERE id = '${id}'`;\n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return data[0] as Client;\n    }\n    \n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al obtener cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Escapa caracteres especiales en cadenas SQL\n */\nfunction escapeSQLString(str: string) {\n  return str.replace(/'/g, \"''\");\n}\n\n// Get applications for a specific client\nexport const getClientApplications = async (clientId: string) => {\n  try {\n    const query = `\n      SELECT * FROM ${TABLES.APPLICATIONS} \n      WHERE client_id = '${clientId}' OR source_id = '${clientId}'\n      ORDER BY created_at DESC\n    `;\n    \n    return await executeQuery(query);\n  } catch (error) {\n    console.error(`Error al obtener aplicaciones del cliente ${clientId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new client\nexport const createClient = async (client: Omit<Client, 'id' | 'created_at'>) => {\n  try {\n    // Construir lista de campos y valores\n    const fields = Object.keys(client).join(', ');\n    const values = Object.values(client)\n      .map(value => typeof value === 'string' ? `'${escapeSQLString(value)}'` : value)\n      .join(', ');\n    \n    const query = `\n      INSERT INTO ${CLIENTS_TABLE} (${fields})\n      VALUES (${values})\n      RETURNING *\n    `;\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return data[0] as Client;\n    }\n    \n    throw new Error('Error al crear el cliente');\n  } catch (error) {\n    console.error('Error al crear cliente:', error);\n    throw error;\n  }\n};\n\n// Update an existing client\nexport const updateClient = async (id: string, updates: Partial<Client>) => {\n  try {\n    // Construir lista de cambios\n    const setClause = Object.entries(updates)\n      .map(([key, value]) => \n        `${key} = ${typeof value === 'string' ? `'${escapeSQLString(value)}'` : value}`\n      )\n      .join(', ');\n    \n    const query = `\n      UPDATE ${CLIENTS_TABLE}\n      SET ${setClause}\n      WHERE id = '${id}'\n      RETURNING *\n    `;\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return data[0] as Client;\n    }\n    \n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al actualizar cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Delete a client\nexport const deleteClient = async (id: string) => {\n  try {\n    const query = `\n      DELETE FROM ${CLIENTS_TABLE}\n      WHERE id = '${id}'\n      RETURNING id\n    `;\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return true;\n    }\n    \n    throw new Error('Cliente no encontrado');\n  } catch (error) {\n    console.error(`Error al eliminar cliente con ID ${id}:`, error);\n    throw error;\n  }\n};\n\n// Check if a client with the given email or RFC already exists\nexport const checkClientExists = async (email: string, rfc?: string) => {\n  try {\n    let query = `\n      SELECT id, email, rfc FROM ${CLIENTS_TABLE}\n      WHERE email = '${escapeSQLString(email)}'\n    `;\n    \n    if (rfc) {\n      query += ` OR rfc = '${escapeSQLString(rfc)}'`;\n    }\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return {\n        exists: true,\n        client: data[0]\n      };\n    }\n    \n    return { exists: false };\n  } catch (error) {\n    console.error('Error al verificar existencia de cliente:', error);\n    throw error;\n  }\n};\n\n// Get total count of clients with filters\nexport const getClientCount = async (filters?: ClientFilter) => {\n  try {\n    let query = `SELECT COUNT(*) as count FROM ${CLIENTS_TABLE} WHERE 1=1`;\n    \n    // Aplicar filtros si existen\n    if (filters) {\n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        query += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n      \n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n      \n      // Filtro por empresa\n      if (filters.company_id) {\n        query += ` AND company_id = '${filters.company_id}'`;\n      }\n    }\n    \n    const data = await executeQuery(query);\n    \n    if (data && data.length > 0) {\n      return parseInt(data[0].count) || 0;\n    }\n    \n    return 0;\n  } catch (error) {\n    console.error('Error al obtener conteo de clientes:', error);\n    return 0;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}