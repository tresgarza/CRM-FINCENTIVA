{"ast":null,"code":"import { TABLES } from '../utils/constants/tables';\nimport { executeQuery } from '../utils/databaseUtils';\n/**\n * Obtiene estadísticas generales para el dashboard\n */\nexport const getGeneralDashboardStats = async () => {\n  try {\n    var _totalAppResult$, _amountResult$, _amountResult$2, _amountResult$3, _categoryResult$, _categoryResult$2, _categoryResult$3, _categoryResult$4, _totalClientsResult$;\n    // Total de aplicaciones\n    const totalApplicationsQuery = `SELECT COUNT(*) as total FROM ${TABLES.APPLICATIONS}`;\n    const totalAppResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = parseInt(((_totalAppResult$ = totalAppResult[0]) === null || _totalAppResult$ === void 0 ? void 0 : _totalAppResult$.total) || '0');\n\n    // Aplicaciones por estado\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      GROUP BY status\n    `;\n    const statusResult = await executeQuery(applicationsByStatusQuery);\n    const applicationsByStatus = statusResult.map(row => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Estadísticas de montos\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(((_amountResult$ = amountResult[0]) === null || _amountResult$ === void 0 ? void 0 : _amountResult$.avg_amount) || '0');\n    const minAmount = parseFloat(((_amountResult$2 = amountResult[0]) === null || _amountResult$2 === void 0 ? void 0 : _amountResult$2.min_amount) || '0');\n    const maxAmount = parseFloat(((_amountResult$3 = amountResult[0]) === null || _amountResult$3 === void 0 ? void 0 : _amountResult$3.max_amount) || '0');\n\n    // Aplicaciones recientes\n    const recentApplicationsQuery = `\n      SELECT id, created_at, client_name, status, amount, company_name\n      FROM ${TABLES.APPLICATIONS}\n      ORDER BY created_at DESC\n      LIMIT 10\n    `;\n    const recentApplications = await executeQuery(recentApplicationsQuery);\n\n    // Aplicaciones por mes (últimos 6 meses)\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE created_at >= NOW() - INTERVAL '6 months'\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    const monthResult = await executeQuery(applicationsByMonthQuery);\n    const applicationsByMonth = monthResult.map(row => ({\n      month: row.month,\n      count: parseInt(row.count)\n    }));\n\n    // Totales por categoría principal\n    const totalByMajorCategoryQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'Aprobado por Asesor')) as approved,\n        COUNT(*) FILTER (WHERE status IN ('rejected', 'RECHAZADO')) as rejected,\n        COUNT(*) FILTER (WHERE status IN ('pending', 'new', 'Solicitud', 'Simulación')) as pending,\n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n    `;\n    const categoryResult = await executeQuery(totalByMajorCategoryQuery);\n    const totalApproved = parseInt(((_categoryResult$ = categoryResult[0]) === null || _categoryResult$ === void 0 ? void 0 : _categoryResult$.approved) || '0');\n    const totalRejected = parseInt(((_categoryResult$2 = categoryResult[0]) === null || _categoryResult$2 === void 0 ? void 0 : _categoryResult$2.rejected) || '0');\n    const totalPending = parseInt(((_categoryResult$3 = categoryResult[0]) === null || _categoryResult$3 === void 0 ? void 0 : _categoryResult$3.pending) || '0');\n    const pendingApproval = parseInt(((_categoryResult$4 = categoryResult[0]) === null || _categoryResult$4 === void 0 ? void 0 : _categoryResult$4.pending_approval) || '0');\n\n    // Total clients\n    const totalClientsQuery = `SELECT COUNT(*) as total FROM ${TABLES.CLIENTS}`;\n    const totalClientsResult = await executeQuery(totalClientsQuery);\n    const totalClients = parseInt(((_totalClientsResult$ = totalClientsResult[0]) === null || _totalClientsResult$ === void 0 ? void 0 : _totalClientsResult$.total) || '0');\n    return {\n      totalApplications,\n      applicationsByStatus,\n      avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para un asesor\n * @param advisorId ID del asesor\n */\nexport const getAdvisorDashboardStats = async advisorId => {\n  try {\n    var _advisorAppResult$, _clientsResult$, _companiesResult$, _conversionResult$, _conversionResult$2, _timeResult$;\n    // Obtenemos las estadísticas generales primero\n    const baseStats = await getGeneralDashboardStats();\n\n    // Estadísticas específicas del asesor\n    // Total de aplicaciones del asesor\n    const advisorApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const advisorAppResult = await executeQuery(advisorApplicationsQuery);\n    const totalAdvisorApplications = parseInt(((_advisorAppResult$ = advisorAppResult[0]) === null || _advisorAppResult$ === void 0 ? void 0 : _advisorAppResult$.total) || '0');\n\n    // Aplicaciones por estado del asesor\n    const advisorStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      GROUP BY status\n    `;\n    const advisorStatusResult = await executeQuery(advisorStatusQuery);\n    const advisorApplicationsByStatus = advisorStatusResult.map(row => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de clientes del asesor\n    const clientsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.CLIENTS} \n      WHERE advisor_id = '${advisorId}'\n    `;\n    const clientsResult = await executeQuery(clientsQuery);\n    const totalClients = parseInt(((_clientsResult$ = clientsResult[0]) === null || _clientsResult$ === void 0 ? void 0 : _clientsResult$.total) || '0');\n\n    // Total de empresas asignadas al asesor\n    const companiesQuery = `\n      SELECT COUNT(DISTINCT company_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const companiesResult = await executeQuery(companiesQuery);\n    const totalCompanies = parseInt(((_companiesResult$ = companiesResult[0]) === null || _companiesResult$ === void 0 ? void 0 : _companiesResult$.total) || '0');\n\n    // Tasa de conversión (aprobados / total)\n    const conversionRateQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'completed')) as approved,\n        COUNT(*) as total\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const conversionResult = await executeQuery(conversionRateQuery);\n    const approved = parseInt(((_conversionResult$ = conversionResult[0]) === null || _conversionResult$ === void 0 ? void 0 : _conversionResult$.approved) || '0');\n    const total = parseInt(((_conversionResult$2 = conversionResult[0]) === null || _conversionResult$2 === void 0 ? void 0 : _conversionResult$2.total) || '0');\n    const conversionRate = total > 0 ? approved / total * 100 : 0;\n\n    // Tiempo promedio hasta aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_advisor - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      AND approval_date_advisor IS NOT NULL\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgTimeToApproval = parseFloat(((_timeResult$ = timeResult[0]) === null || _timeResult$ === void 0 ? void 0 : _timeResult$.avg_days) || '0');\n\n    // Aplicaciones recientes del asesor\n    const recentAdvisorAppsQuery = `\n      SELECT id, created_at, client_name, status, amount, company_name\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ORDER BY created_at DESC\n      LIMIT 10\n    `;\n    const recentAdvisorApps = await executeQuery(recentAdvisorAppsQuery);\n    return {\n      ...baseStats,\n      totalApplications: totalAdvisorApplications,\n      applicationsByStatus: advisorApplicationsByStatus,\n      recentApplications: recentAdvisorApps,\n      totalClients,\n      totalCompanies,\n      conversionRate,\n      avgTimeToApproval\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas del asesor ${advisorId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para una empresa\n * @param companyId ID de la empresa\n */\nexport const getCompanyDashboardStats = async companyId => {\n  try {\n    var _companyAppResult$, _advisorsResult$, _clientsResult$2, _timeResult$2;\n    // Obtenemos las estadísticas generales primero\n    const baseStats = await getGeneralDashboardStats();\n\n    // Estadísticas específicas de la empresa\n    // Total de aplicaciones de la empresa\n    const companyApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const companyAppResult = await executeQuery(companyApplicationsQuery);\n    const totalCompanyApplications = parseInt(((_companyAppResult$ = companyAppResult[0]) === null || _companyAppResult$ === void 0 ? void 0 : _companyAppResult$.total) || '0');\n\n    // Aplicaciones por estado de la empresa\n    const companyStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      GROUP BY status\n    `;\n    const companyStatusResult = await executeQuery(companyStatusQuery);\n    const companyApplicationsByStatus = companyStatusResult.map(row => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de asesores asignados a la empresa\n    const advisorsQuery = `\n      SELECT COUNT(DISTINCT assigned_to) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const advisorsResult = await executeQuery(advisorsQuery);\n    const totalAdvisors = parseInt(((_advisorsResult$ = advisorsResult[0]) === null || _advisorsResult$ === void 0 ? void 0 : _advisorsResult$.total) || '0');\n\n    // Total de clientes de la empresa\n    const clientsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.CLIENTS} \n      WHERE company_id = '${companyId}'\n    `;\n    const clientsResult = await executeQuery(clientsQuery);\n    const totalClientsCompany = parseInt(((_clientsResult$2 = clientsResult[0]) === null || _clientsResult$2 === void 0 ? void 0 : _clientsResult$2.total) || '0');\n\n    // Tiempo promedio de aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_company - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      AND approval_date_company IS NOT NULL\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgApprovalTime = parseFloat(((_timeResult$2 = timeResult[0]) === null || _timeResult$2 === void 0 ? void 0 : _timeResult$2.avg_days) || '0');\n\n    // Aplicaciones recientes de la empresa\n    const recentCompanyAppsQuery = `\n      SELECT id, created_at, client_name, status, amount, assigned_to\n      FROM ${TABLES.APPLICATIONS}\n      WHERE company_id = '${companyId}'\n      ORDER BY created_at DESC\n      LIMIT 10\n    `;\n    const recentCompanyApps = await executeQuery(recentCompanyAppsQuery);\n    return {\n      ...baseStats,\n      totalApplications: totalCompanyApplications,\n      applicationsByStatus: companyApplicationsByStatus,\n      recentApplications: recentCompanyApps,\n      totalAdvisors,\n      totalClientsCompany,\n      avgApprovalTime\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas de la empresa ${companyId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas de aplicaciones pendientes de aprobación\n * @param userId ID del usuario (asesor o admin de empresa)\n * @param isCompanyAdmin Indica si el usuario es un admin de empresa\n */\nexport const getPendingApprovalStats = async (userId, isCompanyAdmin) => {\n  try {\n    var _result$;\n    let query = '';\n    if (isCompanyAdmin) {\n      var _companyResult$;\n      // Obtener ID de la compañía del admin\n      const companyQuery = `\n        SELECT company_id FROM ${TABLES.COMPANY_ADMINS} WHERE id = '${userId}'\n      `;\n      const companyResult = await executeQuery(companyQuery);\n      const companyId = (_companyResult$ = companyResult[0]) === null || _companyResult$ === void 0 ? void 0 : _companyResult$.company_id;\n      if (!companyId) {\n        throw new Error('No se encontró la compañía para este administrador');\n      }\n\n      // Aplicaciones pendientes de aprobación por la compañía\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND approved_by_advisor = true\n        AND approved_by_company = false\n      `;\n    } else {\n      // Aplicaciones pendientes de aprobación por el asesor\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;\n    }\n    const result = await executeQuery(query);\n    return {\n      pendingCount: parseInt(((_result$ = result[0]) === null || _result$ === void 0 ? void 0 : _result$.pending_count) || '0')\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas de aprobaciones pendientes:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["TABLES","executeQuery","getGeneralDashboardStats","_totalAppResult$","_amountResult$","_amountResult$2","_amountResult$3","_categoryResult$","_categoryResult$2","_categoryResult$3","_categoryResult$4","_totalClientsResult$","totalApplicationsQuery","APPLICATIONS","totalAppResult","totalApplications","parseInt","total","applicationsByStatusQuery","statusResult","applicationsByStatus","map","row","status","count","amountStatsQuery","amountResult","avgAmount","parseFloat","avg_amount","minAmount","min_amount","maxAmount","max_amount","recentApplicationsQuery","recentApplications","applicationsByMonthQuery","monthResult","applicationsByMonth","month","totalByMajorCategoryQuery","categoryResult","totalApproved","approved","totalRejected","rejected","totalPending","pending","pendingApproval","pending_approval","totalClientsQuery","CLIENTS","totalClientsResult","totalClients","error","console","getAdvisorDashboardStats","advisorId","_advisorAppResult$","_clientsResult$","_companiesResult$","_conversionResult$","_conversionResult$2","_timeResult$","baseStats","advisorApplicationsQuery","advisorAppResult","totalAdvisorApplications","advisorStatusQuery","advisorStatusResult","advisorApplicationsByStatus","clientsQuery","clientsResult","companiesQuery","companiesResult","totalCompanies","conversionRateQuery","conversionResult","conversionRate","avgTimeQuery","timeResult","avgTimeToApproval","avg_days","recentAdvisorAppsQuery","recentAdvisorApps","getCompanyDashboardStats","companyId","_companyAppResult$","_advisorsResult$","_clientsResult$2","_timeResult$2","companyApplicationsQuery","companyAppResult","totalCompanyApplications","companyStatusQuery","companyStatusResult","companyApplicationsByStatus","advisorsQuery","advisorsResult","totalAdvisors","totalClientsCompany","avgApprovalTime","recentCompanyAppsQuery","recentCompanyApps","getPendingApprovalStats","userId","isCompanyAdmin","_result$","query","_companyResult$","companyQuery","COMPANY_ADMINS","companyResult","company_id","Error","result","pendingCount","pending_count"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/dashboardService.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nimport { executeQuery } from '../utils/databaseUtils';\n\nexport interface DashboardStats {\n  totalApplications: number;\n  applicationsByStatus: {\n    status: string;\n    count: number;\n  }[];\n  avgAmount: number;\n  minAmount: number;\n  maxAmount: number;\n  recentApplications: any[];\n  applicationsByMonth: {\n    month: string;\n    count: number;\n  }[];\n  totalApproved: number;\n  totalRejected: number;\n  totalPending: number;\n  pendingApproval: number;\n  totalClients: number;\n}\n\nexport interface AdvisorStats extends DashboardStats {\n  totalClients: number;\n  totalCompanies: number;\n  conversionRate: number;\n  avgTimeToApproval: number;\n}\n\nexport interface CompanyStats extends DashboardStats {\n  totalAdvisors: number;\n  totalClientsCompany: number;\n  avgApprovalTime: number;\n}\n\n/**\n * Obtiene estadísticas generales para el dashboard\n */\nexport const getGeneralDashboardStats = async (): Promise<DashboardStats> => {\n  try {\n    // Total de aplicaciones\n    const totalApplicationsQuery = `SELECT COUNT(*) as total FROM ${TABLES.APPLICATIONS}`;\n    const totalAppResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = parseInt(totalAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      GROUP BY status\n    `;\n    const statusResult = await executeQuery(applicationsByStatusQuery);\n    const applicationsByStatus = statusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Estadísticas de montos\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(amountResult[0]?.avg_amount || '0');\n    const minAmount = parseFloat(amountResult[0]?.min_amount || '0');\n    const maxAmount = parseFloat(amountResult[0]?.max_amount || '0');\n\n    // Aplicaciones recientes\n    const recentApplicationsQuery = `\n      SELECT id, created_at, client_name, status, amount, company_name\n      FROM ${TABLES.APPLICATIONS}\n      ORDER BY created_at DESC\n      LIMIT 10\n    `;\n    const recentApplications = await executeQuery(recentApplicationsQuery);\n\n    // Aplicaciones por mes (últimos 6 meses)\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE created_at >= NOW() - INTERVAL '6 months'\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    const monthResult = await executeQuery(applicationsByMonthQuery);\n    const applicationsByMonth = monthResult.map((row: any) => ({\n      month: row.month,\n      count: parseInt(row.count)\n    }));\n\n    // Totales por categoría principal\n    const totalByMajorCategoryQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'Aprobado por Asesor')) as approved,\n        COUNT(*) FILTER (WHERE status IN ('rejected', 'RECHAZADO')) as rejected,\n        COUNT(*) FILTER (WHERE status IN ('pending', 'new', 'Solicitud', 'Simulación')) as pending,\n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n    `;\n    const categoryResult = await executeQuery(totalByMajorCategoryQuery);\n    const totalApproved = parseInt(categoryResult[0]?.approved || '0');\n    const totalRejected = parseInt(categoryResult[0]?.rejected || '0');\n    const totalPending = parseInt(categoryResult[0]?.pending || '0');\n    const pendingApproval = parseInt(categoryResult[0]?.pending_approval || '0');\n\n    // Total clients\n    const totalClientsQuery = `SELECT COUNT(*) as total FROM ${TABLES.CLIENTS}`;\n    const totalClientsResult = await executeQuery(totalClientsQuery);\n    const totalClients = parseInt(totalClientsResult[0]?.total || '0');\n\n    return {\n      totalApplications,\n      applicationsByStatus,\n      avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para un asesor\n * @param advisorId ID del asesor\n */\nexport const getAdvisorDashboardStats = async (advisorId: string): Promise<AdvisorStats> => {\n  try {\n    // Obtenemos las estadísticas generales primero\n    const baseStats = await getGeneralDashboardStats();\n\n    // Estadísticas específicas del asesor\n    // Total de aplicaciones del asesor\n    const advisorApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const advisorAppResult = await executeQuery(advisorApplicationsQuery);\n    const totalAdvisorApplications = parseInt(advisorAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado del asesor\n    const advisorStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      GROUP BY status\n    `;\n    const advisorStatusResult = await executeQuery(advisorStatusQuery);\n    const advisorApplicationsByStatus = advisorStatusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de clientes del asesor\n    const clientsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.CLIENTS} \n      WHERE advisor_id = '${advisorId}'\n    `;\n    const clientsResult = await executeQuery(clientsQuery);\n    const totalClients = parseInt(clientsResult[0]?.total || '0');\n\n    // Total de empresas asignadas al asesor\n    const companiesQuery = `\n      SELECT COUNT(DISTINCT company_id) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const companiesResult = await executeQuery(companiesQuery);\n    const totalCompanies = parseInt(companiesResult[0]?.total || '0');\n\n    // Tasa de conversión (aprobados / total)\n    const conversionRateQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'completed')) as approved,\n        COUNT(*) as total\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    const conversionResult = await executeQuery(conversionRateQuery);\n    const approved = parseInt(conversionResult[0]?.approved || '0');\n    const total = parseInt(conversionResult[0]?.total || '0');\n    const conversionRate = total > 0 ? (approved / total) * 100 : 0;\n\n    // Tiempo promedio hasta aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_advisor - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      AND approval_date_advisor IS NOT NULL\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgTimeToApproval = parseFloat(timeResult[0]?.avg_days || '0');\n\n    // Aplicaciones recientes del asesor\n    const recentAdvisorAppsQuery = `\n      SELECT id, created_at, client_name, status, amount, company_name\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ORDER BY created_at DESC\n      LIMIT 10\n    `;\n    const recentAdvisorApps = await executeQuery(recentAdvisorAppsQuery);\n\n    return {\n      ...baseStats,\n      totalApplications: totalAdvisorApplications,\n      applicationsByStatus: advisorApplicationsByStatus,\n      recentApplications: recentAdvisorApps,\n      totalClients,\n      totalCompanies,\n      conversionRate,\n      avgTimeToApproval\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas del asesor ${advisorId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para una empresa\n * @param companyId ID de la empresa\n */\nexport const getCompanyDashboardStats = async (companyId: string): Promise<CompanyStats> => {\n  try {\n    // Obtenemos las estadísticas generales primero\n    const baseStats = await getGeneralDashboardStats();\n\n    // Estadísticas específicas de la empresa\n    // Total de aplicaciones de la empresa\n    const companyApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const companyAppResult = await executeQuery(companyApplicationsQuery);\n    const totalCompanyApplications = parseInt(companyAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado de la empresa\n    const companyStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      GROUP BY status\n    `;\n    const companyStatusResult = await executeQuery(companyStatusQuery);\n    const companyApplicationsByStatus = companyStatusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de asesores asignados a la empresa\n    const advisorsQuery = `\n      SELECT COUNT(DISTINCT assigned_to) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const advisorsResult = await executeQuery(advisorsQuery);\n    const totalAdvisors = parseInt(advisorsResult[0]?.total || '0');\n\n    // Total de clientes de la empresa\n    const clientsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.CLIENTS} \n      WHERE company_id = '${companyId}'\n    `;\n    const clientsResult = await executeQuery(clientsQuery);\n    const totalClientsCompany = parseInt(clientsResult[0]?.total || '0');\n\n    // Tiempo promedio de aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_company - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      AND approval_date_company IS NOT NULL\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgApprovalTime = parseFloat(timeResult[0]?.avg_days || '0');\n\n    // Aplicaciones recientes de la empresa\n    const recentCompanyAppsQuery = `\n      SELECT id, created_at, client_name, status, amount, assigned_to\n      FROM ${TABLES.APPLICATIONS}\n      WHERE company_id = '${companyId}'\n      ORDER BY created_at DESC\n      LIMIT 10\n    `;\n    const recentCompanyApps = await executeQuery(recentCompanyAppsQuery);\n\n    return {\n      ...baseStats,\n      totalApplications: totalCompanyApplications,\n      applicationsByStatus: companyApplicationsByStatus,\n      recentApplications: recentCompanyApps,\n      totalAdvisors,\n      totalClientsCompany,\n      avgApprovalTime\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas de la empresa ${companyId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas de aplicaciones pendientes de aprobación\n * @param userId ID del usuario (asesor o admin de empresa)\n * @param isCompanyAdmin Indica si el usuario es un admin de empresa\n */\nexport const getPendingApprovalStats = async (userId: string, isCompanyAdmin: boolean): Promise<any> => {\n  try {\n    let query = '';\n    \n    if (isCompanyAdmin) {\n      // Obtener ID de la compañía del admin\n      const companyQuery = `\n        SELECT company_id FROM ${TABLES.COMPANY_ADMINS} WHERE id = '${userId}'\n      `;\n      const companyResult = await executeQuery(companyQuery);\n      const companyId = companyResult[0]?.company_id;\n      \n      if (!companyId) {\n        throw new Error('No se encontró la compañía para este administrador');\n      }\n      \n      // Aplicaciones pendientes de aprobación por la compañía\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND approved_by_advisor = true\n        AND approved_by_company = false\n      `;\n    } else {\n      // Aplicaciones pendientes de aprobación por el asesor\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;\n    }\n    \n    const result = await executeQuery(query);\n    return {\n      pendingCount: parseInt(result[0]?.pending_count || '0')\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas de aprobaciones pendientes:', error);\n    throw error;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}