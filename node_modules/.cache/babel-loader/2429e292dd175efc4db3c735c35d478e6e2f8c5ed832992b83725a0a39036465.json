{"ast":null,"code":"import { APPLICATION_TYPE_LABELS } from './constants/applications';\n\n/**\n * Formatea un valor numérico como moneda (pesos mexicanos)\n * @param value El valor a formatear\n * @returns El valor formateado como moneda\n */\nexport const formatCurrency = value => {\n  const numValue = typeof value === 'string' ? parseFloat(value) : value;\n\n  // Si no es un número válido, retornar $0.00\n  if (isNaN(numValue)) return '$0.00';\n  return new Intl.NumberFormat('es-MX', {\n    style: 'currency',\n    currency: 'MXN',\n    minimumFractionDigits: 2,\n    // Siempre mostrar 2 decimales\n    maximumFractionDigits: 2 // Siempre mostrar 2 decimales\n  }).format(numValue);\n};\n\n/**\n * Formatea una fecha en formato legible\n * @param dateString La fecha a formatear (string o Date)\n * @returns La fecha formateada en formato local\n */\nexport const formatDate = dateString => {\n  if (!dateString) return 'N/A';\n  try {\n    const date = typeof dateString === 'string' ? new Date(dateString) : dateString;\n\n    // Verificar si la fecha es válida\n    if (isNaN(date.getTime())) return 'Fecha inválida';\n    return date.toLocaleDateString('es-MX', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric'\n    });\n  } catch (error) {\n    console.error('Error al formatear fecha:', error);\n    return 'Error de fecha';\n  }\n};\n\n/**\n * Obtiene una etiqueta legible para un tipo de aplicación\n * @param type El tipo de aplicación a formatear\n * @returns Etiqueta legible para el tipo de aplicación\n */\nexport const getApplicationTypeLabel = type => {\n  if (!type) return 'No especificado';\n\n  // 1. Verificar si está en los valores de APPLICATION_TYPE_LABELS\n  const typeLabel = APPLICATION_TYPE_LABELS[type];\n  if (typeLabel) return typeLabel;\n\n  // 2. Verificar casos específicos comunes que podrían no estar en mayúsculas\n  const typeMappings = {\n    'selected_plans': 'Planes Seleccionados',\n    'product_simulations': 'Simulación de Producto',\n    'cash_requests': 'Solicitud de Efectivo',\n    'auto_loan': 'Crédito Automotriz',\n    'car_backed_loan': 'Crédito con Garantía Automotriz',\n    'personal_loan': 'Préstamo Personal',\n    'cash_advance': 'Adelanto de Efectivo',\n    'simulacion': 'Simulación',\n    'solicitud': 'Solicitud'\n  };\n\n  // Buscar coincidencia exacta primero\n  if (typeMappings[type.toLowerCase()]) {\n    return typeMappings[type.toLowerCase()];\n  }\n\n  // 3. Buscar coincidencia parcial si no hay coincidencia exacta\n  const lowerType = type.toLowerCase();\n  for (const [key, value] of Object.entries(typeMappings)) {\n    if (lowerType.includes(key) || key.includes(lowerType)) {\n      return value;\n    }\n  }\n\n  // 4. Si es algún otro formato (como snake_case), formatearlo de manera legible\n  if (type.includes('_')) {\n    return type.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\n  }\n\n  // 5. Si nada funciona, devolver el tipo original con la primera letra en mayúscula\n  return type.charAt(0).toUpperCase() + type.slice(1).toLowerCase();\n};","map":{"version":3,"names":["APPLICATION_TYPE_LABELS","formatCurrency","value","numValue","parseFloat","isNaN","Intl","NumberFormat","style","currency","minimumFractionDigits","maximumFractionDigits","format","formatDate","dateString","date","Date","getTime","toLocaleDateString","year","month","day","error","console","getApplicationTypeLabel","type","typeLabel","typeMappings","toLowerCase","lowerType","key","Object","entries","includes","split","map","word","charAt","toUpperCase","slice","join"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/formatters.ts"],"sourcesContent":["import { APPLICATION_TYPE_LABELS } from './constants/applications';\n\n/**\n * Formatea un valor numérico como moneda (pesos mexicanos)\n * @param value El valor a formatear\n * @returns El valor formateado como moneda\n */\nexport const formatCurrency = (value: number | string): string => {\n  const numValue = typeof value === 'string' ? parseFloat(value) : value;\n  \n  // Si no es un número válido, retornar $0.00\n  if (isNaN(numValue)) return '$0.00';\n  \n  return new Intl.NumberFormat('es-MX', {\n    style: 'currency',\n    currency: 'MXN',\n    minimumFractionDigits: 2, // Siempre mostrar 2 decimales\n    maximumFractionDigits: 2, // Siempre mostrar 2 decimales\n  }).format(numValue);\n};\n\n/**\n * Formatea una fecha en formato legible\n * @param dateString La fecha a formatear (string o Date)\n * @returns La fecha formateada en formato local\n */\nexport const formatDate = (dateString: string | Date): string => {\n  if (!dateString) return 'N/A';\n  \n  try {\n    const date = typeof dateString === 'string' ? new Date(dateString) : dateString;\n    \n    // Verificar si la fecha es válida\n    if (isNaN(date.getTime())) return 'Fecha inválida';\n    \n    return date.toLocaleDateString('es-MX', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric'\n    });\n  } catch (error) {\n    console.error('Error al formatear fecha:', error);\n    return 'Error de fecha';\n  }\n};\n\n/**\n * Obtiene una etiqueta legible para un tipo de aplicación\n * @param type El tipo de aplicación a formatear\n * @returns Etiqueta legible para el tipo de aplicación\n */\nexport const getApplicationTypeLabel = (type: string | null | undefined): string => {\n  if (!type) return 'No especificado';\n  \n  // 1. Verificar si está en los valores de APPLICATION_TYPE_LABELS\n  const typeLabel = APPLICATION_TYPE_LABELS[type];\n  if (typeLabel) return typeLabel;\n  \n  // 2. Verificar casos específicos comunes que podrían no estar en mayúsculas\n  const typeMappings: Record<string, string> = {\n    'selected_plans': 'Planes Seleccionados',\n    'product_simulations': 'Simulación de Producto',\n    'cash_requests': 'Solicitud de Efectivo',\n    'auto_loan': 'Crédito Automotriz',\n    'car_backed_loan': 'Crédito con Garantía Automotriz',\n    'personal_loan': 'Préstamo Personal',\n    'cash_advance': 'Adelanto de Efectivo',\n    'simulacion': 'Simulación',\n    'solicitud': 'Solicitud'\n  };\n  \n  // Buscar coincidencia exacta primero\n  if (typeMappings[type.toLowerCase()]) {\n    return typeMappings[type.toLowerCase()];\n  }\n  \n  // 3. Buscar coincidencia parcial si no hay coincidencia exacta\n  const lowerType = type.toLowerCase();\n  for (const [key, value] of Object.entries(typeMappings)) {\n    if (lowerType.includes(key) || key.includes(lowerType)) {\n      return value;\n    }\n  }\n  \n  // 4. Si es algún otro formato (como snake_case), formatearlo de manera legible\n  if (type.includes('_')) {\n    return type\n      .split('_')\n      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n      .join(' ');\n  }\n  \n  // 5. Si nada funciona, devolver el tipo original con la primera letra en mayúscula\n  return type.charAt(0).toUpperCase() + type.slice(1).toLowerCase();\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}