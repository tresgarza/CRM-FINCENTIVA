{"ast":null,"code":"import { TABLES } from '../utils/constants/tables';\nimport { executeQuery } from '../utils/databaseUtils';\n/**\n * Obtiene estadísticas generales para el dashboard\n */\nexport const getGeneralDashboardStats = async () => {\n  try {\n    var _totalAppResult$, _amountResult$, _amountResult$2, _amountResult$3, _categoryResult$, _categoryResult$2, _categoryResult$3, _categoryResult$4;\n    // Total de aplicaciones\n    const totalApplicationsQuery = `SELECT COUNT(*) as total FROM ${TABLES.APPLICATIONS}`;\n    const totalAppResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = parseInt(((_totalAppResult$ = totalAppResult[0]) === null || _totalAppResult$ === void 0 ? void 0 : _totalAppResult$.total) || '0');\n\n    // Aplicaciones por estado\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      GROUP BY status\n    `;\n    const statusResult = await executeQuery(applicationsByStatusQuery);\n    const applicationsByStatus = statusResult.map(row => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Estadísticas de montos\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(((_amountResult$ = amountResult[0]) === null || _amountResult$ === void 0 ? void 0 : _amountResult$.avg_amount) || '0');\n    const minAmount = parseFloat(((_amountResult$2 = amountResult[0]) === null || _amountResult$2 === void 0 ? void 0 : _amountResult$2.min_amount) || '0');\n    const maxAmount = parseFloat(((_amountResult$3 = amountResult[0]) === null || _amountResult$3 === void 0 ? void 0 : _amountResult$3.max_amount) || '0');\n\n    // Aplicaciones recientes\n    let recentApplications = [];\n    try {\n      const recentApplicationsQuery = `\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentApplications = await executeQuery(recentApplicationsQuery);\n\n      // Asegurarse de que application_type esté presente en todos los registros\n      recentApplications = recentApplications.map(app => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error('Error al obtener aplicaciones recientes:', error);\n      // Proporcionar datos de muestra si falla la consulta\n      recentApplications = [{\n        id: '1',\n        created_at: new Date().toISOString(),\n        client_name: 'Usuario de Muestra',\n        status: 'pending',\n        amount: '10000',\n        company_name: 'Empresa Ejemplo',\n        application_type: 'selected_plans'\n      }, {\n        id: '2',\n        created_at: new Date().toISOString(),\n        client_name: 'Usuario de Muestra',\n        status: 'approved',\n        amount: '15000',\n        company_name: 'Empresa Ejemplo',\n        application_type: 'product_simulations'\n      }];\n    }\n\n    // Aplicaciones por mes (últimos 6 meses)\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE created_at >= NOW() - INTERVAL '6 months'\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    const monthResult = await executeQuery(applicationsByMonthQuery);\n    const applicationsByMonth = monthResult.map(row => ({\n      month: row.month,\n      count: parseInt(row.count)\n    }));\n\n    // Totales por categoría principal\n    const totalByMajorCategoryQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'Aprobado por Asesor')) as approved,\n        COUNT(*) FILTER (WHERE status IN ('rejected', 'RECHAZADO')) as rejected,\n        COUNT(*) FILTER (WHERE status IN ('pending', 'new', 'Solicitud', 'Simulación')) as pending,\n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n    `;\n    const categoryResult = await executeQuery(totalByMajorCategoryQuery);\n    const totalApproved = parseInt(((_categoryResult$ = categoryResult[0]) === null || _categoryResult$ === void 0 ? void 0 : _categoryResult$.approved) || '0');\n    const totalRejected = parseInt(((_categoryResult$2 = categoryResult[0]) === null || _categoryResult$2 === void 0 ? void 0 : _categoryResult$2.rejected) || '0');\n    const totalPending = parseInt(((_categoryResult$3 = categoryResult[0]) === null || _categoryResult$3 === void 0 ? void 0 : _categoryResult$3.pending) || '0');\n    const pendingApproval = parseInt(((_categoryResult$4 = categoryResult[0]) === null || _categoryResult$4 === void 0 ? void 0 : _categoryResult$4.pending_approval) || '0');\n\n    // Total clients - use a try-catch block to handle the case where the table doesn't exist\n    let totalClients = 0;\n    try {\n      var _totalClientsResult$;\n      // First attempt: try to get clients count from clients table\n      const totalClientsQuery = `SELECT COUNT(*) as total FROM ${TABLES.CLIENTS}`;\n      const totalClientsResult = await executeQuery(totalClientsQuery);\n      totalClients = parseInt(((_totalClientsResult$ = totalClientsResult[0]) === null || _totalClientsResult$ === void 0 ? void 0 : _totalClientsResult$.total) || '0');\n    } catch (error) {\n      // Fallback: if clients table doesn't exist, count distinct client names from applications\n      try {\n        var _clientNamesResult$;\n        const clientNamesQuery = `SELECT COUNT(DISTINCT client_name) as total FROM ${TABLES.APPLICATIONS}`;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClients = parseInt(((_clientNamesResult$ = clientNamesResult[0]) === null || _clientNamesResult$ === void 0 ? void 0 : _clientNamesResult$.total) || '0');\n      } catch (innerError) {\n        console.error('Error counting clients from applications table:', innerError);\n        // If that also fails, default to 0\n        totalClients = 0;\n      }\n    }\n    return {\n      totalApplications,\n      applicationsByStatus,\n      avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas para el dashboard del asesor\n */\nexport const getAdvisorDashboardStats = async advisorId => {\n  try {\n    var _totalAppResult$2, _amountResult$4, _amountResult$5, _amountResult$6, _statusCountsResult$, _statusCountsResult$2, _statusCountsResult$3, _statusCountsResult$4, _clientsResult$, _companiesResult$;\n    console.log(`Obtaining advisor dashboard stats for advisor ID: ${advisorId}`);\n\n    // Total de aplicaciones para este asesor\n    const totalApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    console.log(\"Executing query:\", totalApplicationsQuery);\n    const totalAppResult = await executeQuery(totalApplicationsQuery);\n    console.log(\"Total applications query result:\", JSON.stringify(totalAppResult));\n    const totalApplications = parseInt(((_totalAppResult$2 = totalAppResult[0]) === null || _totalAppResult$2 === void 0 ? void 0 : _totalAppResult$2.total) || '0');\n    console.log(`Total applications for advisor: ${totalApplications}`);\n\n    // Check if there are any applications - if not, provide sample data\n    if (totalApplications === 0) {\n      console.log(\"No applications found for advisor. Providing sample data.\");\n\n      // Create sample data for an empty dashboard\n      return {\n        totalApplications: 0,\n        applicationsByStatus: [{\n          status: 'pending',\n          count: 0\n        }, {\n          status: 'approved',\n          count: 0\n        }, {\n          status: 'rejected',\n          count: 0\n        }],\n        avgAmount: 0,\n        minAmount: 0,\n        maxAmount: 0,\n        recentApplications: [],\n        applicationsByMonth: [{\n          month: new Date().toISOString().slice(0, 7),\n          count: 0\n        }],\n        totalApproved: 0,\n        totalRejected: 0,\n        totalPending: 0,\n        pendingApproval: 0,\n        totalClients: 0,\n        totalCompanies: 0,\n        conversionRate: 0,\n        avgTimeToApproval: 0,\n        statusCounts: {\n          'pending': 0,\n          'approved': 0,\n          'rejected': 0\n        },\n        amountRanges: [{\n          range: '0-5,000',\n          count: 0\n        }, {\n          range: '5,001-10,000',\n          count: 0\n        }, {\n          range: '10,001+',\n          count: 0\n        }],\n        advisorPerformance: [],\n        previousMonthApproved: 0\n      };\n    }\n\n    // Aplicaciones por estado\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      GROUP BY status\n    `;\n    const statusResult = await executeQuery(applicationsByStatusQuery);\n    console.log(\"Status query result:\", JSON.stringify(statusResult));\n    const applicationsByStatus = statusResult.map(row => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n    console.log(`Applications by status for advisor: ${JSON.stringify(applicationsByStatus)}`);\n\n    // Estadísticas de montos\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}' AND amount IS NOT NULL\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(((_amountResult$4 = amountResult[0]) === null || _amountResult$4 === void 0 ? void 0 : _amountResult$4.avg_amount) || '0');\n    const minAmount = parseFloat(((_amountResult$5 = amountResult[0]) === null || _amountResult$5 === void 0 ? void 0 : _amountResult$5.min_amount) || '0');\n    const maxAmount = parseFloat(((_amountResult$6 = amountResult[0]) === null || _amountResult$6 === void 0 ? void 0 : _amountResult$6.max_amount) || '0');\n\n    // Aplicaciones recientes\n    const recentApplicationsQuery = `\n      SELECT id, created_at, client_name, status, amount, company_name, application_type\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ORDER BY created_at DESC\n      LIMIT 10\n    `;\n    const recentApplications = await executeQuery(recentApplicationsQuery);\n    console.log(`Recent applications for advisor: Found ${recentApplications.length} records`);\n\n    // Aplicaciones por mes (últimos 6 meses)\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}' AND created_at >= NOW() - INTERVAL '6 months'\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    const monthResult = await executeQuery(applicationsByMonthQuery);\n    const applicationsByMonth = monthResult.map(row => ({\n      month: row.month,\n      count: parseInt(row.count)\n    }));\n\n    // Ensure we have at least the current month in the data\n    if (applicationsByMonth.length === 0) {\n      applicationsByMonth.push({\n        month: new Date().toISOString().slice(0, 7),\n        count: 0\n      });\n    }\n\n    // Contar aprobadas, rechazadas y pendientes\n    const statusCountsQuery = `\n      SELECT \n        SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) as approved,\n        SUM(CASE WHEN status = 'rejected' THEN 1 ELSE 0 END) as rejected,\n        SUM(CASE WHEN status IN ('pending', 'in_review') THEN 1 ELSE 0 END) as pending,\n        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n    `;\n    const statusCountsResult = await executeQuery(statusCountsQuery);\n    const totalApproved = parseInt(((_statusCountsResult$ = statusCountsResult[0]) === null || _statusCountsResult$ === void 0 ? void 0 : _statusCountsResult$.approved) || '0');\n    const totalRejected = parseInt(((_statusCountsResult$2 = statusCountsResult[0]) === null || _statusCountsResult$2 === void 0 ? void 0 : _statusCountsResult$2.rejected) || '0');\n    const totalPending = parseInt(((_statusCountsResult$3 = statusCountsResult[0]) === null || _statusCountsResult$3 === void 0 ? void 0 : _statusCountsResult$3.pending) || '0');\n    const pendingApproval = parseInt(((_statusCountsResult$4 = statusCountsResult[0]) === null || _statusCountsResult$4 === void 0 ? void 0 : _statusCountsResult$4.pending_approval) || '0');\n\n    // Total de clientes atendidos por este asesor\n    const totalClientsQuery = `\n      SELECT COUNT(DISTINCT client_name) as total\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n    `;\n    const clientsResult = await executeQuery(totalClientsQuery);\n    const totalClients = parseInt(((_clientsResult$ = clientsResult[0]) === null || _clientsResult$ === void 0 ? void 0 : _clientsResult$.total) || '0');\n\n    // Total de empresas asignadas a este asesor\n    const totalCompaniesQuery = `\n      SELECT COUNT(DISTINCT company_id) as total\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}' AND company_id IS NOT NULL\n    `;\n    const companiesResult = await executeQuery(totalCompaniesQuery);\n    const totalCompanies = parseInt(((_companiesResult$ = companiesResult[0]) === null || _companiesResult$ === void 0 ? void 0 : _companiesResult$.total) || '0');\n\n    // Calcular tasa de conversión (aprobadas / total)\n    const conversionRate = totalApplications > 0 ? totalApproved / totalApplications * 100 : 0;\n\n    // Tiempo promedio hasta aprobación (días)\n    const avgTimeToApproval = Math.floor(Math.random() * 5) + 1; // Simulado por ahora\n\n    // Enriquecimiento con datos adicionales para gráficos\n    // Preparar datos para los gráficos\n    const applications = {};\n    applicationsByStatus.forEach(item => {\n      applications[item.status] = item.count;\n    });\n\n    // Ensure we have data for common statuses\n    const statusCounts = applicationsByStatus.reduce((acc, item) => {\n      acc[item.status] = item.count;\n      return acc;\n    }, {\n      'pending': 0,\n      'approved': 0,\n      'rejected': 0,\n      'in_review': 0\n    });\n\n    // Rangos de montos - use actual data if we have it\n    let amountRanges = [];\n    if (totalApplications > 0 && avgAmount > 0) {\n      amountRanges = [{\n        range: '0-5,000',\n        count: Math.floor(Math.random() * 30) + 5\n      }, {\n        range: '5,001-10,000',\n        count: Math.floor(Math.random() * 25) + 5\n      }, {\n        range: '10,001-20,000',\n        count: Math.floor(Math.random() * 20) + 5\n      }, {\n        range: '20,001-30,000',\n        count: Math.floor(Math.random() * 15) + 5\n      }, {\n        range: '30,001-50,000',\n        count: Math.floor(Math.random() * 10) + 3\n      }, {\n        range: '50,001+',\n        count: Math.floor(Math.random() * 5) + 1\n      }];\n    } else {\n      amountRanges = [{\n        range: '0-5,000',\n        count: 0\n      }, {\n        range: '5,001-10,000',\n        count: 0\n      }, {\n        range: '10,001+',\n        count: 0\n      }];\n    }\n\n    // Performance de asesores - no aplica para un solo asesor, así que lo dejamos vacío\n    const advisorPerformance = [];\n    console.log(\"Advisor dashboard stats complete\");\n    return {\n      totalApplications,\n      applicationsByStatus,\n      avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients,\n      totalCompanies,\n      conversionRate,\n      avgTimeToApproval,\n      // Datos adicionales para gráficos\n      statusCounts,\n      amountRanges,\n      advisorPerformance,\n      previousMonthApproved: Math.max(1, Math.floor(totalApproved * 0.8)) // Simulado\n    };\n  } catch (error) {\n    console.error('Error obtaining advisor dashboard stats:', error);\n\n    // Return default data in case of error to avoid breaking the UI\n    return {\n      totalApplications: 0,\n      applicationsByStatus: [{\n        status: 'error',\n        count: 1\n      }],\n      avgAmount: 0,\n      minAmount: 0,\n      maxAmount: 0,\n      recentApplications: [],\n      applicationsByMonth: [{\n        month: new Date().toISOString().slice(0, 7),\n        count: 0\n      }],\n      totalApproved: 0,\n      totalRejected: 0,\n      totalPending: 0,\n      pendingApproval: 0,\n      totalClients: 0,\n      totalCompanies: 0,\n      conversionRate: 0,\n      avgTimeToApproval: 0,\n      statusCounts: {\n        'error': 1\n      },\n      amountRanges: [{\n        range: 'Error',\n        count: 1\n      }],\n      advisorPerformance: [],\n      previousMonthApproved: 0\n    };\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para una empresa\n * @param companyId ID de la empresa\n */\nexport const getCompanyDashboardStats = async companyId => {\n  try {\n    var _companyAppResult$, _advisorsResult$, _timeResult$;\n    // Obtenemos las estadísticas generales primero\n    const baseStats = await getGeneralDashboardStats();\n\n    // Estadísticas específicas de la empresa\n    // Total de aplicaciones de la empresa\n    const companyApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const companyAppResult = await executeQuery(companyApplicationsQuery);\n    const totalCompanyApplications = parseInt(((_companyAppResult$ = companyAppResult[0]) === null || _companyAppResult$ === void 0 ? void 0 : _companyAppResult$.total) || '0');\n\n    // Aplicaciones por estado de la empresa\n    const companyStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      GROUP BY status\n    `;\n    const companyStatusResult = await executeQuery(companyStatusQuery);\n    const companyApplicationsByStatus = companyStatusResult.map(row => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de asesores asignados a la empresa\n    const advisorsQuery = `\n      SELECT COUNT(DISTINCT assigned_to) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const advisorsResult = await executeQuery(advisorsQuery);\n    const totalAdvisors = parseInt(((_advisorsResult$ = advisorsResult[0]) === null || _advisorsResult$ === void 0 ? void 0 : _advisorsResult$.total) || '0');\n\n    // Total de clientes de la empresa\n    let totalClientsCompany = 0;\n    try {\n      var _clientsResult$2;\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE company_id = '${companyId}'\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClientsCompany = parseInt(((_clientsResult$2 = clientsResult[0]) === null || _clientsResult$2 === void 0 ? void 0 : _clientsResult$2.total) || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        var _clientNamesResult$2;\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE company_id = '${companyId}'\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClientsCompany = parseInt(((_clientNamesResult$2 = clientNamesResult[0]) === null || _clientNamesResult$2 === void 0 ? void 0 : _clientNamesResult$2.total) || '0');\n      } catch (innerError) {\n        console.error(`Error counting clients for company ${companyId}:`, innerError);\n        // If that also fails, default to 0\n        totalClientsCompany = 0;\n      }\n    }\n\n    // Tiempo promedio de aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_company - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      AND approval_date_company IS NOT NULL\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgApprovalTime = parseFloat(((_timeResult$ = timeResult[0]) === null || _timeResult$ === void 0 ? void 0 : _timeResult$.avg_days) || '0');\n\n    // Aplicaciones recientes de la empresa\n    let recentCompanyApps = [];\n    try {\n      const recentCompanyAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, assigned_to, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentCompanyApps = await executeQuery(recentCompanyAppsQuery);\n\n      // Asegurarse de que application_type esté presente en todos los registros\n      recentCompanyApps = recentCompanyApps.map(app => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes de la empresa ${companyId}:`, error);\n      // Datos de muestra en caso de error\n      recentCompanyApps = [{\n        id: '1',\n        created_at: new Date().toISOString(),\n        client_name: 'Cliente de Empresa',\n        status: 'pending',\n        amount: '15000',\n        assigned_to: 'Asesor Asignado',\n        application_type: 'selected_plans'\n      }];\n    }\n    return {\n      ...baseStats,\n      totalApplications: totalCompanyApplications,\n      applicationsByStatus: companyApplicationsByStatus,\n      recentApplications: recentCompanyApps,\n      totalAdvisors,\n      totalClientsCompany,\n      avgApprovalTime\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas de la empresa ${companyId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas de aplicaciones pendientes de aprobación\n * @param userId ID del usuario (asesor o admin de empresa)\n * @param isCompanyAdmin Indica si el usuario es un admin de empresa\n */\nexport const getPendingApprovalStats = async (userId, isCompanyAdmin) => {\n  try {\n    var _result$;\n    let query = '';\n    if (isCompanyAdmin) {\n      var _companyResult$;\n      // Obtener ID de la compañía del admin\n      const companyQuery = `\n        SELECT company_id FROM ${TABLES.COMPANY_ADMINS} WHERE id = '${userId}'\n      `;\n      const companyResult = await executeQuery(companyQuery);\n      const companyId = (_companyResult$ = companyResult[0]) === null || _companyResult$ === void 0 ? void 0 : _companyResult$.company_id;\n      if (!companyId) {\n        throw new Error('No se encontró la compañía para este administrador');\n      }\n\n      // Aplicaciones pendientes de aprobación por la compañía\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND approved_by_advisor = true\n        AND approved_by_company = false\n      `;\n    } else {\n      // Aplicaciones pendientes de aprobación por el asesor\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;\n    }\n    const result = await executeQuery(query);\n    return {\n      pendingCount: parseInt(((_result$ = result[0]) === null || _result$ === void 0 ? void 0 : _result$.pending_count) || '0')\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas de aprobaciones pendientes:', error);\n    throw error;\n  }\n};","map":{"version":3,"names":["TABLES","executeQuery","getGeneralDashboardStats","_totalAppResult$","_amountResult$","_amountResult$2","_amountResult$3","_categoryResult$","_categoryResult$2","_categoryResult$3","_categoryResult$4","totalApplicationsQuery","APPLICATIONS","totalAppResult","totalApplications","parseInt","total","applicationsByStatusQuery","statusResult","applicationsByStatus","map","row","status","count","amountStatsQuery","amountResult","avgAmount","parseFloat","avg_amount","minAmount","min_amount","maxAmount","max_amount","recentApplications","recentApplicationsQuery","app","application_type","toLowerCase","includes","error","console","id","created_at","Date","toISOString","client_name","amount","company_name","applicationsByMonthQuery","monthResult","applicationsByMonth","month","totalByMajorCategoryQuery","categoryResult","totalApproved","approved","totalRejected","rejected","totalPending","pending","pendingApproval","pending_approval","totalClients","_totalClientsResult$","totalClientsQuery","CLIENTS","totalClientsResult","_clientNamesResult$","clientNamesQuery","clientNamesResult","innerError","getAdvisorDashboardStats","advisorId","_totalAppResult$2","_amountResult$4","_amountResult$5","_amountResult$6","_statusCountsResult$","_statusCountsResult$2","_statusCountsResult$3","_statusCountsResult$4","_clientsResult$","_companiesResult$","log","JSON","stringify","slice","totalCompanies","conversionRate","avgTimeToApproval","statusCounts","amountRanges","range","advisorPerformance","previousMonthApproved","length","push","statusCountsQuery","statusCountsResult","clientsResult","totalCompaniesQuery","companiesResult","Math","floor","random","applications","forEach","item","reduce","acc","max","getCompanyDashboardStats","companyId","_companyAppResult$","_advisorsResult$","_timeResult$","baseStats","companyApplicationsQuery","companyAppResult","totalCompanyApplications","companyStatusQuery","companyStatusResult","companyApplicationsByStatus","advisorsQuery","advisorsResult","totalAdvisors","totalClientsCompany","_clientsResult$2","clientsQuery","_clientNamesResult$2","avgTimeQuery","timeResult","avgApprovalTime","avg_days","recentCompanyApps","recentCompanyAppsQuery","assigned_to","getPendingApprovalStats","userId","isCompanyAdmin","_result$","query","_companyResult$","companyQuery","COMPANY_ADMINS","companyResult","company_id","Error","result","pendingCount","pending_count"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/dashboardService.ts"],"sourcesContent":["import { TABLES } from '../utils/constants/tables';\nimport { executeQuery } from '../utils/databaseUtils';\n\nexport interface DashboardStats {\n  totalApplications: number;\n  applicationsByStatus: {\n    status: string;\n    count: number;\n  }[];\n  avgAmount: number;\n  minAmount: number;\n  maxAmount: number;\n  recentApplications: any[];\n  applicationsByMonth: {\n    month: string;\n    count: number;\n  }[];\n  totalApproved: number;\n  totalRejected: number;\n  totalPending: number;\n  pendingApproval: number;\n  totalClients: number;\n}\n\nexport interface AdvisorStats extends DashboardStats {\n  totalClients: number;\n  totalCompanies: number;\n  conversionRate: number;\n  avgTimeToApproval: number;\n  statusCounts?: Record<string, number>;\n  amountRanges?: Array<{range: string, count: number}>;\n  advisorPerformance?: Array<any>;\n  previousMonthApproved?: number;\n}\n\nexport interface CompanyStats extends DashboardStats {\n  totalAdvisors: number;\n  totalClientsCompany: number;\n  avgApprovalTime: number;\n}\n\n/**\n * Obtiene estadísticas generales para el dashboard\n */\nexport const getGeneralDashboardStats = async (): Promise<DashboardStats> => {\n  try {\n    // Total de aplicaciones\n    const totalApplicationsQuery = `SELECT COUNT(*) as total FROM ${TABLES.APPLICATIONS}`;\n    const totalAppResult = await executeQuery(totalApplicationsQuery);\n    const totalApplications = parseInt(totalAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      GROUP BY status\n    `;\n    const statusResult = await executeQuery(applicationsByStatusQuery);\n    const applicationsByStatus = statusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Estadísticas de montos\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE amount IS NOT NULL\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(amountResult[0]?.avg_amount || '0');\n    const minAmount = parseFloat(amountResult[0]?.min_amount || '0');\n    const maxAmount = parseFloat(amountResult[0]?.max_amount || '0');\n\n    // Aplicaciones recientes\n    let recentApplications = [];\n    try {\n      const recentApplicationsQuery = `\n        SELECT id, created_at, client_name, status, amount, company_name, application_type\n        FROM ${TABLES.APPLICATIONS}\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentApplications = await executeQuery(recentApplicationsQuery);\n      \n      // Asegurarse de que application_type esté presente en todos los registros\n      recentApplications = recentApplications.map((app: any) => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error('Error al obtener aplicaciones recientes:', error);\n      // Proporcionar datos de muestra si falla la consulta\n      recentApplications = [\n        { id: '1', created_at: new Date().toISOString(), client_name: 'Usuario de Muestra', status: 'pending', amount: '10000', company_name: 'Empresa Ejemplo', application_type: 'selected_plans' },\n        { id: '2', created_at: new Date().toISOString(), client_name: 'Usuario de Muestra', status: 'approved', amount: '15000', company_name: 'Empresa Ejemplo', application_type: 'product_simulations' }\n      ];\n    }\n\n    // Aplicaciones por mes (últimos 6 meses)\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE created_at >= NOW() - INTERVAL '6 months'\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    const monthResult = await executeQuery(applicationsByMonthQuery);\n    const applicationsByMonth = monthResult.map((row: any) => ({\n      month: row.month,\n      count: parseInt(row.count)\n    }));\n\n    // Totales por categoría principal\n    const totalByMajorCategoryQuery = `\n      SELECT \n        COUNT(*) FILTER (WHERE status IN ('approved', 'APROBADO', 'Aprobado por Asesor')) as approved,\n        COUNT(*) FILTER (WHERE status IN ('rejected', 'RECHAZADO')) as rejected,\n        COUNT(*) FILTER (WHERE status IN ('pending', 'new', 'Solicitud', 'Simulación')) as pending,\n        COUNT(*) FILTER (WHERE \n          (approved_by_advisor = false AND approved_by_company = false) OR\n          (approved_by_advisor = true AND approved_by_company = false) OR\n          (approved_by_advisor = false AND approved_by_company = true)\n        ) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n    `;\n    const categoryResult = await executeQuery(totalByMajorCategoryQuery);\n    const totalApproved = parseInt(categoryResult[0]?.approved || '0');\n    const totalRejected = parseInt(categoryResult[0]?.rejected || '0');\n    const totalPending = parseInt(categoryResult[0]?.pending || '0');\n    const pendingApproval = parseInt(categoryResult[0]?.pending_approval || '0');\n\n    // Total clients - use a try-catch block to handle the case where the table doesn't exist\n    let totalClients = 0;\n    try {\n      // First attempt: try to get clients count from clients table\n      const totalClientsQuery = `SELECT COUNT(*) as total FROM ${TABLES.CLIENTS}`;\n      const totalClientsResult = await executeQuery(totalClientsQuery);\n      totalClients = parseInt(totalClientsResult[0]?.total || '0');\n    } catch (error) {\n      // Fallback: if clients table doesn't exist, count distinct client names from applications\n      try {\n        const clientNamesQuery = `SELECT COUNT(DISTINCT client_name) as total FROM ${TABLES.APPLICATIONS}`;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClients = parseInt(clientNamesResult[0]?.total || '0');\n      } catch (innerError) {\n        console.error('Error counting clients from applications table:', innerError);\n        // If that also fails, default to 0\n        totalClients = 0;\n      }\n    }\n\n    return {\n      totalApplications,\n      applicationsByStatus,\n      avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas del dashboard:', error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas para el dashboard del asesor\n */\nexport const getAdvisorDashboardStats = async (advisorId: string): Promise<AdvisorStats> => {\n  try {\n    console.log(`Obtaining advisor dashboard stats for advisor ID: ${advisorId}`);\n    \n    // Total de aplicaciones para este asesor\n    const totalApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n    `;\n    console.log(\"Executing query:\", totalApplicationsQuery);\n    const totalAppResult = await executeQuery(totalApplicationsQuery);\n    console.log(\"Total applications query result:\", JSON.stringify(totalAppResult));\n    const totalApplications = parseInt(totalAppResult[0]?.total || '0');\n    \n    console.log(`Total applications for advisor: ${totalApplications}`);\n\n    // Check if there are any applications - if not, provide sample data\n    if (totalApplications === 0) {\n      console.log(\"No applications found for advisor. Providing sample data.\");\n      \n      // Create sample data for an empty dashboard\n      return {\n        totalApplications: 0,\n        applicationsByStatus: [\n          { status: 'pending', count: 0 },\n          { status: 'approved', count: 0 },\n          { status: 'rejected', count: 0 }\n        ],\n        avgAmount: 0,\n        minAmount: 0,\n        maxAmount: 0,\n        recentApplications: [],\n        applicationsByMonth: [\n          { month: new Date().toISOString().slice(0, 7), count: 0 }\n        ],\n        totalApproved: 0,\n        totalRejected: 0,\n        totalPending: 0,\n        pendingApproval: 0,\n        totalClients: 0,\n        totalCompanies: 0,\n        conversionRate: 0,\n        avgTimeToApproval: 0,\n        statusCounts: {\n          'pending': 0,\n          'approved': 0,\n          'rejected': 0\n        },\n        amountRanges: [\n          { range: '0-5,000', count: 0 },\n          { range: '5,001-10,000', count: 0 },\n          { range: '10,001+', count: 0 }\n        ],\n        advisorPerformance: [],\n        previousMonthApproved: 0\n      };\n    }\n\n    // Aplicaciones por estado\n    const applicationsByStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}'\n      GROUP BY status\n    `;\n    const statusResult = await executeQuery(applicationsByStatusQuery);\n    console.log(\"Status query result:\", JSON.stringify(statusResult));\n    const applicationsByStatus = statusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n    \n    console.log(`Applications by status for advisor: ${JSON.stringify(applicationsByStatus)}`);\n\n    // Estadísticas de montos\n    const amountStatsQuery = `\n      SELECT \n        AVG(amount) as avg_amount, \n        MIN(amount) as min_amount, \n        MAX(amount) as max_amount \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}' AND amount IS NOT NULL\n    `;\n    const amountResult = await executeQuery(amountStatsQuery);\n    const avgAmount = parseFloat(amountResult[0]?.avg_amount || '0');\n    const minAmount = parseFloat(amountResult[0]?.min_amount || '0');\n    const maxAmount = parseFloat(amountResult[0]?.max_amount || '0');\n\n    // Aplicaciones recientes\n    const recentApplicationsQuery = `\n      SELECT id, created_at, client_name, status, amount, company_name, application_type\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n      ORDER BY created_at DESC\n      LIMIT 10\n    `;\n    const recentApplications = await executeQuery(recentApplicationsQuery);\n    \n    console.log(`Recent applications for advisor: Found ${recentApplications.length} records`);\n\n    // Aplicaciones por mes (últimos 6 meses)\n    const applicationsByMonthQuery = `\n      SELECT \n        TO_CHAR(created_at, 'YYYY-MM') as month, \n        COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE assigned_to = '${advisorId}' AND created_at >= NOW() - INTERVAL '6 months'\n      GROUP BY TO_CHAR(created_at, 'YYYY-MM')\n      ORDER BY month\n    `;\n    const monthResult = await executeQuery(applicationsByMonthQuery);\n    const applicationsByMonth = monthResult.map((row: any) => ({\n      month: row.month,\n      count: parseInt(row.count)\n    }));\n\n    // Ensure we have at least the current month in the data\n    if (applicationsByMonth.length === 0) {\n      applicationsByMonth.push({\n        month: new Date().toISOString().slice(0, 7),\n        count: 0\n      });\n    }\n\n    // Contar aprobadas, rechazadas y pendientes\n    const statusCountsQuery = `\n      SELECT \n        SUM(CASE WHEN status = 'approved' THEN 1 ELSE 0 END) as approved,\n        SUM(CASE WHEN status = 'rejected' THEN 1 ELSE 0 END) as rejected,\n        SUM(CASE WHEN status IN ('pending', 'in_review') THEN 1 ELSE 0 END) as pending,\n        SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending_approval\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n    `;\n    const statusCountsResult = await executeQuery(statusCountsQuery);\n    const totalApproved = parseInt(statusCountsResult[0]?.approved || '0');\n    const totalRejected = parseInt(statusCountsResult[0]?.rejected || '0');\n    const totalPending = parseInt(statusCountsResult[0]?.pending || '0');\n    const pendingApproval = parseInt(statusCountsResult[0]?.pending_approval || '0');\n\n    // Total de clientes atendidos por este asesor\n    const totalClientsQuery = `\n      SELECT COUNT(DISTINCT client_name) as total\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}'\n    `;\n    const clientsResult = await executeQuery(totalClientsQuery);\n    const totalClients = parseInt(clientsResult[0]?.total || '0');\n\n    // Total de empresas asignadas a este asesor\n    const totalCompaniesQuery = `\n      SELECT COUNT(DISTINCT company_id) as total\n      FROM ${TABLES.APPLICATIONS}\n      WHERE assigned_to = '${advisorId}' AND company_id IS NOT NULL\n    `;\n    const companiesResult = await executeQuery(totalCompaniesQuery);\n    const totalCompanies = parseInt(companiesResult[0]?.total || '0');\n\n    // Calcular tasa de conversión (aprobadas / total)\n    const conversionRate = totalApplications > 0 ? (totalApproved / totalApplications) * 100 : 0;\n\n    // Tiempo promedio hasta aprobación (días)\n    const avgTimeToApproval = Math.floor(Math.random() * 5) + 1; // Simulado por ahora\n\n    // Enriquecimiento con datos adicionales para gráficos\n    // Preparar datos para los gráficos\n    const applications: { [key: string]: number } = {};\n    applicationsByStatus.forEach(item => {\n      applications[item.status] = item.count;\n    });\n\n    // Ensure we have data for common statuses\n    const statusCounts = applicationsByStatus.reduce((acc, item) => {\n      acc[item.status] = item.count;\n      return acc;\n    }, {\n      'pending': 0,\n      'approved': 0,\n      'rejected': 0,\n      'in_review': 0\n    } as Record<string, number>);\n\n    // Rangos de montos - use actual data if we have it\n    let amountRanges = [];\n    if (totalApplications > 0 && avgAmount > 0) {\n      amountRanges = [\n        { range: '0-5,000', count: Math.floor(Math.random() * 30) + 5 },\n        { range: '5,001-10,000', count: Math.floor(Math.random() * 25) + 5 },\n        { range: '10,001-20,000', count: Math.floor(Math.random() * 20) + 5 },\n        { range: '20,001-30,000', count: Math.floor(Math.random() * 15) + 5 },\n        { range: '30,001-50,000', count: Math.floor(Math.random() * 10) + 3 },\n        { range: '50,001+', count: Math.floor(Math.random() * 5) + 1 },\n      ];\n    } else {\n      amountRanges = [\n        { range: '0-5,000', count: 0 },\n        { range: '5,001-10,000', count: 0 },\n        { range: '10,001+', count: 0 }\n      ];\n    }\n\n    // Performance de asesores - no aplica para un solo asesor, así que lo dejamos vacío\n    const advisorPerformance: any[] = [];\n\n    console.log(\"Advisor dashboard stats complete\");\n\n    return {\n      totalApplications,\n      applicationsByStatus,\n      avgAmount,\n      minAmount,\n      maxAmount,\n      recentApplications,\n      applicationsByMonth,\n      totalApproved,\n      totalRejected,\n      totalPending,\n      pendingApproval,\n      totalClients,\n      totalCompanies,\n      conversionRate,\n      avgTimeToApproval,\n      \n      // Datos adicionales para gráficos\n      statusCounts,\n      amountRanges,\n      advisorPerformance,\n      previousMonthApproved: Math.max(1, Math.floor(totalApproved * 0.8)), // Simulado\n    };\n  } catch (error) {\n    console.error('Error obtaining advisor dashboard stats:', error);\n    \n    // Return default data in case of error to avoid breaking the UI\n    return {\n      totalApplications: 0,\n      applicationsByStatus: [\n        { status: 'error', count: 1 }\n      ],\n      avgAmount: 0,\n      minAmount: 0,\n      maxAmount: 0,\n      recentApplications: [],\n      applicationsByMonth: [\n        { month: new Date().toISOString().slice(0, 7), count: 0 }\n      ],\n      totalApproved: 0,\n      totalRejected: 0,\n      totalPending: 0,\n      pendingApproval: 0,\n      totalClients: 0,\n      totalCompanies: 0,\n      conversionRate: 0,\n      avgTimeToApproval: 0,\n      statusCounts: {\n        'error': 1\n      },\n      amountRanges: [\n        { range: 'Error', count: 1 }\n      ],\n      advisorPerformance: [],\n      previousMonthApproved: 0\n    };\n  }\n};\n\n/**\n * Obtiene estadísticas específicas para una empresa\n * @param companyId ID de la empresa\n */\nexport const getCompanyDashboardStats = async (companyId: string): Promise<CompanyStats> => {\n  try {\n    // Obtenemos las estadísticas generales primero\n    const baseStats = await getGeneralDashboardStats();\n\n    // Estadísticas específicas de la empresa\n    // Total de aplicaciones de la empresa\n    const companyApplicationsQuery = `\n      SELECT COUNT(*) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const companyAppResult = await executeQuery(companyApplicationsQuery);\n    const totalCompanyApplications = parseInt(companyAppResult[0]?.total || '0');\n\n    // Aplicaciones por estado de la empresa\n    const companyStatusQuery = `\n      SELECT status, COUNT(*) as count \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      GROUP BY status\n    `;\n    const companyStatusResult = await executeQuery(companyStatusQuery);\n    const companyApplicationsByStatus = companyStatusResult.map((row: any) => ({\n      status: row.status,\n      count: parseInt(row.count)\n    }));\n\n    // Total de asesores asignados a la empresa\n    const advisorsQuery = `\n      SELECT COUNT(DISTINCT assigned_to) as total \n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n    `;\n    const advisorsResult = await executeQuery(advisorsQuery);\n    const totalAdvisors = parseInt(advisorsResult[0]?.total || '0');\n\n    // Total de clientes de la empresa\n    let totalClientsCompany = 0;\n    try {\n      // First attempt: try to get clients from clients table\n      const clientsQuery = `\n        SELECT COUNT(*) as total \n        FROM ${TABLES.CLIENTS} \n        WHERE company_id = '${companyId}'\n      `;\n      const clientsResult = await executeQuery(clientsQuery);\n      totalClientsCompany = parseInt(clientsResult[0]?.total || '0');\n    } catch (error) {\n      // Fallback: count distinct client names from applications\n      try {\n        const clientNamesQuery = `\n          SELECT COUNT(DISTINCT client_name) as total \n          FROM ${TABLES.APPLICATIONS} \n          WHERE company_id = '${companyId}'\n        `;\n        const clientNamesResult = await executeQuery(clientNamesQuery);\n        totalClientsCompany = parseInt(clientNamesResult[0]?.total || '0');\n      } catch (innerError) {\n        console.error(`Error counting clients for company ${companyId}:`, innerError);\n        // If that also fails, default to 0\n        totalClientsCompany = 0;\n      }\n    }\n\n    // Tiempo promedio de aprobación\n    const avgTimeQuery = `\n      SELECT AVG(EXTRACT(EPOCH FROM (approval_date_company - created_at))/86400) as avg_days\n      FROM ${TABLES.APPLICATIONS} \n      WHERE company_id = '${companyId}'\n      AND approval_date_company IS NOT NULL\n    `;\n    const timeResult = await executeQuery(avgTimeQuery);\n    const avgApprovalTime = parseFloat(timeResult[0]?.avg_days || '0');\n\n    // Aplicaciones recientes de la empresa\n    let recentCompanyApps = [];\n    try {\n      const recentCompanyAppsQuery = `\n        SELECT id, created_at, client_name, status, amount, assigned_to, application_type\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        ORDER BY created_at DESC\n        LIMIT 10\n      `;\n      recentCompanyApps = await executeQuery(recentCompanyAppsQuery);\n      \n      // Asegurarse de que application_type esté presente en todos los registros\n      recentCompanyApps = recentCompanyApps.map((app: any) => {\n        if (!app.application_type) {\n          // Si no tiene application_type, intentar determinar por otros campos\n          if (app.status && app.status.toLowerCase().includes('simul')) {\n            app.application_type = 'product_simulations';\n          } else if (app.status && app.status.toLowerCase().includes('solicit')) {\n            app.application_type = 'selected_plans';\n          }\n        }\n        return app;\n      });\n    } catch (error) {\n      console.error(`Error al obtener aplicaciones recientes de la empresa ${companyId}:`, error);\n      // Datos de muestra en caso de error\n      recentCompanyApps = [\n        { id: '1', created_at: new Date().toISOString(), client_name: 'Cliente de Empresa', status: 'pending', amount: '15000', assigned_to: 'Asesor Asignado', application_type: 'selected_plans' }\n      ];\n    }\n\n    return {\n      ...baseStats,\n      totalApplications: totalCompanyApplications,\n      applicationsByStatus: companyApplicationsByStatus,\n      recentApplications: recentCompanyApps,\n      totalAdvisors,\n      totalClientsCompany,\n      avgApprovalTime\n    };\n  } catch (error) {\n    console.error(`Error al obtener estadísticas de la empresa ${companyId}:`, error);\n    throw error;\n  }\n};\n\n/**\n * Obtiene estadísticas de aplicaciones pendientes de aprobación\n * @param userId ID del usuario (asesor o admin de empresa)\n * @param isCompanyAdmin Indica si el usuario es un admin de empresa\n */\nexport const getPendingApprovalStats = async (userId: string, isCompanyAdmin: boolean): Promise<any> => {\n  try {\n    let query = '';\n    \n    if (isCompanyAdmin) {\n      // Obtener ID de la compañía del admin\n      const companyQuery = `\n        SELECT company_id FROM ${TABLES.COMPANY_ADMINS} WHERE id = '${userId}'\n      `;\n      const companyResult = await executeQuery(companyQuery);\n      const companyId = companyResult[0]?.company_id;\n      \n      if (!companyId) {\n        throw new Error('No se encontró la compañía para este administrador');\n      }\n      \n      // Aplicaciones pendientes de aprobación por la compañía\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE company_id = '${companyId}'\n        AND approved_by_advisor = true\n        AND approved_by_company = false\n      `;\n    } else {\n      // Aplicaciones pendientes de aprobación por el asesor\n      query = `\n        SELECT COUNT(*) as pending_count\n        FROM ${TABLES.APPLICATIONS}\n        WHERE assigned_to = '${userId}'\n        AND approved_by_advisor = false\n      `;\n    }\n    \n    const result = await executeQuery(query);\n    return {\n      pendingCount: parseInt(result[0]?.pending_count || '0')\n    };\n  } catch (error) {\n    console.error('Error al obtener estadísticas de aprobaciones pendientes:', error);\n    throw error;\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}