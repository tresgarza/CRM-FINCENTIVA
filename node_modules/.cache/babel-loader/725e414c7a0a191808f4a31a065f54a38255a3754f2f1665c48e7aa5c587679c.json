{"ast":null,"code":"import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\nconst CLIENTS_TABLE = TABLES.CLIENTS;\n\n// Get all clients with filters\nexport const getClients = async filters => {\n  try {\n    let query = supabase.from(CLIENTS_TABLE).select('*', {\n      count: 'exact'\n    });\n\n    // Apply filters\n    if (filters) {\n      // Filter by advisor\n      if (filters.advisor_id) {\n        query = query.eq('advisor_id', filters.advisor_id);\n      }\n\n      // Filter by company\n      if (filters.company_id) {\n        query = query.eq('company_id', filters.company_id);\n      }\n\n      // Filter by date range\n      if (filters.dateFrom) {\n        query = query.gte('created_at', filters.dateFrom);\n      }\n      if (filters.dateTo) {\n        query = query.lte('created_at', filters.dateTo);\n      }\n\n      // Search by name, email, phone, RFC or CURP\n      if (filters.searchQuery) {\n        query = query.or(`name.ilike.%${filters.searchQuery}%,email.ilike.%${filters.searchQuery}%,phone.ilike.%${filters.searchQuery}%,rfc.ilike.%${filters.searchQuery}%,curp.ilike.%${filters.searchQuery}%`);\n      }\n\n      // Apply pagination if provided\n      if (filters.page !== undefined && filters.pageSize) {\n        const from = filters.page * filters.pageSize;\n        const to = from + filters.pageSize - 1;\n        query = query.range(from, to);\n      }\n    }\n\n    // Order by most recent first\n    query = query.order('created_at', {\n      ascending: false\n    });\n    const {\n      data,\n      error,\n      count\n    } = await query;\n    if (error) {\n      var _error$message;\n      // Check if the error is because the table doesn't exist\n      if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Using fallback empty list.');\n        return {\n          clients: [],\n          totalCount: 0\n        };\n      }\n      console.error('Error fetching clients:', error);\n      throw error;\n    }\n    return {\n      clients: data,\n      totalCount: count || 0\n    };\n  } catch (error) {\n    // For any other errors, return an empty list\n    console.error('Error in getClients:', error);\n    return {\n      clients: [],\n      totalCount: 0\n    };\n  }\n};\n\n// Get a single client by ID\nexport const getClientById = async id => {\n  const {\n    data,\n    error\n  } = await supabase.from(CLIENTS_TABLE).select('*').eq('id', id).single();\n  if (error) {\n    console.error(`Error fetching client with ID ${id}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Función para escapar cadenas de texto para SQL\nfunction escapeSQLString(str) {\n  if (!str) return '';\n  return str.replace(/'/g, \"''\");\n}\n\n// Get client applications\nexport const getClientApplications = async clientId => {\n  // Consultar aplicaciones usando MCP en lugar de Supabase\n  try {\n    // Primero obtenemos el cliente para saber su nombre\n    const client = await getClientById(clientId);\n\n    // Luego usamos el nombre del cliente para buscar aplicaciones\n    const query = `\n      SELECT * FROM ${TABLES.APPLICATIONS}\n      WHERE client_name = '${escapeSQLString(client.name)}'\n      ORDER BY created_at DESC\n    `;\n\n    // Usamos executeQuery que es el método para el MCP\n    const executeQuery = async query => {\n      try {\n        const response = await fetch('http://localhost:3100/query', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            query\n          })\n        });\n        const result = await response.json();\n        if (result.error) {\n          console.error('Error en la consulta SQL:', result.error);\n          throw new Error(result.error);\n        }\n        return result.data;\n      } catch (error) {\n        console.error('Error ejecutando la consulta:', error);\n        throw error;\n      }\n    };\n    const data = await executeQuery(query);\n    return data;\n  } catch (error) {\n    console.error(`Error fetching applications for client ${clientId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new client\nexport const createClient = async client => {\n  const {\n    data,\n    error\n  } = await supabase.from(CLIENTS_TABLE).insert([client]).select();\n  if (error) {\n    console.error('Error creating client:', error);\n    throw error;\n  }\n  return data[0];\n};\n\n// Update an existing client\nexport const updateClient = async (id, updates) => {\n  const {\n    data,\n    error\n  } = await supabase.from(CLIENTS_TABLE).update(updates).eq('id', id).select();\n  if (error) {\n    console.error(`Error updating client with ID ${id}:`, error);\n    throw error;\n  }\n  return data[0];\n};\n\n// Delete a client\nexport const deleteClient = async id => {\n  const {\n    error\n  } = await supabase.from(CLIENTS_TABLE).delete().eq('id', id);\n  if (error) {\n    console.error(`Error deleting client with ID ${id}:`, error);\n    throw error;\n  }\n  return true;\n};\n\n// Check if a client exists with the given email or RFC\nexport const checkClientExists = async (email, rfc) => {\n  let query = supabase.from(CLIENTS_TABLE).select('id, email, rfc').eq('email', email);\n  if (rfc) {\n    query = query.or(`rfc.eq.${rfc}`);\n  }\n  const {\n    data,\n    error\n  } = await query;\n  if (error) {\n    console.error('Error checking client existence:', error);\n    throw error;\n  }\n  return data.length > 0 ? data[0] : null;\n};\n\n// Get client count by filters\nexport const getClientCount = async filters => {\n  let query = supabase.from(CLIENTS_TABLE).select('id', {\n    count: 'exact',\n    head: true\n  });\n\n  // Apply filters\n  if (filters) {\n    // Filter by advisor\n    if (filters.advisor_id) {\n      query = query.eq('advisor_id', filters.advisor_id);\n    }\n\n    // Filter by company\n    if (filters.company_id) {\n      query = query.eq('company_id', filters.company_id);\n    }\n\n    // Filter by date range\n    if (filters.dateFrom) {\n      query = query.gte('created_at', filters.dateFrom);\n    }\n    if (filters.dateTo) {\n      query = query.lte('created_at', filters.dateTo);\n    }\n\n    // Search by name, email or phone\n    if (filters.searchQuery) {\n      query = query.or(`name.ilike.%${filters.searchQuery}%,email.ilike.%${filters.searchQuery}%,phone.ilike.%${filters.searchQuery}%,rfc.ilike.%${filters.searchQuery}%,curp.ilike.%${filters.searchQuery}%`);\n    }\n  }\n  const {\n    count,\n    error\n  } = await query;\n  if (error) {\n    console.error('Error getting client count:', error);\n    throw error;\n  }\n  return count || 0;\n};","map":{"version":3,"names":["supabase","TABLES","CLIENTS_TABLE","CLIENTS","getClients","filters","query","from","select","count","advisor_id","eq","company_id","dateFrom","gte","dateTo","lte","searchQuery","or","page","undefined","pageSize","to","range","order","ascending","data","error","_error$message","message","includes","code","console","warn","clients","totalCount","getClientById","id","single","escapeSQLString","str","replace","getClientApplications","clientId","client","APPLICATIONS","name","executeQuery","response","fetch","method","headers","body","JSON","stringify","result","json","Error","createClient","insert","updateClient","updates","update","deleteClient","delete","checkClientExists","email","rfc","length","getClientCount","head"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/clientService.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\n\nexport interface Client {\n  id: string;\n  created_at: string;\n  name: string;\n  email: string;\n  phone: string;\n  address?: string;\n  city?: string;\n  state?: string;\n  postal_code?: string;\n  birth_date?: string;\n  rfc?: string;\n  curp?: string;\n  company_id?: string;\n  advisor_id?: string;\n}\n\nexport interface ClientFilter {\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n  page?: number;\n  pageSize?: number;\n}\n\nconst CLIENTS_TABLE = TABLES.CLIENTS;\n\n// Get all clients with filters\nexport const getClients = async (filters?: ClientFilter) => {\n  try {\n    let query = supabase.from(CLIENTS_TABLE).select('*', { count: 'exact' });\n\n    // Apply filters\n    if (filters) {\n      // Filter by advisor\n      if (filters.advisor_id) {\n        query = query.eq('advisor_id', filters.advisor_id);\n      }\n\n      // Filter by company\n      if (filters.company_id) {\n        query = query.eq('company_id', filters.company_id);\n      }\n\n      // Filter by date range\n      if (filters.dateFrom) {\n        query = query.gte('created_at', filters.dateFrom);\n      }\n\n      if (filters.dateTo) {\n        query = query.lte('created_at', filters.dateTo);\n      }\n\n      // Search by name, email, phone, RFC or CURP\n      if (filters.searchQuery) {\n        query = query.or(\n          `name.ilike.%${filters.searchQuery}%,email.ilike.%${filters.searchQuery}%,phone.ilike.%${filters.searchQuery}%,rfc.ilike.%${filters.searchQuery}%,curp.ilike.%${filters.searchQuery}%`\n        );\n      }\n\n      // Apply pagination if provided\n      if (filters.page !== undefined && filters.pageSize) {\n        const from = filters.page * filters.pageSize;\n        const to = from + filters.pageSize - 1;\n        query = query.range(from, to);\n      }\n    }\n\n    // Order by most recent first\n    query = query.order('created_at', { ascending: false });\n\n    const { data, error, count } = await query;\n\n    if (error) {\n      // Check if the error is because the table doesn't exist\n      if (error.message?.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Using fallback empty list.');\n        return {\n          clients: [],\n          totalCount: 0\n        };\n      }\n      \n      console.error('Error fetching clients:', error);\n      throw error;\n    }\n\n    return {\n      clients: data as Client[],\n      totalCount: count || 0\n    };\n  } catch (error) {\n    // For any other errors, return an empty list\n    console.error('Error in getClients:', error);\n    return {\n      clients: [],\n      totalCount: 0\n    };\n  }\n};\n\n// Get a single client by ID\nexport const getClientById = async (id: string) => {\n  const { data, error } = await supabase\n    .from(CLIENTS_TABLE)\n    .select('*')\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    console.error(`Error fetching client with ID ${id}:`, error);\n    throw error;\n  }\n\n  return data as Client;\n};\n\n// Función para escapar cadenas de texto para SQL\nfunction escapeSQLString(str: string) {\n  if (!str) return '';\n  return str.replace(/'/g, \"''\");\n}\n\n// Get client applications\nexport const getClientApplications = async (clientId: string) => {\n  // Consultar aplicaciones usando MCP en lugar de Supabase\n  try {\n    // Primero obtenemos el cliente para saber su nombre\n    const client = await getClientById(clientId);\n    \n    // Luego usamos el nombre del cliente para buscar aplicaciones\n    const query = `\n      SELECT * FROM ${TABLES.APPLICATIONS}\n      WHERE client_name = '${escapeSQLString(client.name)}'\n      ORDER BY created_at DESC\n    `;\n    \n    // Usamos executeQuery que es el método para el MCP\n    const executeQuery = async (query: string) => {\n      try {\n        const response = await fetch('http://localhost:3100/query', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({ query }),\n        });\n        \n        const result = await response.json();\n        \n        if (result.error) {\n          console.error('Error en la consulta SQL:', result.error);\n          throw new Error(result.error);\n        }\n        \n        return result.data;\n      } catch (error) {\n        console.error('Error ejecutando la consulta:', error);\n        throw error;\n      }\n    };\n    \n    const data = await executeQuery(query);\n    return data;\n  } catch (error) {\n    console.error(`Error fetching applications for client ${clientId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new client\nexport const createClient = async (client: Omit<Client, 'id' | 'created_at'>) => {\n  const { data, error } = await supabase\n    .from(CLIENTS_TABLE)\n    .insert([client])\n    .select();\n\n  if (error) {\n    console.error('Error creating client:', error);\n    throw error;\n  }\n\n  return data[0] as Client;\n};\n\n// Update an existing client\nexport const updateClient = async (id: string, updates: Partial<Client>) => {\n  const { data, error } = await supabase\n    .from(CLIENTS_TABLE)\n    .update(updates)\n    .eq('id', id)\n    .select();\n\n  if (error) {\n    console.error(`Error updating client with ID ${id}:`, error);\n    throw error;\n  }\n\n  return data[0] as Client;\n};\n\n// Delete a client\nexport const deleteClient = async (id: string) => {\n  const { error } = await supabase\n    .from(CLIENTS_TABLE)\n    .delete()\n    .eq('id', id);\n\n  if (error) {\n    console.error(`Error deleting client with ID ${id}:`, error);\n    throw error;\n  }\n\n  return true;\n};\n\n// Check if a client exists with the given email or RFC\nexport const checkClientExists = async (email: string, rfc?: string) => {\n  let query = supabase\n    .from(CLIENTS_TABLE)\n    .select('id, email, rfc')\n    .eq('email', email);\n\n  if (rfc) {\n    query = query.or(`rfc.eq.${rfc}`);\n  }\n\n  const { data, error } = await query;\n\n  if (error) {\n    console.error('Error checking client existence:', error);\n    throw error;\n  }\n\n  return data.length > 0 ? data[0] : null;\n};\n\n// Get client count by filters\nexport const getClientCount = async (filters?: ClientFilter) => {\n  let query = supabase\n    .from(CLIENTS_TABLE)\n    .select('id', { count: 'exact', head: true });\n\n  // Apply filters\n  if (filters) {\n    // Filter by advisor\n    if (filters.advisor_id) {\n      query = query.eq('advisor_id', filters.advisor_id);\n    }\n\n    // Filter by company\n    if (filters.company_id) {\n      query = query.eq('company_id', filters.company_id);\n    }\n\n    // Filter by date range\n    if (filters.dateFrom) {\n      query = query.gte('created_at', filters.dateFrom);\n    }\n\n    if (filters.dateTo) {\n      query = query.lte('created_at', filters.dateTo);\n    }\n\n    // Search by name, email or phone\n    if (filters.searchQuery) {\n      query = query.or(\n        `name.ilike.%${filters.searchQuery}%,email.ilike.%${filters.searchQuery}%,phone.ilike.%${filters.searchQuery}%,rfc.ilike.%${filters.searchQuery}%,curp.ilike.%${filters.searchQuery}%`\n      );\n    }\n  }\n\n  const { count, error } = await query;\n\n  if (error) {\n    console.error('Error getting client count:', error);\n    throw error;\n  }\n\n  return count || 0;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}