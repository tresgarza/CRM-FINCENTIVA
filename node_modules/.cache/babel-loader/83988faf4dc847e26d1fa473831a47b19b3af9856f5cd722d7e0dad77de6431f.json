{"ast":null,"code":"import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async () => {\n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const {\n      data,\n      error\n    } = await supabase.storage.from(STORAGE_BUCKET).list();\n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || errorMessage.includes('does not exist') || errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async applicationId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('application_id', applicationId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async clientId => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('client_id', clientId).order('created_at', {\n    ascending: false\n  });\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async id => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).select('*').eq('id', id).single();\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n  return data;\n};\n\n// Upload a document\nexport async function uploadDocument(params) {\n  const {\n    file,\n    client_id,\n    application_id,\n    userId,\n    documentName,\n    category,\n    description\n  } = params;\n  console.log(`Starting document upload: ${documentName} for client ${client_id}`);\n  try {\n    // Primero creamos el registro para el documento\n    const {\n      data,\n      error\n    } = await supabase.from('document').insert([{\n      name: documentName,\n      category,\n      description: description || null,\n      client_id: client_id || null,\n      application_id: application_id || null,\n      created_by: userId\n    }]).select().single();\n    if (error) {\n      console.error('Error creating document record:', error);\n\n      // Mejorar el mensaje de error para problemas de RLS\n      if (error.message.includes('violates row-level security policy')) {\n        console.error('RLS policy violation detected on document table insert');\n        throw new Error('No tienes permisos para crear documentos. Contacta al administrador para configurar las políticas RLS.');\n      }\n      throw new Error(`Error al crear el registro del documento: ${error.message}`);\n    }\n    if (!data) {\n      throw new Error('No se recibió respuesta al crear el registro del documento');\n    }\n    const documentId = data.id;\n    console.log(`Document record created with ID: ${documentId}`);\n\n    // Ahora subimos el archivo al bucket de storage\n    // Implementamos reintentos con backoff exponencial\n    const MAX_RETRIES = 3;\n    let lastError = null;\n    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {\n      try {\n        console.log(`Uploading file for document ${documentId}, attempt ${attempt}/${MAX_RETRIES}`);\n\n        // Construir la ruta del archivo\n        let filePath;\n        if (client_id) {\n          filePath = `client_${client_id}/${documentId}`;\n        } else if (application_id) {\n          filePath = `application_${application_id}/${documentId}`;\n        } else {\n          filePath = `uncategorized/${documentId}`;\n        }\n\n        // Convertir el file blob a un ArrayBuffer para la carga\n        const arrayBuffer = await file.arrayBuffer();\n        const fileBuffer = new Uint8Array(arrayBuffer);\n\n        // Subir el archivo\n        const {\n          data: uploadData,\n          error: uploadError\n        } = await supabase.storage.from('documents').upload(filePath, fileBuffer, {\n          contentType: file.type,\n          upsert: true\n        });\n        if (uploadError) {\n          console.error(`Error uploading file (attempt ${attempt}/${MAX_RETRIES}):`, uploadError);\n\n          // Detección específica de problemas de RLS\n          if (uploadError.message.includes('violates row-level security policy') || uploadError.message.includes('Unauthorized') || typeof uploadError === 'object' && 'status' in uploadError && uploadError.status === 403) {\n            // No hacer más reintentos para errores de permisos\n            throw new Error('No tienes permisos para subir archivos al bucket. Contacta al administrador para configurar las políticas RLS del bucket \"documents\".');\n          }\n\n          // Lanzar error y permitir reintento\n          throw new Error(`Error al subir el archivo: ${uploadError.message}`);\n        }\n        if (!uploadData) {\n          throw new Error('No se recibió respuesta al subir el archivo');\n        }\n\n        // Actualizar el registro con la URL del archivo\n        const fileUrl = `${supabase.storage.from('documents').getPublicUrl(filePath).data.publicUrl}`;\n        const {\n          data: updatedData,\n          error: updateError\n        } = await supabase.from('document').update({\n          file_url: fileUrl,\n          file_path: filePath\n        }).eq('id', documentId).select().single();\n        if (updateError) {\n          console.error('Error updating document with file URL:', updateError);\n\n          // Intentar eliminar el archivo que subimos para evitar archivos huérfanos\n          try {\n            await supabase.storage.from('documents').remove([filePath]);\n            console.log(`Cleaned up orphaned file at ${filePath} after failed URL update`);\n          } catch (cleanupError) {\n            console.warn('Failed to clean up orphaned file after URL update error:', cleanupError);\n          }\n          throw new Error(`Error al actualizar el documento con la URL del archivo: ${updateError.message}`);\n        }\n        if (!updatedData) {\n          // Intentar eliminar el archivo que subimos\n          try {\n            await supabase.storage.from('documents').remove([filePath]);\n            console.log(`Cleaned up orphaned file at ${filePath} after failed document update`);\n          } catch (cleanupError) {\n            console.warn('Failed to clean up orphaned file after document update failure:', cleanupError);\n          }\n          throw new Error('No se recibió respuesta al actualizar el documento con la URL del archivo');\n        }\n        console.log(`Document ${documentId} successfully uploaded and updated with file URL`);\n\n        // Si llegamos aquí, todo salió bien\n        return updatedData;\n      } catch (error) {\n        lastError = error;\n\n        // Si es el último intento o es un error de permisos, no reintentamos\n        if (attempt === MAX_RETRIES || error instanceof Error && (error.message.includes('No tienes permisos') || error.message.includes('policy'))) {\n          break;\n        }\n\n        // Esperar antes de reintentar con backoff exponencial\n        const waitTime = 1000 * Math.pow(2, attempt - 1);\n        console.log(`Waiting ${waitTime}ms before retrying document upload...`);\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n      }\n    }\n\n    // Si llegamos aquí, todos los intentos fallaron\n    // Intentar eliminar el registro de documento ya que no pudimos subir el archivo\n    try {\n      await supabase.from('document').delete().eq('id', documentId);\n      console.log(`Deleted document record ${documentId} after failed file upload`);\n    } catch (deleteError) {\n      console.warn(`Warning: Could not delete document record ${documentId} after failed upload:`, deleteError);\n    }\n\n    // Lanzar el último error que ocurrió\n    throw lastError || new Error('Error desconocido al subir el documento');\n  } catch (error) {\n    const documentError = {\n      message: error instanceof Error ? error.message : 'Error desconocido al subir el documento',\n      details: error\n    };\n    console.error('Document upload error:', documentError);\n    throw error;\n  }\n}\n\n// Delete a document\nexport const deleteDocument = async documentId => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n\n    // Get document to get file path\n    const {\n      data: document,\n      error: fetchError\n    } = await supabase.from(DOCUMENTS_TABLE).select('file_path').eq('id', documentId).single();\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const {\n      error: storageError\n    } = await supabase.storage.from(STORAGE_BUCKET).remove([document.file_path]);\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error ? storageError.message : typeof storageError === 'object' && storageError !== null && 'message' in storageError ? String(storageError.message) : 'Error desconocido';\n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const {\n      error: deleteError\n    } = await supabase.from(DOCUMENTS_TABLE).delete().eq('id', documentId);\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async filePath => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    const {\n      data,\n      error\n    } = await supabase.storage.from(STORAGE_BUCKET).createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId, userId, isVerified = true) => {\n  const {\n    data,\n    error\n  } = await supabase.from(DOCUMENTS_TABLE).update({\n    is_verified: isVerified,\n    verified_by: userId,\n    verified_at: new Date().toISOString()\n  }).eq('id', documentId).select();\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n  return data[0];\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async applicationType => {\n  const {\n    data,\n    error\n  } = await supabase.from('required_documents').select('*').eq('application_type', applicationType);\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n  return data;\n};","map":{"version":3,"names":["supabase","TABLES","DOCUMENTS_TABLE","DOCUMENTS","STORAGE_BUCKET","ensureStorageBucketExists","data","error","storage","from","list","errorMessage","message","includes","console","log","Error","getApplicationDocuments","applicationId","select","eq","order","ascending","getClientDocuments","clientId","getDocumentById","id","single","uploadDocument","params","file","client_id","application_id","userId","documentName","category","description","insert","name","created_by","documentId","MAX_RETRIES","lastError","attempt","filePath","arrayBuffer","fileBuffer","Uint8Array","uploadData","uploadError","upload","contentType","type","upsert","status","fileUrl","getPublicUrl","publicUrl","updatedData","updateError","update","file_url","file_path","remove","cleanupError","warn","waitTime","Math","pow","Promise","resolve","setTimeout","delete","deleteError","documentError","details","deleteDocument","document","fetchError","storageError","String","getDocumentUrl","createSignedUrl","signedUrl","verifyDocument","isVerified","is_verified","verified_by","verified_at","Date","toISOString","getRequiredDocuments","applicationType"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/documentService.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { TABLES } from '../utils/constants/tables';\n\nexport interface Document {\n  id: string;\n  created_at: string;\n  file_name: string;\n  file_path: string;\n  file_type: string;\n  file_size: number;\n  category?: string;\n  application_id?: string;\n  client_id?: string;\n  uploaded_by_user_id?: string;\n  is_verified?: boolean;\n  verified_by?: string;\n  verified_at?: string;\n}\n\nexport interface DocumentUpload {\n  file: File;\n  application_id?: string;\n  client_id?: string;\n  userId: string;\n  documentName: string;\n  description?: string;\n  category?: string;\n}\n\n// Renombramos la interfaz para que coincida con el uso en uploadDocument\nexport type UploadDocumentParams = DocumentUpload;\n\nconst DOCUMENTS_TABLE = TABLES.DOCUMENTS;\nconst STORAGE_BUCKET = 'documents';\n\n// Ensure storage bucket exists\nexport const ensureStorageBucketExists = async () => {\n  try {\n    // Attempt to list files in the bucket instead of checking if bucket exists\n    // This is more reliable as it tests both existence and permissions\n    const { data, error } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .list();\n    \n    if (error) {\n      // If there's an error, it could be because the bucket doesn't exist\n      // or because of permissions issues\n      const errorMessage = error.message || 'Error desconocido';\n      if (errorMessage.includes('not found') || \n          errorMessage.includes('does not exist') || \n          errorMessage.includes('404')) {\n        console.log(`Storage bucket '${STORAGE_BUCKET}' does not exist`);\n        throw new Error(`El bucket de almacenamiento '${STORAGE_BUCKET}' no existe. Contacte al administrador.`);\n      } else {\n        console.error(`Error accessing storage bucket '${STORAGE_BUCKET}':`, error);\n        throw new Error(`Error al acceder al bucket de almacenamiento: ${errorMessage}`);\n      }\n    }\n    \n    console.log(`Storage bucket '${STORAGE_BUCKET}' exists and is accessible`);\n    return true;\n  } catch (error) {\n    console.error('Error in ensureStorageBucketExists:', error);\n    throw error;\n  }\n};\n\n// Get all documents for an application\nexport const getApplicationDocuments = async (applicationId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('application_id', applicationId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for application ${applicationId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get all documents for a client\nexport const getClientDocuments = async (clientId: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('client_id', clientId)\n    .order('created_at', { ascending: false });\n\n  if (error) {\n    console.error(`Error fetching documents for client ${clientId}:`, error);\n    throw error;\n  }\n\n  return data;\n};\n\n// Get a single document by ID\nexport const getDocumentById = async (id: string) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .select('*')\n    .eq('id', id)\n    .single();\n\n  if (error) {\n    console.error(`Error fetching document with ID ${id}:`, error);\n    throw error;\n  }\n\n  return data as Document;\n};\n\n// Upload a document\nexport async function uploadDocument(params: UploadDocumentParams): Promise<Document> {\n  const { file, client_id, application_id, userId, documentName, category, description } = params;\n  \n  console.log(`Starting document upload: ${documentName} for client ${client_id}`);\n  \n  try {\n    // Primero creamos el registro para el documento\n    const { data, error } = await supabase\n      .from('document')\n      .insert([\n        {\n          name: documentName,\n          category,\n          description: description || null,\n          client_id: client_id || null,\n          application_id: application_id || null,\n          created_by: userId,\n        },\n      ])\n      .select()\n      .single();\n\n    if (error) {\n      console.error('Error creating document record:', error);\n      \n      // Mejorar el mensaje de error para problemas de RLS\n      if (error.message.includes('violates row-level security policy')) {\n        console.error('RLS policy violation detected on document table insert');\n        throw new Error('No tienes permisos para crear documentos. Contacta al administrador para configurar las políticas RLS.');\n      }\n      \n      throw new Error(`Error al crear el registro del documento: ${error.message}`);\n    }\n\n    if (!data) {\n      throw new Error('No se recibió respuesta al crear el registro del documento');\n    }\n\n    const documentId = data.id;\n    console.log(`Document record created with ID: ${documentId}`);\n\n    // Ahora subimos el archivo al bucket de storage\n    // Implementamos reintentos con backoff exponencial\n    const MAX_RETRIES = 3;\n    let lastError = null;\n    \n    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {\n      try {\n        console.log(`Uploading file for document ${documentId}, attempt ${attempt}/${MAX_RETRIES}`);\n        \n        // Construir la ruta del archivo\n        let filePath: string;\n        if (client_id) {\n          filePath = `client_${client_id}/${documentId}`;\n        } else if (application_id) {\n          filePath = `application_${application_id}/${documentId}`;\n        } else {\n          filePath = `uncategorized/${documentId}`;\n        }\n\n        // Convertir el file blob a un ArrayBuffer para la carga\n        const arrayBuffer = await file.arrayBuffer();\n        const fileBuffer = new Uint8Array(arrayBuffer);\n\n        // Subir el archivo\n        const { data: uploadData, error: uploadError } = await supabase.storage\n          .from('documents')\n          .upload(filePath, fileBuffer, {\n            contentType: file.type,\n            upsert: true,\n          });\n\n        if (uploadError) {\n          console.error(`Error uploading file (attempt ${attempt}/${MAX_RETRIES}):`, uploadError);\n          \n          // Detección específica de problemas de RLS\n          if (uploadError.message.includes('violates row-level security policy') || \n              uploadError.message.includes('Unauthorized') ||\n              (typeof uploadError === 'object' && 'status' in uploadError && uploadError.status === 403)) {\n            // No hacer más reintentos para errores de permisos\n            throw new Error('No tienes permisos para subir archivos al bucket. Contacta al administrador para configurar las políticas RLS del bucket \"documents\".');\n          }\n          \n          // Lanzar error y permitir reintento\n          throw new Error(`Error al subir el archivo: ${uploadError.message}`);\n        }\n\n        if (!uploadData) {\n          throw new Error('No se recibió respuesta al subir el archivo');\n        }\n\n        // Actualizar el registro con la URL del archivo\n        const fileUrl = `${supabase.storage.from('documents').getPublicUrl(filePath).data.publicUrl}`;\n        \n        const { data: updatedData, error: updateError } = await supabase\n          .from('document')\n          .update({ file_url: fileUrl, file_path: filePath })\n          .eq('id', documentId)\n          .select()\n          .single();\n\n        if (updateError) {\n          console.error('Error updating document with file URL:', updateError);\n          \n          // Intentar eliminar el archivo que subimos para evitar archivos huérfanos\n          try {\n            await supabase.storage\n              .from('documents')\n              .remove([filePath]);\n            console.log(`Cleaned up orphaned file at ${filePath} after failed URL update`);\n          } catch (cleanupError) {\n            console.warn('Failed to clean up orphaned file after URL update error:', cleanupError);\n          }\n          \n          throw new Error(`Error al actualizar el documento con la URL del archivo: ${updateError.message}`);\n        }\n\n        if (!updatedData) {\n          // Intentar eliminar el archivo que subimos\n          try {\n            await supabase.storage\n              .from('documents')\n              .remove([filePath]);\n            console.log(`Cleaned up orphaned file at ${filePath} after failed document update`);\n          } catch (cleanupError) {\n            console.warn('Failed to clean up orphaned file after document update failure:', cleanupError);\n          }\n          \n          throw new Error('No se recibió respuesta al actualizar el documento con la URL del archivo');\n        }\n\n        console.log(`Document ${documentId} successfully uploaded and updated with file URL`);\n        \n        // Si llegamos aquí, todo salió bien\n        return updatedData;\n      } catch (error) {\n        lastError = error;\n        \n        // Si es el último intento o es un error de permisos, no reintentamos\n        if (attempt === MAX_RETRIES || \n            (error instanceof Error && \n             (error.message.includes('No tienes permisos') || \n              error.message.includes('policy')))) {\n          break;\n        }\n        \n        // Esperar antes de reintentar con backoff exponencial\n        const waitTime = 1000 * Math.pow(2, attempt - 1);\n        console.log(`Waiting ${waitTime}ms before retrying document upload...`);\n        await new Promise(resolve => setTimeout(resolve, waitTime));\n      }\n    }\n\n    // Si llegamos aquí, todos los intentos fallaron\n    // Intentar eliminar el registro de documento ya que no pudimos subir el archivo\n    try {\n      await supabase\n        .from('document')\n        .delete()\n        .eq('id', documentId);\n      console.log(`Deleted document record ${documentId} after failed file upload`);\n    } catch (deleteError) {\n      console.warn(`Warning: Could not delete document record ${documentId} after failed upload:`, deleteError);\n    }\n\n    // Lanzar el último error que ocurrió\n    throw lastError || new Error('Error desconocido al subir el documento');\n  } catch (error) {\n    const documentError = {\n      message: error instanceof Error ? error.message : 'Error desconocido al subir el documento',\n      details: error\n    };\n    console.error('Document upload error:', documentError);\n    throw error;\n  }\n}\n\n// Delete a document\nexport const deleteDocument = async (documentId: string) => {\n  try {\n    // Ensure bucket exists before attempting to delete\n    await ensureStorageBucketExists();\n    \n    // Get document to get file path\n    const { data: document, error: fetchError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .select('file_path')\n      .eq('id', documentId)\n      .single();\n\n    if (fetchError) {\n      console.error(`Error fetching document ${documentId} for deletion:`, fetchError);\n      throw fetchError;\n    }\n\n    // Delete file from storage\n    const { error: storageError } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .remove([document.file_path]);\n\n    if (storageError) {\n      console.error(`Error deleting file for document ${documentId}:`, storageError);\n      // Use type-safe error handling\n      const errorMessage = storageError instanceof Error \n        ? storageError.message \n        : (typeof storageError === 'object' && storageError !== null && 'message' in storageError)\n          ? String((storageError as {message: string}).message)\n          : 'Error desconocido';\n      \n      throw new Error(`Error al eliminar el archivo del documento: ${errorMessage}`);\n    }\n\n    // Delete document record\n    const { error: deleteError } = await supabase\n      .from(DOCUMENTS_TABLE)\n      .delete()\n      .eq('id', documentId);\n\n    if (deleteError) {\n      console.error(`Error deleting document record ${documentId}:`, deleteError);\n      throw deleteError;\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteDocument for ${documentId}:`, error);\n    throw error;\n  }\n};\n\n// Get document download URL\nexport const getDocumentUrl = async (filePath: string) => {\n  try {\n    // Ensure bucket exists before attempting to get URL\n    await ensureStorageBucketExists();\n    \n    const { data, error } = await supabase.storage\n      .from(STORAGE_BUCKET)\n      .createSignedUrl(filePath, 60 * 60); // 1 hour expiry\n\n    if (error) {\n      console.error(`Error getting URL for document ${filePath}:`, error);\n      throw error;\n    }\n\n    return data.signedUrl;\n  } catch (error) {\n    console.error(`Error in getDocumentUrl for ${filePath}:`, error);\n    throw error;\n  }\n};\n\n// Verify a document\nexport const verifyDocument = async (documentId: string, userId: string, isVerified: boolean = true) => {\n  const { data, error } = await supabase\n    .from(DOCUMENTS_TABLE)\n    .update({\n      is_verified: isVerified,\n      verified_by: userId,\n      verified_at: new Date().toISOString()\n    })\n    .eq('id', documentId)\n    .select();\n\n  if (error) {\n    console.error(`Error verifying document ${documentId}:`, error);\n    throw error;\n  }\n\n  return data[0] as Document;\n};\n\n// Get required documents (based on application type)\nexport const getRequiredDocuments = async (applicationType: string) => {\n  const { data, error } = await supabase\n    .from('required_documents')\n    .select('*')\n    .eq('application_type', applicationType);\n\n  if (error) {\n    console.error(`Error fetching required documents for ${applicationType}:`, error);\n    throw error;\n  }\n\n  return data;\n}; "],"mappings":"AAAA,SAASA,QAAQ,QAAQ,uBAAuB;AAChD,SAASC,MAAM,QAAQ,2BAA2B;;AA4BlD;;AAGA,MAAMC,eAAe,GAAGD,MAAM,CAACE,SAAS;AACxC,MAAMC,cAAc,GAAG,WAAW;;AAElC;AACA,OAAO,MAAMC,yBAAyB,GAAG,MAAAA,CAAA,KAAY;EACnD,IAAI;IACF;IACA;IACA,MAAM;MAAEC,IAAI;MAAEC;IAAM,CAAC,GAAG,MAAMP,QAAQ,CAACQ,OAAO,CAC3CC,IAAI,CAACL,cAAc,CAAC,CACpBM,IAAI,CAAC,CAAC;IAET,IAAIH,KAAK,EAAE;MACT;MACA;MACA,MAAMI,YAAY,GAAGJ,KAAK,CAACK,OAAO,IAAI,mBAAmB;MACzD,IAAID,YAAY,CAACE,QAAQ,CAAC,WAAW,CAAC,IAClCF,YAAY,CAACE,QAAQ,CAAC,gBAAgB,CAAC,IACvCF,YAAY,CAACE,QAAQ,CAAC,KAAK,CAAC,EAAE;QAChCC,OAAO,CAACC,GAAG,CAAC,mBAAmBX,cAAc,kBAAkB,CAAC;QAChE,MAAM,IAAIY,KAAK,CAAC,gCAAgCZ,cAAc,yCAAyC,CAAC;MAC1G,CAAC,MAAM;QACLU,OAAO,CAACP,KAAK,CAAC,mCAAmCH,cAAc,IAAI,EAAEG,KAAK,CAAC;QAC3E,MAAM,IAAIS,KAAK,CAAC,iDAAiDL,YAAY,EAAE,CAAC;MAClF;IACF;IAEAG,OAAO,CAACC,GAAG,CAAC,mBAAmBX,cAAc,4BAA4B,CAAC;IAC1E,OAAO,IAAI;EACb,CAAC,CAAC,OAAOG,KAAK,EAAE;IACdO,OAAO,CAACP,KAAK,CAAC,qCAAqC,EAAEA,KAAK,CAAC;IAC3D,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAMU,uBAAuB,GAAG,MAAOC,aAAqB,IAAK;EACtE,MAAM;IAAEZ,IAAI;IAAEC;EAAM,CAAC,GAAG,MAAMP,QAAQ,CACnCS,IAAI,CAACP,eAAe,CAAC,CACrBiB,MAAM,CAAC,GAAG,CAAC,CACXC,EAAE,CAAC,gBAAgB,EAAEF,aAAa,CAAC,CACnCG,KAAK,CAAC,YAAY,EAAE;IAAEC,SAAS,EAAE;EAAM,CAAC,CAAC;EAE5C,IAAIf,KAAK,EAAE;IACTO,OAAO,CAACP,KAAK,CAAC,4CAA4CW,aAAa,GAAG,EAAEX,KAAK,CAAC;IAClF,MAAMA,KAAK;EACb;EAEA,OAAOD,IAAI;AACb,CAAC;;AAED;AACA,OAAO,MAAMiB,kBAAkB,GAAG,MAAOC,QAAgB,IAAK;EAC5D,MAAM;IAAElB,IAAI;IAAEC;EAAM,CAAC,GAAG,MAAMP,QAAQ,CACnCS,IAAI,CAACP,eAAe,CAAC,CACrBiB,MAAM,CAAC,GAAG,CAAC,CACXC,EAAE,CAAC,WAAW,EAAEI,QAAQ,CAAC,CACzBH,KAAK,CAAC,YAAY,EAAE;IAAEC,SAAS,EAAE;EAAM,CAAC,CAAC;EAE5C,IAAIf,KAAK,EAAE;IACTO,OAAO,CAACP,KAAK,CAAC,uCAAuCiB,QAAQ,GAAG,EAAEjB,KAAK,CAAC;IACxE,MAAMA,KAAK;EACb;EAEA,OAAOD,IAAI;AACb,CAAC;;AAED;AACA,OAAO,MAAMmB,eAAe,GAAG,MAAOC,EAAU,IAAK;EACnD,MAAM;IAAEpB,IAAI;IAAEC;EAAM,CAAC,GAAG,MAAMP,QAAQ,CACnCS,IAAI,CAACP,eAAe,CAAC,CACrBiB,MAAM,CAAC,GAAG,CAAC,CACXC,EAAE,CAAC,IAAI,EAAEM,EAAE,CAAC,CACZC,MAAM,CAAC,CAAC;EAEX,IAAIpB,KAAK,EAAE;IACTO,OAAO,CAACP,KAAK,CAAC,mCAAmCmB,EAAE,GAAG,EAAEnB,KAAK,CAAC;IAC9D,MAAMA,KAAK;EACb;EAEA,OAAOD,IAAI;AACb,CAAC;;AAED;AACA,OAAO,eAAesB,cAAcA,CAACC,MAA4B,EAAqB;EACpF,MAAM;IAAEC,IAAI;IAAEC,SAAS;IAAEC,cAAc;IAAEC,MAAM;IAAEC,YAAY;IAAEC,QAAQ;IAAEC;EAAY,CAAC,GAAGP,MAAM;EAE/Ff,OAAO,CAACC,GAAG,CAAC,6BAA6BmB,YAAY,eAAeH,SAAS,EAAE,CAAC;EAEhF,IAAI;IACF;IACA,MAAM;MAAEzB,IAAI;MAAEC;IAAM,CAAC,GAAG,MAAMP,QAAQ,CACnCS,IAAI,CAAC,UAAU,CAAC,CAChB4B,MAAM,CAAC,CACN;MACEC,IAAI,EAAEJ,YAAY;MAClBC,QAAQ;MACRC,WAAW,EAAEA,WAAW,IAAI,IAAI;MAChCL,SAAS,EAAEA,SAAS,IAAI,IAAI;MAC5BC,cAAc,EAAEA,cAAc,IAAI,IAAI;MACtCO,UAAU,EAAEN;IACd,CAAC,CACF,CAAC,CACDd,MAAM,CAAC,CAAC,CACRQ,MAAM,CAAC,CAAC;IAEX,IAAIpB,KAAK,EAAE;MACTO,OAAO,CAACP,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;;MAEvD;MACA,IAAIA,KAAK,CAACK,OAAO,CAACC,QAAQ,CAAC,oCAAoC,CAAC,EAAE;QAChEC,OAAO,CAACP,KAAK,CAAC,wDAAwD,CAAC;QACvE,MAAM,IAAIS,KAAK,CAAC,wGAAwG,CAAC;MAC3H;MAEA,MAAM,IAAIA,KAAK,CAAC,6CAA6CT,KAAK,CAACK,OAAO,EAAE,CAAC;IAC/E;IAEA,IAAI,CAACN,IAAI,EAAE;MACT,MAAM,IAAIU,KAAK,CAAC,4DAA4D,CAAC;IAC/E;IAEA,MAAMwB,UAAU,GAAGlC,IAAI,CAACoB,EAAE;IAC1BZ,OAAO,CAACC,GAAG,CAAC,oCAAoCyB,UAAU,EAAE,CAAC;;IAE7D;IACA;IACA,MAAMC,WAAW,GAAG,CAAC;IACrB,IAAIC,SAAS,GAAG,IAAI;IAEpB,KAAK,IAAIC,OAAO,GAAG,CAAC,EAAEA,OAAO,IAAIF,WAAW,EAAEE,OAAO,EAAE,EAAE;MACvD,IAAI;QACF7B,OAAO,CAACC,GAAG,CAAC,+BAA+ByB,UAAU,aAAaG,OAAO,IAAIF,WAAW,EAAE,CAAC;;QAE3F;QACA,IAAIG,QAAgB;QACpB,IAAIb,SAAS,EAAE;UACba,QAAQ,GAAG,UAAUb,SAAS,IAAIS,UAAU,EAAE;QAChD,CAAC,MAAM,IAAIR,cAAc,EAAE;UACzBY,QAAQ,GAAG,eAAeZ,cAAc,IAAIQ,UAAU,EAAE;QAC1D,CAAC,MAAM;UACLI,QAAQ,GAAG,iBAAiBJ,UAAU,EAAE;QAC1C;;QAEA;QACA,MAAMK,WAAW,GAAG,MAAMf,IAAI,CAACe,WAAW,CAAC,CAAC;QAC5C,MAAMC,UAAU,GAAG,IAAIC,UAAU,CAACF,WAAW,CAAC;;QAE9C;QACA,MAAM;UAAEvC,IAAI,EAAE0C,UAAU;UAAEzC,KAAK,EAAE0C;QAAY,CAAC,GAAG,MAAMjD,QAAQ,CAACQ,OAAO,CACpEC,IAAI,CAAC,WAAW,CAAC,CACjByC,MAAM,CAACN,QAAQ,EAAEE,UAAU,EAAE;UAC5BK,WAAW,EAAErB,IAAI,CAACsB,IAAI;UACtBC,MAAM,EAAE;QACV,CAAC,CAAC;QAEJ,IAAIJ,WAAW,EAAE;UACfnC,OAAO,CAACP,KAAK,CAAC,iCAAiCoC,OAAO,IAAIF,WAAW,IAAI,EAAEQ,WAAW,CAAC;;UAEvF;UACA,IAAIA,WAAW,CAACrC,OAAO,CAACC,QAAQ,CAAC,oCAAoC,CAAC,IAClEoC,WAAW,CAACrC,OAAO,CAACC,QAAQ,CAAC,cAAc,CAAC,IAC3C,OAAOoC,WAAW,KAAK,QAAQ,IAAI,QAAQ,IAAIA,WAAW,IAAIA,WAAW,CAACK,MAAM,KAAK,GAAI,EAAE;YAC9F;YACA,MAAM,IAAItC,KAAK,CAAC,uIAAuI,CAAC;UAC1J;;UAEA;UACA,MAAM,IAAIA,KAAK,CAAC,8BAA8BiC,WAAW,CAACrC,OAAO,EAAE,CAAC;QACtE;QAEA,IAAI,CAACoC,UAAU,EAAE;UACf,MAAM,IAAIhC,KAAK,CAAC,6CAA6C,CAAC;QAChE;;QAEA;QACA,MAAMuC,OAAO,GAAG,GAAGvD,QAAQ,CAACQ,OAAO,CAACC,IAAI,CAAC,WAAW,CAAC,CAAC+C,YAAY,CAACZ,QAAQ,CAAC,CAACtC,IAAI,CAACmD,SAAS,EAAE;QAE7F,MAAM;UAAEnD,IAAI,EAAEoD,WAAW;UAAEnD,KAAK,EAAEoD;QAAY,CAAC,GAAG,MAAM3D,QAAQ,CAC7DS,IAAI,CAAC,UAAU,CAAC,CAChBmD,MAAM,CAAC;UAAEC,QAAQ,EAAEN,OAAO;UAAEO,SAAS,EAAElB;QAAS,CAAC,CAAC,CAClDxB,EAAE,CAAC,IAAI,EAAEoB,UAAU,CAAC,CACpBrB,MAAM,CAAC,CAAC,CACRQ,MAAM,CAAC,CAAC;QAEX,IAAIgC,WAAW,EAAE;UACf7C,OAAO,CAACP,KAAK,CAAC,wCAAwC,EAAEoD,WAAW,CAAC;;UAEpE;UACA,IAAI;YACF,MAAM3D,QAAQ,CAACQ,OAAO,CACnBC,IAAI,CAAC,WAAW,CAAC,CACjBsD,MAAM,CAAC,CAACnB,QAAQ,CAAC,CAAC;YACrB9B,OAAO,CAACC,GAAG,CAAC,+BAA+B6B,QAAQ,0BAA0B,CAAC;UAChF,CAAC,CAAC,OAAOoB,YAAY,EAAE;YACrBlD,OAAO,CAACmD,IAAI,CAAC,0DAA0D,EAAED,YAAY,CAAC;UACxF;UAEA,MAAM,IAAIhD,KAAK,CAAC,4DAA4D2C,WAAW,CAAC/C,OAAO,EAAE,CAAC;QACpG;QAEA,IAAI,CAAC8C,WAAW,EAAE;UAChB;UACA,IAAI;YACF,MAAM1D,QAAQ,CAACQ,OAAO,CACnBC,IAAI,CAAC,WAAW,CAAC,CACjBsD,MAAM,CAAC,CAACnB,QAAQ,CAAC,CAAC;YACrB9B,OAAO,CAACC,GAAG,CAAC,+BAA+B6B,QAAQ,+BAA+B,CAAC;UACrF,CAAC,CAAC,OAAOoB,YAAY,EAAE;YACrBlD,OAAO,CAACmD,IAAI,CAAC,iEAAiE,EAAED,YAAY,CAAC;UAC/F;UAEA,MAAM,IAAIhD,KAAK,CAAC,2EAA2E,CAAC;QAC9F;QAEAF,OAAO,CAACC,GAAG,CAAC,YAAYyB,UAAU,kDAAkD,CAAC;;QAErF;QACA,OAAOkB,WAAW;MACpB,CAAC,CAAC,OAAOnD,KAAK,EAAE;QACdmC,SAAS,GAAGnC,KAAK;;QAEjB;QACA,IAAIoC,OAAO,KAAKF,WAAW,IACtBlC,KAAK,YAAYS,KAAK,KACrBT,KAAK,CAACK,OAAO,CAACC,QAAQ,CAAC,oBAAoB,CAAC,IAC5CN,KAAK,CAACK,OAAO,CAACC,QAAQ,CAAC,QAAQ,CAAC,CAAE,EAAE;UACxC;QACF;;QAEA;QACA,MAAMqD,QAAQ,GAAG,IAAI,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEzB,OAAO,GAAG,CAAC,CAAC;QAChD7B,OAAO,CAACC,GAAG,CAAC,WAAWmD,QAAQ,uCAAuC,CAAC;QACvE,MAAM,IAAIG,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEJ,QAAQ,CAAC,CAAC;MAC7D;IACF;;IAEA;IACA;IACA,IAAI;MACF,MAAMlE,QAAQ,CACXS,IAAI,CAAC,UAAU,CAAC,CAChB+D,MAAM,CAAC,CAAC,CACRpD,EAAE,CAAC,IAAI,EAAEoB,UAAU,CAAC;MACvB1B,OAAO,CAACC,GAAG,CAAC,2BAA2ByB,UAAU,2BAA2B,CAAC;IAC/E,CAAC,CAAC,OAAOiC,WAAW,EAAE;MACpB3D,OAAO,CAACmD,IAAI,CAAC,6CAA6CzB,UAAU,uBAAuB,EAAEiC,WAAW,CAAC;IAC3G;;IAEA;IACA,MAAM/B,SAAS,IAAI,IAAI1B,KAAK,CAAC,yCAAyC,CAAC;EACzE,CAAC,CAAC,OAAOT,KAAK,EAAE;IACd,MAAMmE,aAAa,GAAG;MACpB9D,OAAO,EAAEL,KAAK,YAAYS,KAAK,GAAGT,KAAK,CAACK,OAAO,GAAG,yCAAyC;MAC3F+D,OAAO,EAAEpE;IACX,CAAC;IACDO,OAAO,CAACP,KAAK,CAAC,wBAAwB,EAAEmE,aAAa,CAAC;IACtD,MAAMnE,KAAK;EACb;AACF;;AAEA;AACA,OAAO,MAAMqE,cAAc,GAAG,MAAOpC,UAAkB,IAAK;EAC1D,IAAI;IACF;IACA,MAAMnC,yBAAyB,CAAC,CAAC;;IAEjC;IACA,MAAM;MAAEC,IAAI,EAAEuE,QAAQ;MAAEtE,KAAK,EAAEuE;IAAW,CAAC,GAAG,MAAM9E,QAAQ,CACzDS,IAAI,CAACP,eAAe,CAAC,CACrBiB,MAAM,CAAC,WAAW,CAAC,CACnBC,EAAE,CAAC,IAAI,EAAEoB,UAAU,CAAC,CACpBb,MAAM,CAAC,CAAC;IAEX,IAAImD,UAAU,EAAE;MACdhE,OAAO,CAACP,KAAK,CAAC,2BAA2BiC,UAAU,gBAAgB,EAAEsC,UAAU,CAAC;MAChF,MAAMA,UAAU;IAClB;;IAEA;IACA,MAAM;MAAEvE,KAAK,EAAEwE;IAAa,CAAC,GAAG,MAAM/E,QAAQ,CAACQ,OAAO,CACnDC,IAAI,CAACL,cAAc,CAAC,CACpB2D,MAAM,CAAC,CAACc,QAAQ,CAACf,SAAS,CAAC,CAAC;IAE/B,IAAIiB,YAAY,EAAE;MAChBjE,OAAO,CAACP,KAAK,CAAC,oCAAoCiC,UAAU,GAAG,EAAEuC,YAAY,CAAC;MAC9E;MACA,MAAMpE,YAAY,GAAGoE,YAAY,YAAY/D,KAAK,GAC9C+D,YAAY,CAACnE,OAAO,GACnB,OAAOmE,YAAY,KAAK,QAAQ,IAAIA,YAAY,KAAK,IAAI,IAAI,SAAS,IAAIA,YAAY,GACrFC,MAAM,CAAED,YAAY,CAAuBnE,OAAO,CAAC,GACnD,mBAAmB;MAEzB,MAAM,IAAII,KAAK,CAAC,+CAA+CL,YAAY,EAAE,CAAC;IAChF;;IAEA;IACA,MAAM;MAAEJ,KAAK,EAAEkE;IAAY,CAAC,GAAG,MAAMzE,QAAQ,CAC1CS,IAAI,CAACP,eAAe,CAAC,CACrBsE,MAAM,CAAC,CAAC,CACRpD,EAAE,CAAC,IAAI,EAAEoB,UAAU,CAAC;IAEvB,IAAIiC,WAAW,EAAE;MACf3D,OAAO,CAACP,KAAK,CAAC,kCAAkCiC,UAAU,GAAG,EAAEiC,WAAW,CAAC;MAC3E,MAAMA,WAAW;IACnB;IAEA,OAAO,IAAI;EACb,CAAC,CAAC,OAAOlE,KAAK,EAAE;IACdO,OAAO,CAACP,KAAK,CAAC,+BAA+BiC,UAAU,GAAG,EAAEjC,KAAK,CAAC;IAClE,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAM0E,cAAc,GAAG,MAAOrC,QAAgB,IAAK;EACxD,IAAI;IACF;IACA,MAAMvC,yBAAyB,CAAC,CAAC;IAEjC,MAAM;MAAEC,IAAI;MAAEC;IAAM,CAAC,GAAG,MAAMP,QAAQ,CAACQ,OAAO,CAC3CC,IAAI,CAACL,cAAc,CAAC,CACpB8E,eAAe,CAACtC,QAAQ,EAAE,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;;IAEvC,IAAIrC,KAAK,EAAE;MACTO,OAAO,CAACP,KAAK,CAAC,kCAAkCqC,QAAQ,GAAG,EAAErC,KAAK,CAAC;MACnE,MAAMA,KAAK;IACb;IAEA,OAAOD,IAAI,CAAC6E,SAAS;EACvB,CAAC,CAAC,OAAO5E,KAAK,EAAE;IACdO,OAAO,CAACP,KAAK,CAAC,+BAA+BqC,QAAQ,GAAG,EAAErC,KAAK,CAAC;IAChE,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAM6E,cAAc,GAAG,MAAAA,CAAO5C,UAAkB,EAAEP,MAAc,EAAEoD,UAAmB,GAAG,IAAI,KAAK;EACtG,MAAM;IAAE/E,IAAI;IAAEC;EAAM,CAAC,GAAG,MAAMP,QAAQ,CACnCS,IAAI,CAACP,eAAe,CAAC,CACrB0D,MAAM,CAAC;IACN0B,WAAW,EAAED,UAAU;IACvBE,WAAW,EAAEtD,MAAM;IACnBuD,WAAW,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC;EACtC,CAAC,CAAC,CACDtE,EAAE,CAAC,IAAI,EAAEoB,UAAU,CAAC,CACpBrB,MAAM,CAAC,CAAC;EAEX,IAAIZ,KAAK,EAAE;IACTO,OAAO,CAACP,KAAK,CAAC,4BAA4BiC,UAAU,GAAG,EAAEjC,KAAK,CAAC;IAC/D,MAAMA,KAAK;EACb;EAEA,OAAOD,IAAI,CAAC,CAAC,CAAC;AAChB,CAAC;;AAED;AACA,OAAO,MAAMqF,oBAAoB,GAAG,MAAOC,eAAuB,IAAK;EACrE,MAAM;IAAEtF,IAAI;IAAEC;EAAM,CAAC,GAAG,MAAMP,QAAQ,CACnCS,IAAI,CAAC,oBAAoB,CAAC,CAC1BU,MAAM,CAAC,GAAG,CAAC,CACXC,EAAE,CAAC,kBAAkB,EAAEwE,eAAe,CAAC;EAE1C,IAAIrF,KAAK,EAAE;IACTO,OAAO,CAACP,KAAK,CAAC,yCAAyCqF,eAAe,GAAG,EAAErF,KAAK,CAAC;IACjF,MAAMA,KAAK;EACb;EAEA,OAAOD,IAAI;AACb,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}