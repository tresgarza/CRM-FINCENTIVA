{"ast":null,"code":"import{supabase}from'../lib/supabaseClient';import{ErrorType,createAppError,logError,safeAsync}from'./errorHandling';import{v4 as uuidv4}from'uuid';import{getStorage}from'../lib/supabaseClient';/**\n * Maximum number of upload retry attempts\n */export const MAX_UPLOAD_RETRIES=3;/**\n * Validates if a file is a valid document for upload\n */export const isValidDocument=file=>{// Allowed MIME types\nconst allowedTypes=['application/pdf','image/jpeg','image/png','image/jpg','image/heic','application/vnd.openxmlformats-officedocument.wordprocessingml.document','application/msword','application/vnd.openxmlformats-officedocument.spreadsheetml.sheet','application/vnd.ms-excel'];// Maximum file size (10MB)\nconst maxSize=10*1024*1024;return allowedTypes.includes(file.type)&&file.size<=maxSize;};/**\n * Uploads a document to storage with automatic retries\n */export const uploadDocumentToStorage=async function(document,folder){let attempt=arguments.length>2&&arguments[2]!==undefined?arguments[2]:1;const file=document.file;if(!isValidDocument(file)){throw createAppError(ErrorType.VALIDATION,'Invalid document format or size',{fileName:file.name,fileType:file.type,fileSize:file.size});}try{// Generate unique file id and name\nconst fileId=uuidv4();const fileExtension=file.name.split('.').pop();const fileName=`${fileId}.${fileExtension}`;const filePath=`${folder}/${fileName}`;// Upload the file\nconst{error:uploadError}=await supabase.storage.from('documents').upload(filePath,file);if(uploadError){throw createAppError(ErrorType.UPLOAD,`Error uploading document: ${uploadError.message}`,{filePath,attempt},uploadError);}// Get public URL for the uploaded file\nconst{data:publicUrlData}=supabase.storage.from('documents').getPublicUrl(filePath);// Return document info\nreturn{id:fileId,name:file.name,size:file.size,type:document.type,url:publicUrlData.publicUrl,description:document.description,createdAt:new Date().toISOString()};}catch(error){// Retry logic for transient errors\nif(attempt<MAX_UPLOAD_RETRIES){logError(error,'documentUpload',{message:`Retrying upload (${attempt+1}/${MAX_UPLOAD_RETRIES})`,fileName:file.name});// Exponential backoff delay\nconst delay=Math.pow(2,attempt)*1000;await new Promise(resolve=>setTimeout(resolve,delay));// Retry with incremented attempt count\nreturn uploadDocumentToStorage(document,folder,attempt+1);}// Max retries reached, rethrow error\nthrow error;}};/**\n * Uploads multiple documents with reliable error handling\n */export const uploadDocuments=async(documents,folder)=>{const uploadedDocs=[];const failedDocs=[];// Process each document\nfor(const document of documents){const[uploaded,error]=await safeAsync(uploadDocumentToStorage(document,folder),'uploadDocuments');if(uploaded){uploadedDocs.push(uploaded);}else if(error){failedDocs.push({document,error});}}return{uploadedDocs,failedDocs};};/**\n * Asegura que el bucket de almacenamiento exista antes de utilizarlo\n * @param bucketName Nombre del bucket a verificar\n * @returns True si el bucket existe o fue creado correctamente\n */export const ensureClientBucketExists=async function(){let bucketName=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'client-documents';try{console.log(`Verificando si el bucket ${bucketName} existe...`);const storage=getStorage();// Intentar listar buckets para verificar si existe\nconst{data:buckets,error:listError}=await storage.listBuckets();if(listError){console.error(`Error al listar buckets:`,listError);// Si hay un error al listar buckets, podría ser un problema de permisos\n// Intentaremos verificar directamente intentando listar archivos del bucket\nconst{error:listFilesError}=await storage.from(bucketName).list();if(!listFilesError){// Si no hay error al listar archivos, significa que el bucket existe\nconsole.log(`El bucket ${bucketName} existe y es accesible.`);return true;}throw createAppError(ErrorType.UPLOAD,`Error al acceder al almacenamiento: ${listError.message}`,{error:listError});}// Verificar si el bucket ya existe\nconst bucketExists=buckets===null||buckets===void 0?void 0:buckets.some(bucket=>bucket.name===bucketName);if(bucketExists){console.log(`El bucket ${bucketName} ya existe.`);return true;}console.log(`El bucket ${bucketName} no existe. Intentando crearlo...`);// Crear el bucket si no existe\nconst MAX_RETRIES=2;let attempt=0;let lastError=null;while(attempt<MAX_RETRIES){try{const{data,error:createError}=await storage.createBucket(bucketName,{public:false});if(createError){var _createError$message;console.error(`Error al crear el bucket ${bucketName} (intento ${attempt+1}/${MAX_RETRIES}):`,createError);lastError=createError;// Si el error indica que el bucket ya existe, consideremos eso un éxito\nif((_createError$message=createError.message)!==null&&_createError$message!==void 0&&_createError$message.includes('already exists')){console.log(`El bucket ${bucketName} ya existe (según el mensaje de error).`);return true;}throw createError;}console.log(`Bucket ${bucketName} creado correctamente.`);// Intentar establecer políticas públicas para el bucket\ntry{// Verificar que podemos acceder al bucket recién creado\nconst{error:testError}=await storage.from(bucketName).list('',{limit:1});if(testError){console.warn(`Advertencia: El bucket ${bucketName} fue creado pero hay problemas para acceder a él: ${testError.message}`);}else{console.log(`Bucket ${bucketName} creado y accesible correctamente.`);}}catch(policyError){// No bloquear el proceso si falla la verificación\nconsole.warn(`No se pudo verificar acceso al bucket ${bucketName}:`,policyError);}return true;}catch(error){lastError=error;attempt++;// Si no es el último intento, esperar antes de reintentar\nif(attempt<MAX_RETRIES){const waitTime=1000*Math.pow(2,attempt-1);// Backoff exponencial\nconsole.log(`Esperando ${waitTime}ms antes de reintentar crear el bucket...`);await new Promise(resolve=>setTimeout(resolve,waitTime));}}}// Si llegamos aquí, todos los intentos fallaron\nthrow lastError||new Error(`No se pudo crear el bucket ${bucketName} después de ${MAX_RETRIES} intentos.`);}catch(error){// Como último recurso, verificamos si podemos escribir en el bucket aunque no podamos crearlo\ntry{const storage=getStorage();const testFilePath=`test-${Date.now()}.txt`;const testContent=new Blob(['test'],{type:'text/plain'});console.log(`Intentando escribir archivo de prueba en ${bucketName}/${testFilePath} como último recurso...`);const{error:uploadError}=await storage.from(bucketName).upload(testFilePath,testContent);if(!uploadError){console.log(`¡Éxito! El bucket ${bucketName} existe y permite escritura.`);// Limpieza del archivo de prueba\nawait storage.from(bucketName).remove([testFilePath]);return true;}}catch(testError){console.error(`Error en la prueba final de escritura en bucket:`,testError);}console.error(`Error al verificar/crear bucket ${bucketName}:`,error);throw createAppError(ErrorType.UPLOAD,error instanceof Error?`Error al crear el bucket de almacenamiento: ${error.message}`:'Error desconocido al crear el bucket de almacenamiento',{bucketName,error});}};/**\n * Uploads client documents to storage\n * @param clientId The client ID\n * @param documents Array of documents to upload\n * @param maxRetries Maximum number of retry attempts (default: 2)\n * @returns Array of successfully uploaded documents (without the original file object)\n */export const uploadClientDocuments=async function(clientId,documents){let maxRetries=arguments.length>2&&arguments[2]!==undefined?arguments[2]:2;// Verify parameters\nif(!clientId){throw new Error('Client ID is required for uploading documents');}if(!documents||!Array.isArray(documents)||documents.length===0){return[];}try{// Asegurar que el bucket existe antes de continuar\nlet bucketName='client-documents';console.log(`Iniciando proceso de subida de documentos para cliente ${clientId}`);console.log(`Total de documentos: ${documents.length}`);let bucketReady=false;try{bucketReady=await ensureClientBucketExists(bucketName);if(bucketReady){console.log(`Bucket ${bucketName} verificado y listo para su uso.`);}}catch(bucketError){console.error(`Error preparando el bucket ${bucketName}:`,bucketError);// Intentar continuar usando el bucket predeterminado 'documents' como fallback\nbucketName='documents';console.log(`Intentando usar el bucket predeterminado '${bucketName}' como alternativa...`);try{bucketReady=await ensureClientBucketExists(bucketName);if(bucketReady){console.log(`Usando bucket alternativo '${bucketName}' para la subida.`);}}catch(fallbackError){console.error(`No se pudo usar ningún bucket para la subida:`,fallbackError);throw createAppError(ErrorType.UPLOAD,`No se pudo preparar un bucket para subir documentos. Contacte al administrador.`,{originalError:bucketError});}}const storage=getStorage();const uploadedDocs=[];const failedDocs=[];// Filter out docs with invalid or missing files\nconst validDocs=documents.filter(doc=>doc&&doc.file&&doc.file instanceof File&&doc.category&&doc.name);console.log(`Documentos válidos para subida: ${validDocs.length} de ${documents.length}`);if(validDocs.length===0){console.warn(`No hay documentos válidos para subir. Se requiere archivo, categoría y nombre.`);return[];}for(let docIndex=0;docIndex<validDocs.length;docIndex++){const doc=validDocs[docIndex];let fileUrl='';let success=false;let retries=0;let lastError=null;console.log(`Procesando documento ${docIndex+1}/${validDocs.length}: \"${doc.name}\" (${doc.file.size} bytes)`);while(!success&&retries<=maxRetries){retries++;try{// Construct a unique file name to avoid collisions\nconst timestamp=new Date().getTime();const fileNameSafe=doc.file.name.replace(/[^a-zA-Z0-9.-]/g,'_');// Sanitizar nombre de archivo\nconst fileName=`${timestamp}_${fileNameSafe}`;const filePath=`${clientId}/${doc.category}/${fileName}`;console.log(`Intento ${retries}/${maxRetries+1}: Subiendo \"${doc.name}\" a ${bucketName}/${filePath}`);// Upload the file\nconst{data,error}=await storage.from(bucketName).upload(filePath,doc.file,{cacheControl:'3600',upsert:true// Cambiar a true para sobrescribir si existe\n});if(error){console.error(`Error al subir archivo \"${doc.name}\" (intento ${retries}/${maxRetries+1}):`,error);lastError=error;throw error;}// Get the public URL\nconst{data:urlData}=storage.from(bucketName).getPublicUrl(filePath);fileUrl=urlData.publicUrl;success=true;console.log(`✅ Documento \"${doc.name}\" subido exitosamente a ${bucketName}/${filePath}`);}catch(error){lastError=error;// Imprimir detalles adicionales del error para diagnóstico\nif(error instanceof Error){console.error(`Detalles del error: ${error.message}`);if(error.stack){console.error(`Stack: ${error.stack}`);}}// Si no es el último intento, esperar antes de reintentar\nif(retries<=maxRetries){const waitTime=Math.pow(2,retries-1)*1000;// Backoff exponencial\nconsole.log(`Esperando ${waitTime}ms antes de reintentar la subida...`);await new Promise(resolve=>setTimeout(resolve,waitTime));}else{console.error(`❌ Falló la subida de \"${doc.name}\" después de ${retries} intentos.`);failedDocs.push({name:doc.name||doc.file.name,error:error});// Create a proper AppError and log it\nconst uploadError=createAppError(ErrorType.UPLOAD,`Error al subir documento \"${doc.name||doc.file.name}\" después de ${maxRetries+1} intentos`,{documentName:doc.name,clientId,category:doc.category,attempts:retries},error);logError(uploadError,'uploadClientDocuments');}}}if(success){// Create document without the file property\nconst{file,...docWithoutFile}=doc;uploadedDocs.push({...docWithoutFile,url:fileUrl});}}if(failedDocs.length>0){console.warn(`⚠️ ${failedDocs.length} documentos fallaron al subirse de un total de ${validDocs.length}:`,failedDocs);}console.log(`📊 Resumen: ${uploadedDocs.length} documentos subidos exitosamente, ${failedDocs.length} fallidos.`);return uploadedDocs;}catch(error){console.error('❌ Error general en uploadClientDocuments:',error);// Proporcionar un mensaje de error más descriptivo basado en el tipo de error\nlet errorMessage='Error al subir documentos';if(error instanceof Error){errorMessage=error.message;}else if(typeof error==='object'&&error!==null&&'message'in error){errorMessage=error.message||errorMessage;}throw createAppError(ErrorType.UPLOAD,errorMessage,{clientId,error});}};","map":{"version":3,"names":["supabase","ErrorType","createAppError","logError","safeAsync","v4","uuidv4","getStorage","MAX_UPLOAD_RETRIES","isValidDocument","file","allowedTypes","maxSize","includes","type","size","uploadDocumentToStorage","document","folder","attempt","arguments","length","undefined","VALIDATION","fileName","name","fileType","fileSize","fileId","fileExtension","split","pop","filePath","error","uploadError","storage","from","upload","UPLOAD","message","data","publicUrlData","getPublicUrl","id","url","publicUrl","description","createdAt","Date","toISOString","delay","Math","pow","Promise","resolve","setTimeout","uploadDocuments","documents","uploadedDocs","failedDocs","uploaded","push","ensureClientBucketExists","bucketName","console","log","buckets","listError","listBuckets","listFilesError","list","bucketExists","some","bucket","MAX_RETRIES","lastError","createError","createBucket","public","_createError$message","testError","limit","warn","policyError","waitTime","Error","testFilePath","now","testContent","Blob","remove","uploadClientDocuments","clientId","maxRetries","Array","isArray","bucketReady","bucketError","fallbackError","originalError","validDocs","filter","doc","File","category","docIndex","fileUrl","success","retries","timestamp","getTime","fileNameSafe","replace","cacheControl","upsert","urlData","stack","documentName","attempts","docWithoutFile","errorMessage"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/utils/documentUpload.ts"],"sourcesContent":["import { supabase } from '../lib/supabaseClient';\nimport { ErrorType, createAppError, logError, safeAsync } from './errorHandling';\nimport { v4 as uuidv4 } from 'uuid';\nimport { getStorage } from '../lib/supabaseClient';\nimport { ClientDocument } from '../types/client';\n\nexport interface UploadDocument {\n  file: File;\n  type: string;\n  description?: string;\n}\n\nexport interface UploadedDocument {\n  id: string;\n  name: string;\n  size: number;\n  type: string;\n  url: string;\n  description?: string;\n  createdAt: string;\n}\n\n/**\n * Maximum number of upload retry attempts\n */\nexport const MAX_UPLOAD_RETRIES = 3;\n\n/**\n * Validates if a file is a valid document for upload\n */\nexport const isValidDocument = (file: File): boolean => {\n  // Allowed MIME types\n  const allowedTypes = [\n    'application/pdf',\n    'image/jpeg',\n    'image/png',\n    'image/jpg',\n    'image/heic',\n    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n    'application/msword',\n    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n    'application/vnd.ms-excel'\n  ];\n\n  // Maximum file size (10MB)\n  const maxSize = 10 * 1024 * 1024;\n\n  return allowedTypes.includes(file.type) && file.size <= maxSize;\n};\n\n/**\n * Uploads a document to storage with automatic retries\n */\nexport const uploadDocumentToStorage = async (\n  document: UploadDocument,\n  folder: string,\n  attempt = 1\n): Promise<UploadedDocument> => {\n  const file = document.file;\n  \n  if (!isValidDocument(file)) {\n    throw createAppError(\n      ErrorType.VALIDATION,\n      'Invalid document format or size',\n      { \n        fileName: file.name, \n        fileType: file.type, \n        fileSize: file.size \n      }\n    );\n  }\n  \n  try {\n    // Generate unique file id and name\n    const fileId = uuidv4();\n    const fileExtension = file.name.split('.').pop();\n    const fileName = `${fileId}.${fileExtension}`;\n    const filePath = `${folder}/${fileName}`;\n    \n    // Upload the file\n    const { error: uploadError } = await supabase.storage\n      .from('documents')\n      .upload(filePath, file);\n    \n    if (uploadError) {\n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error uploading document: ${uploadError.message}`,\n        { filePath, attempt },\n        uploadError\n      );\n    }\n    \n    // Get public URL for the uploaded file\n    const { data: publicUrlData } = supabase.storage\n      .from('documents')\n      .getPublicUrl(filePath);\n    \n    // Return document info\n    return {\n      id: fileId,\n      name: file.name,\n      size: file.size,\n      type: document.type,\n      url: publicUrlData.publicUrl,\n      description: document.description,\n      createdAt: new Date().toISOString()\n    };\n  } catch (error) {\n    // Retry logic for transient errors\n    if (attempt < MAX_UPLOAD_RETRIES) {\n      logError(error, 'documentUpload', { \n        message: `Retrying upload (${attempt + 1}/${MAX_UPLOAD_RETRIES})`,\n        fileName: file.name\n      });\n      \n      // Exponential backoff delay\n      const delay = Math.pow(2, attempt) * 1000;\n      await new Promise(resolve => setTimeout(resolve, delay));\n      \n      // Retry with incremented attempt count\n      return uploadDocumentToStorage(document, folder, attempt + 1);\n    }\n    \n    // Max retries reached, rethrow error\n    throw error;\n  }\n};\n\n/**\n * Uploads multiple documents with reliable error handling\n */\nexport const uploadDocuments = async (\n  documents: UploadDocument[],\n  folder: string\n): Promise<{\n  uploadedDocs: UploadedDocument[];\n  failedDocs: Array<{ document: UploadDocument; error: any }>;\n}> => {\n  const uploadedDocs: UploadedDocument[] = [];\n  const failedDocs: Array<{ document: UploadDocument; error: any }> = [];\n  \n  // Process each document\n  for (const document of documents) {\n    const [uploaded, error] = await safeAsync(\n      uploadDocumentToStorage(document, folder),\n      'uploadDocuments'\n    );\n    \n    if (uploaded) {\n      uploadedDocs.push(uploaded);\n    } else if (error) {\n      failedDocs.push({ \n        document, \n        error \n      });\n    }\n  }\n  \n  return { uploadedDocs, failedDocs };\n};\n\n/**\n * Asegura que el bucket de almacenamiento exista antes de utilizarlo\n * @param bucketName Nombre del bucket a verificar\n * @returns True si el bucket existe o fue creado correctamente\n */\nexport const ensureClientBucketExists = async (bucketName: string = 'client-documents'): Promise<boolean> => {\n  try {\n    console.log(`Verificando si el bucket ${bucketName} existe...`);\n    const storage = getStorage();\n    \n    // Intentar listar buckets para verificar si existe\n    const { data: buckets, error: listError } = await storage.listBuckets();\n    \n    if (listError) {\n      console.error(`Error al listar buckets:`, listError);\n      // Si hay un error al listar buckets, podría ser un problema de permisos\n      // Intentaremos verificar directamente intentando listar archivos del bucket\n      const { error: listFilesError } = await storage.from(bucketName).list();\n      \n      if (!listFilesError) {\n        // Si no hay error al listar archivos, significa que el bucket existe\n        console.log(`El bucket ${bucketName} existe y es accesible.`);\n        return true;\n      }\n      \n      throw createAppError(\n        ErrorType.UPLOAD,\n        `Error al acceder al almacenamiento: ${listError.message}`,\n        { error: listError }\n      );\n    }\n    \n    // Verificar si el bucket ya existe\n    const bucketExists = buckets?.some(bucket => bucket.name === bucketName);\n    \n    if (bucketExists) {\n      console.log(`El bucket ${bucketName} ya existe.`);\n      return true;\n    }\n    \n    console.log(`El bucket ${bucketName} no existe. Intentando crearlo...`);\n    \n    // Crear el bucket si no existe\n    const MAX_RETRIES = 2;\n    let attempt = 0;\n    let lastError = null;\n    \n    while (attempt < MAX_RETRIES) {\n      try {\n        const { data, error: createError } = await storage.createBucket(bucketName, {\n          public: false\n        });\n        \n        if (createError) {\n          console.error(`Error al crear el bucket ${bucketName} (intento ${attempt + 1}/${MAX_RETRIES}):`, createError);\n          lastError = createError;\n          \n          // Si el error indica que el bucket ya existe, consideremos eso un éxito\n          if (createError.message?.includes('already exists')) {\n            console.log(`El bucket ${bucketName} ya existe (según el mensaje de error).`);\n            return true;\n          }\n          \n          throw createError;\n        }\n        \n        console.log(`Bucket ${bucketName} creado correctamente.`);\n        \n        // Intentar establecer políticas públicas para el bucket\n        try {\n          // Verificar que podemos acceder al bucket recién creado\n          const { error: testError } = await storage.from(bucketName).list('', {\n            limit: 1\n          });\n          \n          if (testError) {\n            console.warn(`Advertencia: El bucket ${bucketName} fue creado pero hay problemas para acceder a él: ${testError.message}`);\n          } else {\n            console.log(`Bucket ${bucketName} creado y accesible correctamente.`);\n          }\n        } catch (policyError) {\n          // No bloquear el proceso si falla la verificación\n          console.warn(`No se pudo verificar acceso al bucket ${bucketName}:`, policyError);\n        }\n        \n        return true;\n      } catch (error) {\n        lastError = error;\n        attempt++;\n        \n        // Si no es el último intento, esperar antes de reintentar\n        if (attempt < MAX_RETRIES) {\n          const waitTime = 1000 * Math.pow(2, attempt - 1); // Backoff exponencial\n          console.log(`Esperando ${waitTime}ms antes de reintentar crear el bucket...`);\n          await new Promise(resolve => setTimeout(resolve, waitTime));\n        }\n      }\n    }\n    \n    // Si llegamos aquí, todos los intentos fallaron\n    throw lastError || new Error(`No se pudo crear el bucket ${bucketName} después de ${MAX_RETRIES} intentos.`);\n  } catch (error) {\n    // Como último recurso, verificamos si podemos escribir en el bucket aunque no podamos crearlo\n    try {\n      const storage = getStorage();\n      const testFilePath = `test-${Date.now()}.txt`;\n      const testContent = new Blob(['test'], { type: 'text/plain' });\n      \n      console.log(`Intentando escribir archivo de prueba en ${bucketName}/${testFilePath} como último recurso...`);\n      const { error: uploadError } = await storage.from(bucketName).upload(testFilePath, testContent);\n      \n      if (!uploadError) {\n        console.log(`¡Éxito! El bucket ${bucketName} existe y permite escritura.`);\n        // Limpieza del archivo de prueba\n        await storage.from(bucketName).remove([testFilePath]);\n        return true;\n      }\n    } catch (testError) {\n      console.error(`Error en la prueba final de escritura en bucket:`, testError);\n    }\n    \n    console.error(`Error al verificar/crear bucket ${bucketName}:`, error);\n    throw createAppError(\n      ErrorType.UPLOAD,\n      error instanceof Error \n        ? `Error al crear el bucket de almacenamiento: ${error.message}` \n        : 'Error desconocido al crear el bucket de almacenamiento',\n      { bucketName, error }\n    );\n  }\n};\n\n/**\n * Uploads client documents to storage\n * @param clientId The client ID\n * @param documents Array of documents to upload\n * @param maxRetries Maximum number of retry attempts (default: 2)\n * @returns Array of successfully uploaded documents (without the original file object)\n */\nexport const uploadClientDocuments = async (\n  clientId: string,\n  documents: ClientDocument[],\n  maxRetries = 2\n): Promise<Omit<ClientDocument & { url: string }, 'file'>[]> => {\n  // Verify parameters\n  if (!clientId) {\n    throw new Error('Client ID is required for uploading documents');\n  }\n\n  if (!documents || !Array.isArray(documents) || documents.length === 0) {\n    return [];\n  }\n\n  try {\n    // Asegurar que el bucket existe antes de continuar\n    let bucketName = 'client-documents';\n    \n    console.log(`Iniciando proceso de subida de documentos para cliente ${clientId}`);\n    console.log(`Total de documentos: ${documents.length}`);\n    \n    let bucketReady = false;\n    try {\n      bucketReady = await ensureClientBucketExists(bucketName);\n      if (bucketReady) {\n        console.log(`Bucket ${bucketName} verificado y listo para su uso.`);\n      }\n    } catch (bucketError) {\n      console.error(`Error preparando el bucket ${bucketName}:`, bucketError);\n      // Intentar continuar usando el bucket predeterminado 'documents' como fallback\n      bucketName = 'documents';\n      console.log(`Intentando usar el bucket predeterminado '${bucketName}' como alternativa...`);\n      try {\n        bucketReady = await ensureClientBucketExists(bucketName);\n        if (bucketReady) {\n          console.log(`Usando bucket alternativo '${bucketName}' para la subida.`);\n        }\n      } catch (fallbackError) {\n        console.error(`No se pudo usar ningún bucket para la subida:`, fallbackError);\n        throw createAppError(\n          ErrorType.UPLOAD,\n          `No se pudo preparar un bucket para subir documentos. Contacte al administrador.`,\n          { originalError: bucketError }\n        );\n      }\n    }\n    \n    const storage = getStorage();\n    const uploadedDocs: Array<Omit<ClientDocument & { url: string }, 'file'>> = [];\n    const failedDocs: Array<{name: string, error: any}> = [];\n\n    // Filter out docs with invalid or missing files\n    const validDocs = documents.filter(doc => \n      doc && doc.file && doc.file instanceof File && doc.category && doc.name\n    );\n    console.log(`Documentos válidos para subida: ${validDocs.length} de ${documents.length}`);\n\n    if (validDocs.length === 0) {\n      console.warn(`No hay documentos válidos para subir. Se requiere archivo, categoría y nombre.`);\n      return [];\n    }\n\n    for (let docIndex = 0; docIndex < validDocs.length; docIndex++) {\n      const doc = validDocs[docIndex];\n      let fileUrl = '';\n      let success = false;\n      let retries = 0;\n      let lastError = null;\n\n      console.log(`Procesando documento ${docIndex + 1}/${validDocs.length}: \"${doc.name}\" (${doc.file.size} bytes)`);\n\n      while (!success && retries <= maxRetries) {\n        retries++;\n        try {\n          // Construct a unique file name to avoid collisions\n          const timestamp = new Date().getTime();\n          const fileNameSafe = doc.file.name.replace(/[^a-zA-Z0-9.-]/g, '_'); // Sanitizar nombre de archivo\n          const fileName = `${timestamp}_${fileNameSafe}`;\n          const filePath = `${clientId}/${doc.category}/${fileName}`;\n\n          console.log(`Intento ${retries}/${maxRetries+1}: Subiendo \"${doc.name}\" a ${bucketName}/${filePath}`);\n\n          // Upload the file\n          const { data, error } = await storage\n            .from(bucketName)\n            .upload(filePath, doc.file, {\n              cacheControl: '3600',\n              upsert: true, // Cambiar a true para sobrescribir si existe\n            });\n\n          if (error) {\n            console.error(`Error al subir archivo \"${doc.name}\" (intento ${retries}/${maxRetries+1}):`, error);\n            lastError = error;\n            throw error;\n          }\n\n          // Get the public URL\n          const { data: urlData } = storage\n            .from(bucketName)\n            .getPublicUrl(filePath);\n\n          fileUrl = urlData.publicUrl;\n          success = true;\n          console.log(`✅ Documento \"${doc.name}\" subido exitosamente a ${bucketName}/${filePath}`);\n        } catch (error) {\n          lastError = error;\n          \n          // Imprimir detalles adicionales del error para diagnóstico\n          if (error instanceof Error) {\n            console.error(`Detalles del error: ${error.message}`);\n            if ((error as any).stack) {\n              console.error(`Stack: ${(error as any).stack}`);\n            }\n          }\n          \n          // Si no es el último intento, esperar antes de reintentar\n          if (retries <= maxRetries) {\n            const waitTime = Math.pow(2, retries-1) * 1000; // Backoff exponencial\n            console.log(`Esperando ${waitTime}ms antes de reintentar la subida...`);\n            await new Promise(resolve => setTimeout(resolve, waitTime));\n          } else {\n            console.error(`❌ Falló la subida de \"${doc.name}\" después de ${retries} intentos.`);\n            failedDocs.push({\n              name: doc.name || doc.file.name,\n              error: error\n            });\n            \n            // Create a proper AppError and log it\n            const uploadError = createAppError(\n              ErrorType.UPLOAD,\n              `Error al subir documento \"${doc.name || doc.file.name}\" después de ${maxRetries+1} intentos`,\n              {\n                documentName: doc.name,\n                clientId,\n                category: doc.category,\n                attempts: retries\n              },\n              error\n            );\n            \n            logError(uploadError, 'uploadClientDocuments');\n          }\n        }\n      }\n\n      if (success) {\n        // Create document without the file property\n        const { file, ...docWithoutFile } = doc;\n        uploadedDocs.push({\n          ...docWithoutFile,\n          url: fileUrl\n        });\n      }\n    }\n\n    if (failedDocs.length > 0) {\n      console.warn(`⚠️ ${failedDocs.length} documentos fallaron al subirse de un total de ${validDocs.length}:`, failedDocs);\n    }\n    \n    console.log(`📊 Resumen: ${uploadedDocs.length} documentos subidos exitosamente, ${failedDocs.length} fallidos.`);\n    return uploadedDocs;\n  } catch (error) {\n    console.error('❌ Error general en uploadClientDocuments:', error);\n    \n    // Proporcionar un mensaje de error más descriptivo basado en el tipo de error\n    let errorMessage = 'Error al subir documentos';\n    if (error instanceof Error) {\n      errorMessage = error.message;\n    } else if (typeof error === 'object' && error !== null && 'message' in error) {\n      errorMessage = (error as any).message || errorMessage;\n    }\n    \n    throw createAppError(\n      ErrorType.UPLOAD,\n      errorMessage,\n      { clientId, error }\n    );\n  }\n}; "],"mappings":"AAAA,OAASA,QAAQ,KAAQ,uBAAuB,CAChD,OAASC,SAAS,CAAEC,cAAc,CAAEC,QAAQ,CAAEC,SAAS,KAAQ,iBAAiB,CAChF,OAASC,EAAE,GAAI,CAAAC,MAAM,KAAQ,MAAM,CACnC,OAASC,UAAU,KAAQ,uBAAuB,CAmBlD;AACA;AACA,GACA,MAAO,MAAM,CAAAC,kBAAkB,CAAG,CAAC,CAEnC;AACA;AACA,GACA,MAAO,MAAM,CAAAC,eAAe,CAAIC,IAAU,EAAc,CACtD;AACA,KAAM,CAAAC,YAAY,CAAG,CACnB,iBAAiB,CACjB,YAAY,CACZ,WAAW,CACX,WAAW,CACX,YAAY,CACZ,yEAAyE,CACzE,oBAAoB,CACpB,mEAAmE,CACnE,0BAA0B,CAC3B,CAED;AACA,KAAM,CAAAC,OAAO,CAAG,EAAE,CAAG,IAAI,CAAG,IAAI,CAEhC,MAAO,CAAAD,YAAY,CAACE,QAAQ,CAACH,IAAI,CAACI,IAAI,CAAC,EAAIJ,IAAI,CAACK,IAAI,EAAIH,OAAO,CACjE,CAAC,CAED;AACA;AACA,GACA,MAAO,MAAM,CAAAI,uBAAuB,CAAG,cAAAA,CACrCC,QAAwB,CACxBC,MAAc,CAEgB,IAD9B,CAAAC,OAAO,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAEX,KAAM,CAAAV,IAAI,CAAGO,QAAQ,CAACP,IAAI,CAE1B,GAAI,CAACD,eAAe,CAACC,IAAI,CAAC,CAAE,CAC1B,KAAM,CAAAR,cAAc,CAClBD,SAAS,CAACsB,UAAU,CACpB,iCAAiC,CACjC,CACEC,QAAQ,CAAEd,IAAI,CAACe,IAAI,CACnBC,QAAQ,CAAEhB,IAAI,CAACI,IAAI,CACnBa,QAAQ,CAAEjB,IAAI,CAACK,IACjB,CACF,CAAC,CACH,CAEA,GAAI,CACF;AACA,KAAM,CAAAa,MAAM,CAAGtB,MAAM,CAAC,CAAC,CACvB,KAAM,CAAAuB,aAAa,CAAGnB,IAAI,CAACe,IAAI,CAACK,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,CAAC,CAAC,CAChD,KAAM,CAAAP,QAAQ,CAAG,GAAGI,MAAM,IAAIC,aAAa,EAAE,CAC7C,KAAM,CAAAG,QAAQ,CAAG,GAAGd,MAAM,IAAIM,QAAQ,EAAE,CAExC;AACA,KAAM,CAAES,KAAK,CAAEC,WAAY,CAAC,CAAG,KAAM,CAAAlC,QAAQ,CAACmC,OAAO,CAClDC,IAAI,CAAC,WAAW,CAAC,CACjBC,MAAM,CAACL,QAAQ,CAAEtB,IAAI,CAAC,CAEzB,GAAIwB,WAAW,CAAE,CACf,KAAM,CAAAhC,cAAc,CAClBD,SAAS,CAACqC,MAAM,CAChB,6BAA6BJ,WAAW,CAACK,OAAO,EAAE,CAClD,CAAEP,QAAQ,CAAEb,OAAQ,CAAC,CACrBe,WACF,CAAC,CACH,CAEA;AACA,KAAM,CAAEM,IAAI,CAAEC,aAAc,CAAC,CAAGzC,QAAQ,CAACmC,OAAO,CAC7CC,IAAI,CAAC,WAAW,CAAC,CACjBM,YAAY,CAACV,QAAQ,CAAC,CAEzB;AACA,MAAO,CACLW,EAAE,CAAEf,MAAM,CACVH,IAAI,CAAEf,IAAI,CAACe,IAAI,CACfV,IAAI,CAAEL,IAAI,CAACK,IAAI,CACfD,IAAI,CAAEG,QAAQ,CAACH,IAAI,CACnB8B,GAAG,CAAEH,aAAa,CAACI,SAAS,CAC5BC,WAAW,CAAE7B,QAAQ,CAAC6B,WAAW,CACjCC,SAAS,CAAE,GAAI,CAAAC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CACpC,CAAC,CACH,CAAE,MAAOhB,KAAK,CAAE,CACd;AACA,GAAId,OAAO,CAAGX,kBAAkB,CAAE,CAChCL,QAAQ,CAAC8B,KAAK,CAAE,gBAAgB,CAAE,CAChCM,OAAO,CAAE,oBAAoBpB,OAAO,CAAG,CAAC,IAAIX,kBAAkB,GAAG,CACjEgB,QAAQ,CAAEd,IAAI,CAACe,IACjB,CAAC,CAAC,CAEF;AACA,KAAM,CAAAyB,KAAK,CAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAEjC,OAAO,CAAC,CAAG,IAAI,CACzC,KAAM,IAAI,CAAAkC,OAAO,CAACC,OAAO,EAAIC,UAAU,CAACD,OAAO,CAAEJ,KAAK,CAAC,CAAC,CAExD;AACA,MAAO,CAAAlC,uBAAuB,CAACC,QAAQ,CAAEC,MAAM,CAAEC,OAAO,CAAG,CAAC,CAAC,CAC/D,CAEA;AACA,KAAM,CAAAc,KAAK,CACb,CACF,CAAC,CAED;AACA;AACA,GACA,MAAO,MAAM,CAAAuB,eAAe,CAAG,KAAAA,CAC7BC,SAA2B,CAC3BvC,MAAc,GAIV,CACJ,KAAM,CAAAwC,YAAgC,CAAG,EAAE,CAC3C,KAAM,CAAAC,UAA2D,CAAG,EAAE,CAEtE;AACA,IAAK,KAAM,CAAA1C,QAAQ,GAAI,CAAAwC,SAAS,CAAE,CAChC,KAAM,CAACG,QAAQ,CAAE3B,KAAK,CAAC,CAAG,KAAM,CAAA7B,SAAS,CACvCY,uBAAuB,CAACC,QAAQ,CAAEC,MAAM,CAAC,CACzC,iBACF,CAAC,CAED,GAAI0C,QAAQ,CAAE,CACZF,YAAY,CAACG,IAAI,CAACD,QAAQ,CAAC,CAC7B,CAAC,IAAM,IAAI3B,KAAK,CAAE,CAChB0B,UAAU,CAACE,IAAI,CAAC,CACd5C,QAAQ,CACRgB,KACF,CAAC,CAAC,CACJ,CACF,CAEA,MAAO,CAAEyB,YAAY,CAAEC,UAAW,CAAC,CACrC,CAAC,CAED;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAG,wBAAwB,CAAG,cAAAA,CAAA,CAAqE,IAA9D,CAAAC,UAAkB,CAAA3C,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,kBAAkB,CACpF,GAAI,CACF4C,OAAO,CAACC,GAAG,CAAC,4BAA4BF,UAAU,YAAY,CAAC,CAC/D,KAAM,CAAA5B,OAAO,CAAG5B,UAAU,CAAC,CAAC,CAE5B;AACA,KAAM,CAAEiC,IAAI,CAAE0B,OAAO,CAAEjC,KAAK,CAAEkC,SAAU,CAAC,CAAG,KAAM,CAAAhC,OAAO,CAACiC,WAAW,CAAC,CAAC,CAEvE,GAAID,SAAS,CAAE,CACbH,OAAO,CAAC/B,KAAK,CAAC,0BAA0B,CAAEkC,SAAS,CAAC,CACpD;AACA;AACA,KAAM,CAAElC,KAAK,CAAEoC,cAAe,CAAC,CAAG,KAAM,CAAAlC,OAAO,CAACC,IAAI,CAAC2B,UAAU,CAAC,CAACO,IAAI,CAAC,CAAC,CAEvE,GAAI,CAACD,cAAc,CAAE,CACnB;AACAL,OAAO,CAACC,GAAG,CAAC,aAAaF,UAAU,yBAAyB,CAAC,CAC7D,MAAO,KAAI,CACb,CAEA,KAAM,CAAA7D,cAAc,CAClBD,SAAS,CAACqC,MAAM,CAChB,uCAAuC6B,SAAS,CAAC5B,OAAO,EAAE,CAC1D,CAAEN,KAAK,CAAEkC,SAAU,CACrB,CAAC,CACH,CAEA;AACA,KAAM,CAAAI,YAAY,CAAGL,OAAO,SAAPA,OAAO,iBAAPA,OAAO,CAAEM,IAAI,CAACC,MAAM,EAAIA,MAAM,CAAChD,IAAI,GAAKsC,UAAU,CAAC,CAExE,GAAIQ,YAAY,CAAE,CAChBP,OAAO,CAACC,GAAG,CAAC,aAAaF,UAAU,aAAa,CAAC,CACjD,MAAO,KAAI,CACb,CAEAC,OAAO,CAACC,GAAG,CAAC,aAAaF,UAAU,mCAAmC,CAAC,CAEvE;AACA,KAAM,CAAAW,WAAW,CAAG,CAAC,CACrB,GAAI,CAAAvD,OAAO,CAAG,CAAC,CACf,GAAI,CAAAwD,SAAS,CAAG,IAAI,CAEpB,MAAOxD,OAAO,CAAGuD,WAAW,CAAE,CAC5B,GAAI,CACF,KAAM,CAAElC,IAAI,CAAEP,KAAK,CAAE2C,WAAY,CAAC,CAAG,KAAM,CAAAzC,OAAO,CAAC0C,YAAY,CAACd,UAAU,CAAE,CAC1Ee,MAAM,CAAE,KACV,CAAC,CAAC,CAEF,GAAIF,WAAW,CAAE,KAAAG,oBAAA,CACff,OAAO,CAAC/B,KAAK,CAAC,4BAA4B8B,UAAU,aAAa5C,OAAO,CAAG,CAAC,IAAIuD,WAAW,IAAI,CAAEE,WAAW,CAAC,CAC7GD,SAAS,CAAGC,WAAW,CAEvB;AACA,IAAAG,oBAAA,CAAIH,WAAW,CAACrC,OAAO,UAAAwC,oBAAA,WAAnBA,oBAAA,CAAqBlE,QAAQ,CAAC,gBAAgB,CAAC,CAAE,CACnDmD,OAAO,CAACC,GAAG,CAAC,aAAaF,UAAU,yCAAyC,CAAC,CAC7E,MAAO,KAAI,CACb,CAEA,KAAM,CAAAa,WAAW,CACnB,CAEAZ,OAAO,CAACC,GAAG,CAAC,UAAUF,UAAU,wBAAwB,CAAC,CAEzD;AACA,GAAI,CACF;AACA,KAAM,CAAE9B,KAAK,CAAE+C,SAAU,CAAC,CAAG,KAAM,CAAA7C,OAAO,CAACC,IAAI,CAAC2B,UAAU,CAAC,CAACO,IAAI,CAAC,EAAE,CAAE,CACnEW,KAAK,CAAE,CACT,CAAC,CAAC,CAEF,GAAID,SAAS,CAAE,CACbhB,OAAO,CAACkB,IAAI,CAAC,0BAA0BnB,UAAU,qDAAqDiB,SAAS,CAACzC,OAAO,EAAE,CAAC,CAC5H,CAAC,IAAM,CACLyB,OAAO,CAACC,GAAG,CAAC,UAAUF,UAAU,oCAAoC,CAAC,CACvE,CACF,CAAE,MAAOoB,WAAW,CAAE,CACpB;AACAnB,OAAO,CAACkB,IAAI,CAAC,yCAAyCnB,UAAU,GAAG,CAAEoB,WAAW,CAAC,CACnF,CAEA,MAAO,KAAI,CACb,CAAE,MAAOlD,KAAK,CAAE,CACd0C,SAAS,CAAG1C,KAAK,CACjBd,OAAO,EAAE,CAET;AACA,GAAIA,OAAO,CAAGuD,WAAW,CAAE,CACzB,KAAM,CAAAU,QAAQ,CAAG,IAAI,CAAGjC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAEjC,OAAO,CAAG,CAAC,CAAC,CAAE;AAClD6C,OAAO,CAACC,GAAG,CAAC,aAAamB,QAAQ,2CAA2C,CAAC,CAC7E,KAAM,IAAI,CAAA/B,OAAO,CAACC,OAAO,EAAIC,UAAU,CAACD,OAAO,CAAE8B,QAAQ,CAAC,CAAC,CAC7D,CACF,CACF,CAEA;AACA,KAAM,CAAAT,SAAS,EAAI,GAAI,CAAAU,KAAK,CAAC,8BAA8BtB,UAAU,eAAeW,WAAW,YAAY,CAAC,CAC9G,CAAE,MAAOzC,KAAK,CAAE,CACd;AACA,GAAI,CACF,KAAM,CAAAE,OAAO,CAAG5B,UAAU,CAAC,CAAC,CAC5B,KAAM,CAAA+E,YAAY,CAAG,QAAQtC,IAAI,CAACuC,GAAG,CAAC,CAAC,MAAM,CAC7C,KAAM,CAAAC,WAAW,CAAG,GAAI,CAAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAE,CAAE3E,IAAI,CAAE,YAAa,CAAC,CAAC,CAE9DkD,OAAO,CAACC,GAAG,CAAC,4CAA4CF,UAAU,IAAIuB,YAAY,yBAAyB,CAAC,CAC5G,KAAM,CAAErD,KAAK,CAAEC,WAAY,CAAC,CAAG,KAAM,CAAAC,OAAO,CAACC,IAAI,CAAC2B,UAAU,CAAC,CAAC1B,MAAM,CAACiD,YAAY,CAAEE,WAAW,CAAC,CAE/F,GAAI,CAACtD,WAAW,CAAE,CAChB8B,OAAO,CAACC,GAAG,CAAC,qBAAqBF,UAAU,8BAA8B,CAAC,CAC1E;AACA,KAAM,CAAA5B,OAAO,CAACC,IAAI,CAAC2B,UAAU,CAAC,CAAC2B,MAAM,CAAC,CAACJ,YAAY,CAAC,CAAC,CACrD,MAAO,KAAI,CACb,CACF,CAAE,MAAON,SAAS,CAAE,CAClBhB,OAAO,CAAC/B,KAAK,CAAC,kDAAkD,CAAE+C,SAAS,CAAC,CAC9E,CAEAhB,OAAO,CAAC/B,KAAK,CAAC,mCAAmC8B,UAAU,GAAG,CAAE9B,KAAK,CAAC,CACtE,KAAM,CAAA/B,cAAc,CAClBD,SAAS,CAACqC,MAAM,CAChBL,KAAK,WAAY,CAAAoD,KAAK,CAClB,+CAA+CpD,KAAK,CAACM,OAAO,EAAE,CAC9D,wDAAwD,CAC5D,CAAEwB,UAAU,CAAE9B,KAAM,CACtB,CAAC,CACH,CACF,CAAC,CAED;AACA;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAA0D,qBAAqB,CAAG,cAAAA,CACnCC,QAAgB,CAChBnC,SAA2B,CAEmC,IAD9D,CAAAoC,UAAU,CAAAzE,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAC,CAEd;AACA,GAAI,CAACwE,QAAQ,CAAE,CACb,KAAM,IAAI,CAAAP,KAAK,CAAC,+CAA+C,CAAC,CAClE,CAEA,GAAI,CAAC5B,SAAS,EAAI,CAACqC,KAAK,CAACC,OAAO,CAACtC,SAAS,CAAC,EAAIA,SAAS,CAACpC,MAAM,GAAK,CAAC,CAAE,CACrE,MAAO,EAAE,CACX,CAEA,GAAI,CACF;AACA,GAAI,CAAA0C,UAAU,CAAG,kBAAkB,CAEnCC,OAAO,CAACC,GAAG,CAAC,0DAA0D2B,QAAQ,EAAE,CAAC,CACjF5B,OAAO,CAACC,GAAG,CAAC,wBAAwBR,SAAS,CAACpC,MAAM,EAAE,CAAC,CAEvD,GAAI,CAAA2E,WAAW,CAAG,KAAK,CACvB,GAAI,CACFA,WAAW,CAAG,KAAM,CAAAlC,wBAAwB,CAACC,UAAU,CAAC,CACxD,GAAIiC,WAAW,CAAE,CACfhC,OAAO,CAACC,GAAG,CAAC,UAAUF,UAAU,kCAAkC,CAAC,CACrE,CACF,CAAE,MAAOkC,WAAW,CAAE,CACpBjC,OAAO,CAAC/B,KAAK,CAAC,8BAA8B8B,UAAU,GAAG,CAAEkC,WAAW,CAAC,CACvE;AACAlC,UAAU,CAAG,WAAW,CACxBC,OAAO,CAACC,GAAG,CAAC,6CAA6CF,UAAU,uBAAuB,CAAC,CAC3F,GAAI,CACFiC,WAAW,CAAG,KAAM,CAAAlC,wBAAwB,CAACC,UAAU,CAAC,CACxD,GAAIiC,WAAW,CAAE,CACfhC,OAAO,CAACC,GAAG,CAAC,8BAA8BF,UAAU,mBAAmB,CAAC,CAC1E,CACF,CAAE,MAAOmC,aAAa,CAAE,CACtBlC,OAAO,CAAC/B,KAAK,CAAC,+CAA+C,CAAEiE,aAAa,CAAC,CAC7E,KAAM,CAAAhG,cAAc,CAClBD,SAAS,CAACqC,MAAM,CAChB,iFAAiF,CACjF,CAAE6D,aAAa,CAAEF,WAAY,CAC/B,CAAC,CACH,CACF,CAEA,KAAM,CAAA9D,OAAO,CAAG5B,UAAU,CAAC,CAAC,CAC5B,KAAM,CAAAmD,YAAmE,CAAG,EAAE,CAC9E,KAAM,CAAAC,UAA6C,CAAG,EAAE,CAExD;AACA,KAAM,CAAAyC,SAAS,CAAG3C,SAAS,CAAC4C,MAAM,CAACC,GAAG,EACpCA,GAAG,EAAIA,GAAG,CAAC5F,IAAI,EAAI4F,GAAG,CAAC5F,IAAI,WAAY,CAAA6F,IAAI,EAAID,GAAG,CAACE,QAAQ,EAAIF,GAAG,CAAC7E,IACrE,CAAC,CACDuC,OAAO,CAACC,GAAG,CAAC,mCAAmCmC,SAAS,CAAC/E,MAAM,OAAOoC,SAAS,CAACpC,MAAM,EAAE,CAAC,CAEzF,GAAI+E,SAAS,CAAC/E,MAAM,GAAK,CAAC,CAAE,CAC1B2C,OAAO,CAACkB,IAAI,CAAC,gFAAgF,CAAC,CAC9F,MAAO,EAAE,CACX,CAEA,IAAK,GAAI,CAAAuB,QAAQ,CAAG,CAAC,CAAEA,QAAQ,CAAGL,SAAS,CAAC/E,MAAM,CAAEoF,QAAQ,EAAE,CAAE,CAC9D,KAAM,CAAAH,GAAG,CAAGF,SAAS,CAACK,QAAQ,CAAC,CAC/B,GAAI,CAAAC,OAAO,CAAG,EAAE,CAChB,GAAI,CAAAC,OAAO,CAAG,KAAK,CACnB,GAAI,CAAAC,OAAO,CAAG,CAAC,CACf,GAAI,CAAAjC,SAAS,CAAG,IAAI,CAEpBX,OAAO,CAACC,GAAG,CAAC,wBAAwBwC,QAAQ,CAAG,CAAC,IAAIL,SAAS,CAAC/E,MAAM,MAAMiF,GAAG,CAAC7E,IAAI,MAAM6E,GAAG,CAAC5F,IAAI,CAACK,IAAI,SAAS,CAAC,CAE/G,MAAO,CAAC4F,OAAO,EAAIC,OAAO,EAAIf,UAAU,CAAE,CACxCe,OAAO,EAAE,CACT,GAAI,CACF;AACA,KAAM,CAAAC,SAAS,CAAG,GAAI,CAAA7D,IAAI,CAAC,CAAC,CAAC8D,OAAO,CAAC,CAAC,CACtC,KAAM,CAAAC,YAAY,CAAGT,GAAG,CAAC5F,IAAI,CAACe,IAAI,CAACuF,OAAO,CAAC,iBAAiB,CAAE,GAAG,CAAC,CAAE;AACpE,KAAM,CAAAxF,QAAQ,CAAG,GAAGqF,SAAS,IAAIE,YAAY,EAAE,CAC/C,KAAM,CAAA/E,QAAQ,CAAG,GAAG4D,QAAQ,IAAIU,GAAG,CAACE,QAAQ,IAAIhF,QAAQ,EAAE,CAE1DwC,OAAO,CAACC,GAAG,CAAC,WAAW2C,OAAO,IAAIf,UAAU,CAAC,CAAC,eAAeS,GAAG,CAAC7E,IAAI,OAAOsC,UAAU,IAAI/B,QAAQ,EAAE,CAAC,CAErG;AACA,KAAM,CAAEQ,IAAI,CAAEP,KAAM,CAAC,CAAG,KAAM,CAAAE,OAAO,CAClCC,IAAI,CAAC2B,UAAU,CAAC,CAChB1B,MAAM,CAACL,QAAQ,CAAEsE,GAAG,CAAC5F,IAAI,CAAE,CAC1BuG,YAAY,CAAE,MAAM,CACpBC,MAAM,CAAE,IAAM;AAChB,CAAC,CAAC,CAEJ,GAAIjF,KAAK,CAAE,CACT+B,OAAO,CAAC/B,KAAK,CAAC,2BAA2BqE,GAAG,CAAC7E,IAAI,cAAcmF,OAAO,IAAIf,UAAU,CAAC,CAAC,IAAI,CAAE5D,KAAK,CAAC,CAClG0C,SAAS,CAAG1C,KAAK,CACjB,KAAM,CAAAA,KAAK,CACb,CAEA;AACA,KAAM,CAAEO,IAAI,CAAE2E,OAAQ,CAAC,CAAGhF,OAAO,CAC9BC,IAAI,CAAC2B,UAAU,CAAC,CAChBrB,YAAY,CAACV,QAAQ,CAAC,CAEzB0E,OAAO,CAAGS,OAAO,CAACtE,SAAS,CAC3B8D,OAAO,CAAG,IAAI,CACd3C,OAAO,CAACC,GAAG,CAAC,gBAAgBqC,GAAG,CAAC7E,IAAI,2BAA2BsC,UAAU,IAAI/B,QAAQ,EAAE,CAAC,CAC1F,CAAE,MAAOC,KAAK,CAAE,CACd0C,SAAS,CAAG1C,KAAK,CAEjB;AACA,GAAIA,KAAK,WAAY,CAAAoD,KAAK,CAAE,CAC1BrB,OAAO,CAAC/B,KAAK,CAAC,uBAAuBA,KAAK,CAACM,OAAO,EAAE,CAAC,CACrD,GAAKN,KAAK,CAASmF,KAAK,CAAE,CACxBpD,OAAO,CAAC/B,KAAK,CAAC,UAAWA,KAAK,CAASmF,KAAK,EAAE,CAAC,CACjD,CACF,CAEA;AACA,GAAIR,OAAO,EAAIf,UAAU,CAAE,CACzB,KAAM,CAAAT,QAAQ,CAAGjC,IAAI,CAACC,GAAG,CAAC,CAAC,CAAEwD,OAAO,CAAC,CAAC,CAAC,CAAG,IAAI,CAAE;AAChD5C,OAAO,CAACC,GAAG,CAAC,aAAamB,QAAQ,qCAAqC,CAAC,CACvE,KAAM,IAAI,CAAA/B,OAAO,CAACC,OAAO,EAAIC,UAAU,CAACD,OAAO,CAAE8B,QAAQ,CAAC,CAAC,CAC7D,CAAC,IAAM,CACLpB,OAAO,CAAC/B,KAAK,CAAC,yBAAyBqE,GAAG,CAAC7E,IAAI,gBAAgBmF,OAAO,YAAY,CAAC,CACnFjD,UAAU,CAACE,IAAI,CAAC,CACdpC,IAAI,CAAE6E,GAAG,CAAC7E,IAAI,EAAI6E,GAAG,CAAC5F,IAAI,CAACe,IAAI,CAC/BQ,KAAK,CAAEA,KACT,CAAC,CAAC,CAEF;AACA,KAAM,CAAAC,WAAW,CAAGhC,cAAc,CAChCD,SAAS,CAACqC,MAAM,CAChB,6BAA6BgE,GAAG,CAAC7E,IAAI,EAAI6E,GAAG,CAAC5F,IAAI,CAACe,IAAI,gBAAgBoE,UAAU,CAAC,CAAC,WAAW,CAC7F,CACEwB,YAAY,CAAEf,GAAG,CAAC7E,IAAI,CACtBmE,QAAQ,CACRY,QAAQ,CAAEF,GAAG,CAACE,QAAQ,CACtBc,QAAQ,CAAEV,OACZ,CAAC,CACD3E,KACF,CAAC,CAED9B,QAAQ,CAAC+B,WAAW,CAAE,uBAAuB,CAAC,CAChD,CACF,CACF,CAEA,GAAIyE,OAAO,CAAE,CACX;AACA,KAAM,CAAEjG,IAAI,CAAE,GAAG6G,cAAe,CAAC,CAAGjB,GAAG,CACvC5C,YAAY,CAACG,IAAI,CAAC,CAChB,GAAG0D,cAAc,CACjB3E,GAAG,CAAE8D,OACP,CAAC,CAAC,CACJ,CACF,CAEA,GAAI/C,UAAU,CAACtC,MAAM,CAAG,CAAC,CAAE,CACzB2C,OAAO,CAACkB,IAAI,CAAC,MAAMvB,UAAU,CAACtC,MAAM,kDAAkD+E,SAAS,CAAC/E,MAAM,GAAG,CAAEsC,UAAU,CAAC,CACxH,CAEAK,OAAO,CAACC,GAAG,CAAC,eAAeP,YAAY,CAACrC,MAAM,qCAAqCsC,UAAU,CAACtC,MAAM,YAAY,CAAC,CACjH,MAAO,CAAAqC,YAAY,CACrB,CAAE,MAAOzB,KAAK,CAAE,CACd+B,OAAO,CAAC/B,KAAK,CAAC,2CAA2C,CAAEA,KAAK,CAAC,CAEjE;AACA,GAAI,CAAAuF,YAAY,CAAG,2BAA2B,CAC9C,GAAIvF,KAAK,WAAY,CAAAoD,KAAK,CAAE,CAC1BmC,YAAY,CAAGvF,KAAK,CAACM,OAAO,CAC9B,CAAC,IAAM,IAAI,MAAO,CAAAN,KAAK,GAAK,QAAQ,EAAIA,KAAK,GAAK,IAAI,EAAI,SAAS,EAAI,CAAAA,KAAK,CAAE,CAC5EuF,YAAY,CAAIvF,KAAK,CAASM,OAAO,EAAIiF,YAAY,CACvD,CAEA,KAAM,CAAAtH,cAAc,CAClBD,SAAS,CAACqC,MAAM,CAChBkF,YAAY,CACZ,CAAE5B,QAAQ,CAAE3D,KAAM,CACpB,CAAC,CACH,CACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}