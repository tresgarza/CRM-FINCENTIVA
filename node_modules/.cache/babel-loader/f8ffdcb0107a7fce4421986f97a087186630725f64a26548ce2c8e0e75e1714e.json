{"ast":null,"code":"var _jsxFileName = \"/Users/diegogg98/NEW CRM MAR18/src/contexts/NotificationContext.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useState, useEffect, useRef } from 'react';\nimport { useAuth } from './AuthContext';\nimport NotificationPopup from '../components/ui/NotificationPopup';\n\n// Generate a proper UUID for notification IDs\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nfunction generateUUID() {\n  // Use a more standard implementation for UUID v4\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n\n// For test notifications, use a valid UUID format - don't use app-timestamp\nfunction getTestApplicationId() {\n  // Use a small set of real UUIDs as sample application IDs\n  const sampleIds = ['110cc76a-1762-4df4-840e-a503fea9d7aa', '220cc76a-1762-4df4-840e-a503fea9d7bb', '330cc76a-1762-4df4-840e-a503fea9d7cc', '440cc76a-1762-4df4-840e-a503fea9d7dd', '550cc76a-1762-4df4-840e-a503fea9d7ee'];\n\n  // Pick a random ID from the sample list\n  return sampleIds[Math.floor(Math.random() * sampleIds.length)];\n}\n\n// Enum for notification types\nexport let NotificationType = /*#__PURE__*/function (NotificationType) {\n  NotificationType[\"INFO\"] = \"info\";\n  NotificationType[\"SUCCESS\"] = \"success\";\n  NotificationType[\"WARNING\"] = \"warning\";\n  NotificationType[\"ERROR\"] = \"error\";\n  NotificationType[\"NEW_APPLICATION\"] = \"new_application\";\n  NotificationType[\"APPROVAL_REQUIRED\"] = \"approval_required\";\n  NotificationType[\"NEW_MESSAGE\"] = \"new_message\";\n  NotificationType[\"APPLICATION_STATUS_UPDATED\"] = \"application_status_updated\";\n  NotificationType[\"APPLICATION_COMMENT\"] = \"application_comment\";\n  return NotificationType;\n}({});\n\n// Interfaces\n\nexport const NotificationContext = /*#__PURE__*/createContext(undefined);\nexport const useNotifications = () => {\n  _s();\n  const context = useContext(NotificationContext);\n  if (context === undefined) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n};\n_s(useNotifications, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport const NotificationProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    user\n  } = useAuth();\n  const [notifications, setNotifications] = useState([]);\n  const [unreadCount, setUnreadCount] = useState(0);\n  const [soundEnabled, setSoundEnabled] = useState(true);\n\n  // Estado para la notificación emergente actual\n  const [currentPopup, setCurrentPopup] = useState(null);\n\n  // Referencia al ID del polling interval\n  const pollingIntervalRef = useRef(null);\n\n  // State to keep track of already notified application IDs with timestamps\n  // This helps prevent showing the same notification multiple times\n  const [notifiedApplications, setNotifiedApplications] = useState(new Map());\n\n  // Referencia para evitar múltiples ejecuciones simultáneas\n  const checkingRef = useRef(false);\n\n  // Reference to the latest known notification time\n  const lastNotificationTimeRef = useRef(new Date());\n\n  // Avoid duplicate notifications by ensuring we have a minimum interval between checks\n  const lastCheckTimeRef = useRef(new Date());\n\n  // Efecto para manejar la carga inicial de notificaciones y configurar el polling\n  useEffect(() => {\n    if (user) {\n      // Cargar notificaciones al inicio\n      loadNotifications();\n\n      // Cargar aplicaciones ya notificadas desde localStorage\n      try {\n        const storedNotifications = localStorage.getItem('notified_application_ids');\n        if (storedNotifications) {\n          const parsedData = JSON.parse(storedNotifications);\n\n          // Handle both old format (array) and new format (object with timestamps)\n          if (Array.isArray(parsedData)) {\n            // Old format - convert to new Map with current timestamp\n            const notifiedMap = new Map();\n            const now = Date.now();\n            parsedData.forEach(id => {\n              notifiedMap.set(id, now);\n            });\n            setNotifiedApplications(notifiedMap);\n            // Re-save with the new format\n            saveNotifiedApplications(notifiedMap);\n            console.log(`Converted ${notifiedMap.size} notified application IDs from old format to new format`);\n          } else if (typeof parsedData === 'object') {\n            // New format - convert object to Map\n            const notifiedMap = new Map();\n            Object.entries(parsedData).forEach(([id, timestamp]) => {\n              notifiedMap.set(id, timestamp);\n            });\n            setNotifiedApplications(notifiedMap);\n            console.log(`Loaded ${notifiedMap.size} notified application IDs from localStorage`);\n          }\n        } else {\n          console.log('No previously notified applications found in localStorage');\n        }\n\n        // Limpiar notificaciones antiguas (más de 48 horas)\n        cleanupOldNotifications();\n      } catch (error) {\n        console.error('Error loading notified applications:', error);\n        // Reset if there's an error\n        setNotifiedApplications(new Map());\n      }\n\n      // Set the initial last check time to now\n      lastCheckTimeRef.current = new Date();\n      // Set the initial last notification time to 10 seconds ago to avoid immediate checks\n      lastNotificationTimeRef.current = new Date(Date.now() - 10000);\n\n      // Wait 5 seconds before first check to ensure UI is fully loaded\n      const initialCheckTimeout = setTimeout(() => {\n        // Verificar al inicio si hay solicitudes recientes\n        checkForNewNotifications();\n\n        // Configurar polling para verificar nuevas notificaciones cada 45 seconds\n        // Increased from 30 to 45 seconds to reduce duplicate risks\n        pollingIntervalRef.current = setInterval(() => {\n          const now = new Date();\n          const timeSinceLastCheck = now.getTime() - lastCheckTimeRef.current.getTime();\n          const timeSinceLastNotification = now.getTime() - lastNotificationTimeRef.current.getTime();\n\n          // Only check if:\n          // 1. It's been at least 30 seconds since last check AND\n          // 2. It's been at least 10 seconds since showing a notification\n          if (timeSinceLastCheck > 30000 && timeSinceLastNotification > 10000) {\n            checkForNewNotifications();\n          } else {\n            console.log(`Skipping notification check (last check: ${(timeSinceLastCheck / 1000).toFixed(1)}s ago, last notification: ${(timeSinceLastNotification / 1000).toFixed(1)}s ago)`);\n          }\n        }, 45000);\n      }, 5000);\n\n      // Limpiar el intervalo cuando el componente se desmonte\n      return () => {\n        if (pollingIntervalRef.current) {\n          clearInterval(pollingIntervalRef.current);\n        }\n        clearTimeout(initialCheckTimeout);\n      };\n    }\n  }, [user]);\n\n  // Cálculo de notificaciones no leídas\n  useEffect(() => {\n    const count = notifications.filter(notification => !notification.read).length;\n    setUnreadCount(count);\n  }, [notifications]);\n\n  // Cargar notificaciones del almacenamiento local o del servidor\n  const loadNotifications = async () => {\n    try {\n      // En un escenario real, aquí se cargarían las notificaciones del servidor\n      // Por ahora, usaremos el localStorage como ejemplo\n      const storedNotifications = localStorage.getItem('notifications');\n      if (storedNotifications) {\n        const parsed = JSON.parse(storedNotifications);\n        setNotifications(parsed.map(n => ({\n          ...n,\n          createdAt: new Date(n.createdAt)\n        })));\n      }\n    } catch (error) {\n      console.error('Error loading notifications:', error);\n    }\n  };\n\n  // Save notified applications with timestamps to localStorage\n  const saveNotifiedApplications = notifiedMap => {\n    try {\n      // Convert Map to object for storage\n      const notifiedObject = {};\n      notifiedMap.forEach((timestamp, id) => {\n        notifiedObject[id] = timestamp;\n      });\n      localStorage.setItem('notified_application_ids', JSON.stringify(notifiedObject));\n      console.log(`Saved ${notifiedMap.size} notified application IDs to localStorage`);\n    } catch (error) {\n      console.error('Error saving notified applications:', error);\n    }\n  };\n\n  // Limpia notificaciones antiguas (más de 48 horas)\n  const cleanupOldNotifications = () => {\n    try {\n      const now = Date.now();\n      const twoDaysInMs = 48 * 60 * 60 * 1000; // 48 horas en milisegundos\n      const updatedMap = new Map();\n\n      // Solo conservamos notificaciones de las últimas 48 horas\n      notifiedApplications.forEach((timestamp, id) => {\n        if (now - timestamp < twoDaysInMs) {\n          updatedMap.set(id, timestamp);\n        }\n      });\n      if (updatedMap.size !== notifiedApplications.size) {\n        console.log(`Cleaned up ${notifiedApplications.size - updatedMap.size} old notifications`);\n        setNotifiedApplications(updatedMap);\n        saveNotifiedApplications(updatedMap);\n      }\n    } catch (error) {\n      console.error('Error cleaning up old notifications:', error);\n    }\n  };\n\n  // Mark an application as notified to prevent duplicate notifications\n  const markApplicationAsNotified = applicationId => {\n    // Don't do anything if it's already marked\n    if (notifiedApplications.has(applicationId)) {\n      console.log(`Application ${applicationId} already marked as notified - skipping`);\n      return;\n    }\n    const now = Date.now();\n    const updatedMap = new Map(notifiedApplications);\n    updatedMap.set(applicationId, now);\n    setNotifiedApplications(updatedMap);\n    saveNotifiedApplications(updatedMap);\n\n    // Also update the last notification time to prevent immediate duplicates\n    lastNotificationTimeRef.current = new Date();\n    console.log(`Marked application ${applicationId} as notified`);\n  };\n\n  // Verificar nuevas notificaciones en el servidor\n  const checkForNewNotifications = async () => {\n    // Record the check time immediately to prevent race conditions\n    lastCheckTimeRef.current = new Date();\n\n    // Avoid multiple executions at the same time\n    if (checkingRef.current) {\n      console.log('Already checking for notifications');\n      return;\n    }\n\n    // Make sure we don't have any lingering popups\n    clearPopups();\n\n    // Sincronizar con localStorage antes de verificar para evitar duplicados\n    try {\n      const storedNotifications = localStorage.getItem('notified_application_ids');\n      if (storedNotifications) {\n        const parsedData = JSON.parse(storedNotifications);\n        if (typeof parsedData === 'object' && !Array.isArray(parsedData)) {\n          // Fusionar con las notificaciones actuales\n          const updatedMap = new Map(notifiedApplications);\n          let hasChanges = false;\n          Object.entries(parsedData).forEach(([id, timestamp]) => {\n            if (!updatedMap.has(id)) {\n              updatedMap.set(id, timestamp);\n              hasChanges = true;\n            }\n          });\n          if (hasChanges) {\n            console.log('Synchronized notification IDs from localStorage before checking');\n            setNotifiedApplications(updatedMap);\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error synchronizing notifications from localStorage:', error);\n    }\n    checkingRef.current = true;\n    console.log('Checking for new notifications...');\n    try {\n      // Convert notified IDs Map to array for logging\n      const notifiedIdsArray = Array.from(notifiedApplications.keys());\n      console.log(`${notifiedIdsArray.length} already notified application IDs: ${notifiedIdsArray.join(', ').substring(0, 200)}${notifiedIdsArray.length > 5 ? '...' : ''}`);\n\n      // IMPORTANTE: Solo consultar aplicaciones de los últimos 30 segundos\n      // Esto evita notificaciones sobre aplicaciones antiguas\n      const thirtySecondsAgo = new Date();\n      thirtySecondsAgo.setSeconds(thirtySecondsAgo.getSeconds() - 30);\n      const response = await fetch('http://localhost:3100/query', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          query: `\n            SELECT id, client_name, application_type, company_name, created_at, status, \n                   amount, term, interest_rate, monthly_payment\n            FROM applications \n            WHERE created_at > NOW() - INTERVAL '30 seconds'\n            ORDER BY created_at DESC\n            LIMIT 5\n          `\n        })\n      });\n      if (!response.ok) {\n        throw new Error('Error querying recent applications');\n      }\n      const data = await response.json();\n\n      // If there are applications, filter them first and then show notification\n      if (data.data && data.data.length > 0) {\n        console.log(`Received ${data.data.length} applications from the last 30 seconds`);\n\n        // Filter out any applications that have already been notified\n        const newApps = data.data.filter(app => {\n          const isAlreadyNotified = notifiedApplications.has(app.id);\n          if (isAlreadyNotified) {\n            console.log(`Skipping already notified application: ${app.id}`);\n            return false;\n          }\n\n          // Convertir el timestamp de la aplicación a Date para comparar\n          const appCreatedAt = new Date(app.created_at);\n\n          // Si la aplicación es de hace más de 60 segundos, no notificar\n          const isTooOld = new Date().getTime() - appCreatedAt.getTime() > 60000;\n          if (isTooOld) {\n            console.log(`Skipping too old application: ${app.id} created at ${appCreatedAt.toISOString()}`);\n            // Marcar como notificada para evitar mostrarla en futuras verificaciones\n            markApplicationAsNotified(app.id);\n            return false;\n          }\n          return true;\n        });\n        console.log(`Found ${newApps.length} new applications after filtering`);\n        if (newApps.length === 0) {\n          console.log('No truly new applications found (already notified or too old)');\n          checkingRef.current = false;\n          return;\n        }\n\n        // Take only the first new application to show\n        const newApp = newApps[0];\n        const appId = newApp.id;\n\n        // Verificar si ya está en proceso de notificación (para evitar doble notificación)\n        if (currentPopup && currentPopup.relatedItemId === appId) {\n          console.log(`Already showing notification for application ${appId} - skipping`);\n          checkingRef.current = false;\n          return;\n        }\n        console.log(`New application detected: ${appId} (created ${new Date(newApp.created_at).toISOString()})`);\n\n        // IMPORTANT: Mark as notified IMMEDIATELY to prevent duplicates\n        // even if processing fails later\n        markApplicationAsNotified(appId);\n\n        // Format data for notification\n        const createdAt = new Date(newApp.created_at);\n        const formattedDate = new Intl.DateTimeFormat('es-MX', {\n          day: '2-digit',\n          month: '2-digit',\n          year: 'numeric'\n        }).format(createdAt);\n        const formattedTime = new Intl.DateTimeFormat('es-MX', {\n          hour: '2-digit',\n          minute: '2-digit',\n          hour12: true\n        }).format(createdAt);\n\n        // Format amount with thousands separator and 2 decimals\n        const formattedAmount = new Intl.NumberFormat('es-MX', {\n          style: 'currency',\n          currency: 'MXN',\n          minimumFractionDigits: 2\n        }).format(Number(newApp.amount || 0));\n\n        // Format interest rate with percentage\n        const formattedRate = `${newApp.interest_rate || 0}%`;\n\n        // Format monthly payment\n        const formattedMonthly = new Intl.NumberFormat('es-MX', {\n          style: 'currency',\n          currency: 'MXN',\n          minimumFractionDigits: 2\n        }).format(Number(newApp.monthly_payment || 0));\n\n        // Transform application type to a more readable format\n        let appType = 'No especificado';\n        if (newApp.application_type) {\n          // Remove any trailing slash if it exists\n          const cleanType = newApp.application_type.replace(/\\/$/, '');\n          if (cleanType === 'selected_plans') {\n            appType = 'Planes seleccionados';\n          } else if (cleanType === 'product_simulations') {\n            appType = 'Simulación de producto';\n          } else {\n            appType = cleanType.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');\n          }\n        }\n\n        // Create a well-structured HTML message for the popup\n        const detailedMessage = `\n          <div class=\"grid grid-cols-2 gap-2 text-sm mt-2\">\n            <div class=\"font-semibold text-gray-700\">Cliente:</div>\n            <div class=\"text-gray-900\">${newApp.client_name || 'Sin nombre'}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Empresa:</div>\n            <div class=\"text-gray-900\">${newApp.company_name || 'No especificada'}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Tipo:</div>\n            <div class=\"text-gray-900\">${appType}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Monto:</div>\n            <div class=\"text-gray-900\">${formattedAmount}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Plazo:</div>\n            <div class=\"text-gray-900\">${newApp.term || 'N/A'} ${newApp.term === 1 ? 'mes' : 'meses'}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Tasa:</div>\n            <div class=\"text-gray-900\">${formattedRate}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Pago mensual:</div>\n            <div class=\"text-gray-900\">${formattedMonthly}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Fecha:</div>\n            <div class=\"text-gray-900\">${formattedDate} ${formattedTime}</div>\n          </div>\n        `;\n        const notificationTitle = '💼 Nueva solicitud recibida';\n\n        // Create the notification for the panel\n        const newNotification = {\n          title: notificationTitle,\n          message: `Cliente: ${newApp.client_name || 'Sin nombre'} - ${newApp.company_name || 'Empresa no especificada'}`,\n          type: NotificationType.NEW_APPLICATION,\n          relatedItemType: 'application',\n          relatedItemId: appId\n        };\n\n        // Add the notification to the panel\n        addNotification(newNotification);\n\n        // Show popup with complete details\n        showPopup({\n          title: notificationTitle,\n          message: detailedMessage,\n          type: NotificationType.NEW_APPLICATION,\n          playSound: soundEnabled,\n          soundType: 'notification',\n          duration: 10000,\n          // 10 seconds\n          customSound: '/sounds/clean-notification.mp3',\n          centerScreen: true,\n          relatedItemId: appId\n        });\n\n        // Update last notification time to avoid duplicates\n        lastNotificationTimeRef.current = new Date();\n      } else {\n        console.log('No new applications found in the last 30 seconds');\n      }\n    } catch (error) {\n      console.error('Error checking for new notifications:', error);\n    } finally {\n      // Always mark as not running regardless of the result\n      checkingRef.current = false;\n    }\n  };\n\n  // Añadir una nueva notificación\n  const addNotification = notification => {\n    const newNotification = {\n      ...notification,\n      // Using a proper UUID for the notification ID\n      id: generateUUID(),\n      createdAt: new Date(),\n      read: false,\n      timestamp: new Date()\n    };\n    setNotifications(prev => {\n      const updated = [newNotification, ...prev];\n      // Guardar en localStorage (en producción esto iría al servidor)\n      localStorage.setItem('notifications', JSON.stringify(updated));\n      return updated;\n    });\n  };\n\n  // Marcar una notificación como leída\n  const markAsRead = id => {\n    setNotifications(prev => {\n      const updated = prev.map(notification => notification.id === id ? {\n        ...notification,\n        read: true,\n        isRead: true\n      } : notification);\n\n      // Guardar en localStorage\n      localStorage.setItem('notifications', JSON.stringify(updated));\n      return updated;\n    });\n  };\n\n  // Marcar todas las notificaciones como leídas\n  const markAllAsRead = () => {\n    setNotifications(prev => {\n      const updated = prev.map(notification => ({\n        ...notification,\n        read: true,\n        isRead: true\n      }));\n\n      // Guardar en localStorage\n      localStorage.setItem('notifications', JSON.stringify(updated));\n      return updated;\n    });\n  };\n\n  // Limpiar todas las notificaciones\n  const clearNotifications = () => {\n    setNotifications([]);\n    // Limpiar del localStorage\n    localStorage.setItem('notifications', JSON.stringify([]));\n  };\n\n  // Mostrar una notificación emergente\n  const showPopup = config => {\n    // Verificar si ya hay un popup con el mismo título y mensaje (posible duplicado)\n    if (currentPopup && currentPopup.title === config.title && currentPopup.message === config.message) {\n      console.log('Ignoring duplicate popup with the same content');\n      return;\n    }\n\n    // Clear any existing popups to prevent stacking\n    clearPopups();\n\n    // Log what we're showing\n    console.log(`Showing popup: ${config.title}`);\n\n    // Short timeout to ensure DOM updates before showing the new popup\n    setTimeout(() => {\n      setCurrentPopup(config);\n\n      // Automatically close popup after the specified duration\n      setTimeout(() => {\n        setCurrentPopup(null);\n      }, config.duration || 5000);\n    }, 50);\n  };\n\n  // Clear any pending popups\n  const clearPopups = () => {\n    if (currentPopup) {\n      console.log('Clearing existing popup');\n      setCurrentPopup(null);\n    }\n  };\n\n  // Activar/desactivar sonidos de notificación\n  const toggleSound = () => {\n    const newValue = !soundEnabled;\n    setSoundEnabled(newValue);\n    // Guardar preferencia en localStorage\n    localStorage.setItem('notification_sound_enabled', newValue.toString());\n  };\n  const value = {\n    notifications,\n    unreadCount,\n    addNotification,\n    markAsRead,\n    markAllAsRead,\n    clearNotifications,\n    showPopup,\n    soundEnabled,\n    toggleSound,\n    setSoundEnabled\n  };\n  return /*#__PURE__*/_jsxDEV(NotificationContext.Provider, {\n    value: value,\n    children: [children, currentPopup && /*#__PURE__*/_jsxDEV(NotificationPopup, {\n      title: currentPopup.title,\n      message: currentPopup.message,\n      type: currentPopup.type,\n      duration: currentPopup.duration,\n      playSound: currentPopup.playSound,\n      soundType: currentPopup.soundType,\n      customSound: currentPopup.customSound,\n      onClose: () => setCurrentPopup(null),\n      centerScreen: currentPopup.centerScreen\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 644,\n      columnNumber: 9\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 641,\n    columnNumber: 5\n  }, this);\n};\n_s2(NotificationProvider, \"761ZEwnDqoPaVf275MjxyO3vdG8=\", false, function () {\n  return [useAuth];\n});\n_c = NotificationProvider;\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");","map":{"version":3,"names":["React","createContext","useContext","useState","useEffect","useRef","useAuth","NotificationPopup","jsxDEV","_jsxDEV","generateUUID","replace","c","r","Math","random","v","toString","getTestApplicationId","sampleIds","floor","length","NotificationType","NotificationContext","undefined","useNotifications","_s","context","Error","NotificationProvider","children","_s2","user","notifications","setNotifications","unreadCount","setUnreadCount","soundEnabled","setSoundEnabled","currentPopup","setCurrentPopup","pollingIntervalRef","notifiedApplications","setNotifiedApplications","Map","checkingRef","lastNotificationTimeRef","Date","lastCheckTimeRef","loadNotifications","storedNotifications","localStorage","getItem","parsedData","JSON","parse","Array","isArray","notifiedMap","now","forEach","id","set","saveNotifiedApplications","console","log","size","Object","entries","timestamp","cleanupOldNotifications","error","current","initialCheckTimeout","setTimeout","checkForNewNotifications","setInterval","timeSinceLastCheck","getTime","timeSinceLastNotification","toFixed","clearInterval","clearTimeout","count","filter","notification","read","parsed","map","n","createdAt","notifiedObject","setItem","stringify","twoDaysInMs","updatedMap","markApplicationAsNotified","applicationId","has","clearPopups","hasChanges","notifiedIdsArray","from","keys","join","substring","thirtySecondsAgo","setSeconds","getSeconds","response","fetch","method","headers","body","query","ok","data","json","newApps","app","isAlreadyNotified","appCreatedAt","created_at","isTooOld","toISOString","newApp","appId","relatedItemId","formattedDate","Intl","DateTimeFormat","day","month","year","format","formattedTime","hour","minute","hour12","formattedAmount","NumberFormat","style","currency","minimumFractionDigits","Number","amount","formattedRate","interest_rate","formattedMonthly","monthly_payment","appType","application_type","cleanType","split","word","charAt","toUpperCase","slice","detailedMessage","client_name","company_name","term","notificationTitle","newNotification","title","message","type","NEW_APPLICATION","relatedItemType","addNotification","showPopup","playSound","soundType","duration","customSound","centerScreen","prev","updated","markAsRead","isRead","markAllAsRead","clearNotifications","config","toggleSound","newValue","value","Provider","onClose","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/contexts/NotificationContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useState, useEffect, useRef } from 'react';\nimport { useAuth } from './AuthContext';\nimport NotificationPopup from '../components/ui/NotificationPopup';\n\n// Generate a proper UUID for notification IDs\nfunction generateUUID() {\n  // Use a more standard implementation for UUID v4\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\n// For test notifications, use a valid UUID format - don't use app-timestamp\nfunction getTestApplicationId() {\n  // Use a small set of real UUIDs as sample application IDs\n  const sampleIds = [\n    '110cc76a-1762-4df4-840e-a503fea9d7aa',\n    '220cc76a-1762-4df4-840e-a503fea9d7bb',\n    '330cc76a-1762-4df4-840e-a503fea9d7cc',\n    '440cc76a-1762-4df4-840e-a503fea9d7dd',\n    '550cc76a-1762-4df4-840e-a503fea9d7ee'\n  ];\n  \n  // Pick a random ID from the sample list\n  return sampleIds[Math.floor(Math.random() * sampleIds.length)];\n}\n\n// Enum for notification types\nexport enum NotificationType {\n  INFO = 'info',\n  SUCCESS = 'success',\n  WARNING = 'warning',\n  ERROR = 'error',\n  NEW_APPLICATION = 'new_application',\n  APPROVAL_REQUIRED = 'approval_required',\n  NEW_MESSAGE = 'new_message',\n  APPLICATION_STATUS_UPDATED = 'application_status_updated',\n  APPLICATION_COMMENT = 'application_comment',\n}\n\n// Interfaces\ninterface Notification {\n  id: string;\n  title: string;\n  message: string;\n  createdAt: Date;\n  read: boolean;\n  type: NotificationType | 'info' | 'success' | 'warning' | 'error';\n  relatedItemId?: string;\n  relatedItemType?: string;\n  data?: any;\n  timestamp?: Date;\n  isRead?: boolean;\n}\n\ninterface NotificationPopupConfig {\n  title: string;\n  message: string;\n  type?: NotificationType | 'info' | 'success' | 'warning' | 'error';\n  duration?: number;\n  playSound?: boolean;\n  soundType?: 'notification' | 'alert' | 'approval';\n  customSound?: string;\n  centerScreen?: boolean;\n}\n\ninterface NotificationContextType {\n  notifications: Notification[];\n  unreadCount: number;\n  addNotification: (notification: Omit<Notification, 'id' | 'createdAt' | 'read'>) => void;\n  markAsRead: (id: string) => void;\n  markAllAsRead: () => void;\n  clearNotifications: () => void;\n  showPopup: (config: NotificationPopupConfig) => void;\n  soundEnabled: boolean;\n  toggleSound: () => void;\n  setSoundEnabled: (enabled: boolean) => void;\n}\n\nexport const NotificationContext = createContext<NotificationContextType | undefined>(undefined);\n\nexport const useNotifications = () => {\n  const context = useContext(NotificationContext);\n  if (context === undefined) {\n    throw new Error('useNotifications must be used within a NotificationProvider');\n  }\n  return context;\n};\n\nexport const NotificationProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n  const { user } = useAuth();\n  const [notifications, setNotifications] = useState<Notification[]>([]);\n  const [unreadCount, setUnreadCount] = useState<number>(0);\n  const [soundEnabled, setSoundEnabled] = useState<boolean>(true);\n  \n  // Estado para la notificación emergente actual\n  const [currentPopup, setCurrentPopup] = useState<NotificationPopupConfig | null>(null);\n  \n  // Referencia al ID del polling interval\n  const pollingIntervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  // State to keep track of already notified application IDs with timestamps\n  // This helps prevent showing the same notification multiple times\n  const [notifiedApplications, setNotifiedApplications] = useState<Map<string, number>>(new Map());\n\n  // Referencia para evitar múltiples ejecuciones simultáneas\n  const checkingRef = useRef<boolean>(false);\n  \n  // Reference to the latest known notification time\n  const lastNotificationTimeRef = useRef<Date>(new Date());\n  \n  // Avoid duplicate notifications by ensuring we have a minimum interval between checks\n  const lastCheckTimeRef = useRef<Date>(new Date());\n\n  // Efecto para manejar la carga inicial de notificaciones y configurar el polling\n  useEffect(() => {\n    if (user) {\n      // Cargar notificaciones al inicio\n      loadNotifications();\n\n      // Cargar aplicaciones ya notificadas desde localStorage\n      try {\n        const storedNotifications = localStorage.getItem('notified_application_ids');\n        if (storedNotifications) {\n          const parsedData = JSON.parse(storedNotifications);\n          \n          // Handle both old format (array) and new format (object with timestamps)\n          if (Array.isArray(parsedData)) {\n            // Old format - convert to new Map with current timestamp\n            const notifiedMap = new Map();\n            const now = Date.now();\n            parsedData.forEach((id: string) => {\n              notifiedMap.set(id, now);\n            });\n            setNotifiedApplications(notifiedMap);\n            // Re-save with the new format\n            saveNotifiedApplications(notifiedMap);\n            console.log(`Converted ${notifiedMap.size} notified application IDs from old format to new format`);\n          } else if (typeof parsedData === 'object') {\n            // New format - convert object to Map\n            const notifiedMap = new Map();\n            Object.entries(parsedData).forEach(([id, timestamp]) => {\n              notifiedMap.set(id, timestamp as number);\n            });\n            setNotifiedApplications(notifiedMap);\n            console.log(`Loaded ${notifiedMap.size} notified application IDs from localStorage`);\n          }\n        } else {\n          console.log('No previously notified applications found in localStorage');\n        }\n        \n        // Limpiar notificaciones antiguas (más de 48 horas)\n        cleanupOldNotifications();\n      } catch (error) {\n        console.error('Error loading notified applications:', error);\n        // Reset if there's an error\n        setNotifiedApplications(new Map());\n      }\n      \n      // Set the initial last check time to now\n      lastCheckTimeRef.current = new Date();\n      // Set the initial last notification time to 10 seconds ago to avoid immediate checks\n      lastNotificationTimeRef.current = new Date(Date.now() - 10000);\n      \n      // Wait 5 seconds before first check to ensure UI is fully loaded\n      const initialCheckTimeout = setTimeout(() => {\n        // Verificar al inicio si hay solicitudes recientes\n        checkForNewNotifications();\n        \n        // Configurar polling para verificar nuevas notificaciones cada 45 seconds\n        // Increased from 30 to 45 seconds to reduce duplicate risks\n        pollingIntervalRef.current = setInterval(() => {\n          const now = new Date();\n          const timeSinceLastCheck = now.getTime() - lastCheckTimeRef.current.getTime();\n          const timeSinceLastNotification = now.getTime() - lastNotificationTimeRef.current.getTime();\n          \n          // Only check if:\n          // 1. It's been at least 30 seconds since last check AND\n          // 2. It's been at least 10 seconds since showing a notification\n          if (timeSinceLastCheck > 30000 && timeSinceLastNotification > 10000) {\n            checkForNewNotifications();\n          } else {\n            console.log(`Skipping notification check (last check: ${(timeSinceLastCheck/1000).toFixed(1)}s ago, last notification: ${(timeSinceLastNotification/1000).toFixed(1)}s ago)`);\n          }\n        }, 45000);\n      }, 5000);\n      \n      // Limpiar el intervalo cuando el componente se desmonte\n      return () => {\n        if (pollingIntervalRef.current) {\n          clearInterval(pollingIntervalRef.current);\n        }\n        clearTimeout(initialCheckTimeout);\n      };\n    }\n  }, [user]);\n\n  // Cálculo de notificaciones no leídas\n  useEffect(() => {\n    const count = notifications.filter(notification => !notification.read).length;\n    setUnreadCount(count);\n  }, [notifications]);\n\n  // Cargar notificaciones del almacenamiento local o del servidor\n  const loadNotifications = async () => {\n    try {\n      // En un escenario real, aquí se cargarían las notificaciones del servidor\n      // Por ahora, usaremos el localStorage como ejemplo\n      const storedNotifications = localStorage.getItem('notifications');\n      if (storedNotifications) {\n        const parsed = JSON.parse(storedNotifications);\n        setNotifications(parsed.map((n: any) => ({\n          ...n,\n          createdAt: new Date(n.createdAt)\n        })));\n      }\n    } catch (error) {\n      console.error('Error loading notifications:', error);\n    }\n  };\n\n  // Save notified applications with timestamps to localStorage\n  const saveNotifiedApplications = (notifiedMap: Map<string, number>) => {\n    try {\n      // Convert Map to object for storage\n      const notifiedObject: Record<string, number> = {};\n      notifiedMap.forEach((timestamp, id) => {\n        notifiedObject[id] = timestamp;\n      });\n      \n      localStorage.setItem('notified_application_ids', JSON.stringify(notifiedObject));\n      console.log(`Saved ${notifiedMap.size} notified application IDs to localStorage`);\n    } catch (error) {\n      console.error('Error saving notified applications:', error);\n    }\n  };\n\n  // Limpia notificaciones antiguas (más de 48 horas)\n  const cleanupOldNotifications = () => {\n    try {\n      const now = Date.now();\n      const twoDaysInMs = 48 * 60 * 60 * 1000; // 48 horas en milisegundos\n      const updatedMap = new Map<string, number>();\n\n      // Solo conservamos notificaciones de las últimas 48 horas\n      notifiedApplications.forEach((timestamp, id) => {\n        if (now - timestamp < twoDaysInMs) {\n          updatedMap.set(id, timestamp);\n        }\n      });\n\n      if (updatedMap.size !== notifiedApplications.size) {\n        console.log(`Cleaned up ${notifiedApplications.size - updatedMap.size} old notifications`);\n        setNotifiedApplications(updatedMap);\n        saveNotifiedApplications(updatedMap);\n      }\n    } catch (error) {\n      console.error('Error cleaning up old notifications:', error);\n    }\n  };\n\n  // Mark an application as notified to prevent duplicate notifications\n  const markApplicationAsNotified = (applicationId: string) => {\n    // Don't do anything if it's already marked\n    if (notifiedApplications.has(applicationId)) {\n      console.log(`Application ${applicationId} already marked as notified - skipping`);\n      return;\n    }\n    \n    const now = Date.now();\n    const updatedMap = new Map(notifiedApplications);\n    updatedMap.set(applicationId, now);\n    setNotifiedApplications(updatedMap);\n    saveNotifiedApplications(updatedMap);\n    \n    // Also update the last notification time to prevent immediate duplicates\n    lastNotificationTimeRef.current = new Date();\n    \n    console.log(`Marked application ${applicationId} as notified`);\n  };\n\n  // Verificar nuevas notificaciones en el servidor\n  const checkForNewNotifications = async () => {\n    // Record the check time immediately to prevent race conditions\n    lastCheckTimeRef.current = new Date();\n    \n    // Avoid multiple executions at the same time\n    if (checkingRef.current) {\n      console.log('Already checking for notifications');\n      return;\n    }\n    \n    // Make sure we don't have any lingering popups\n    clearPopups();\n    \n    // Sincronizar con localStorage antes de verificar para evitar duplicados\n    try {\n      const storedNotifications = localStorage.getItem('notified_application_ids');\n      if (storedNotifications) {\n        const parsedData = JSON.parse(storedNotifications);\n        if (typeof parsedData === 'object' && !Array.isArray(parsedData)) {\n          // Fusionar con las notificaciones actuales\n          const updatedMap = new Map(notifiedApplications);\n          let hasChanges = false;\n          \n          Object.entries(parsedData).forEach(([id, timestamp]) => {\n            if (!updatedMap.has(id)) {\n              updatedMap.set(id, timestamp as number);\n              hasChanges = true;\n            }\n          });\n          \n          if (hasChanges) {\n            console.log('Synchronized notification IDs from localStorage before checking');\n            setNotifiedApplications(updatedMap);\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error synchronizing notifications from localStorage:', error);\n    }\n    \n    checkingRef.current = true;\n    console.log('Checking for new notifications...');\n    \n    try {\n      // Convert notified IDs Map to array for logging\n      const notifiedIdsArray = Array.from(notifiedApplications.keys());\n      console.log(`${notifiedIdsArray.length} already notified application IDs: ${notifiedIdsArray.join(', ').substring(0, 200)}${notifiedIdsArray.length > 5 ? '...' : ''}`);\n      \n      // IMPORTANTE: Solo consultar aplicaciones de los últimos 30 segundos\n      // Esto evita notificaciones sobre aplicaciones antiguas\n      const thirtySecondsAgo = new Date();\n      thirtySecondsAgo.setSeconds(thirtySecondsAgo.getSeconds() - 30);\n      \n      const response = await fetch('http://localhost:3100/query', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          query: `\n            SELECT id, client_name, application_type, company_name, created_at, status, \n                   amount, term, interest_rate, monthly_payment\n            FROM applications \n            WHERE created_at > NOW() - INTERVAL '30 seconds'\n            ORDER BY created_at DESC\n            LIMIT 5\n          `\n        })\n      });\n      \n      if (!response.ok) {\n        throw new Error('Error querying recent applications');\n      }\n      \n      const data = await response.json();\n      \n      // If there are applications, filter them first and then show notification\n      if (data.data && data.data.length > 0) {\n        console.log(`Received ${data.data.length} applications from the last 30 seconds`);\n        \n        // Filter out any applications that have already been notified\n        const newApps = data.data.filter((app: any) => {\n          const isAlreadyNotified = notifiedApplications.has(app.id);\n          if (isAlreadyNotified) {\n            console.log(`Skipping already notified application: ${app.id}`);\n            return false;\n          }\n          \n          // Convertir el timestamp de la aplicación a Date para comparar\n          const appCreatedAt = new Date(app.created_at);\n          \n          // Si la aplicación es de hace más de 60 segundos, no notificar\n          const isTooOld = (new Date().getTime() - appCreatedAt.getTime()) > 60000;\n          if (isTooOld) {\n            console.log(`Skipping too old application: ${app.id} created at ${appCreatedAt.toISOString()}`);\n            // Marcar como notificada para evitar mostrarla en futuras verificaciones\n            markApplicationAsNotified(app.id);\n            return false;\n          }\n          \n          return true;\n        });\n        \n        console.log(`Found ${newApps.length} new applications after filtering`);\n        \n        if (newApps.length === 0) {\n          console.log('No truly new applications found (already notified or too old)');\n          checkingRef.current = false;\n          return;\n        }\n        \n        // Take only the first new application to show\n        const newApp = newApps[0];\n        const appId = newApp.id;\n        \n        // Verificar si ya está en proceso de notificación (para evitar doble notificación)\n        if (currentPopup && currentPopup.relatedItemId === appId) {\n          console.log(`Already showing notification for application ${appId} - skipping`);\n          checkingRef.current = false;\n          return;\n        }\n        \n        console.log(`New application detected: ${appId} (created ${new Date(newApp.created_at).toISOString()})`);\n        \n        // IMPORTANT: Mark as notified IMMEDIATELY to prevent duplicates\n        // even if processing fails later\n        markApplicationAsNotified(appId);\n          \n        // Format data for notification\n        const createdAt = new Date(newApp.created_at);\n        const formattedDate = new Intl.DateTimeFormat('es-MX', {\n          day: '2-digit',\n          month: '2-digit',\n          year: 'numeric'\n        }).format(createdAt);\n        \n        const formattedTime = new Intl.DateTimeFormat('es-MX', {\n          hour: '2-digit',\n          minute: '2-digit',\n          hour12: true\n        }).format(createdAt);\n        \n        // Format amount with thousands separator and 2 decimals\n        const formattedAmount = new Intl.NumberFormat('es-MX', {\n          style: 'currency',\n          currency: 'MXN',\n          minimumFractionDigits: 2\n        }).format(Number(newApp.amount || 0));\n        \n        // Format interest rate with percentage\n        const formattedRate = `${newApp.interest_rate || 0}%`;\n        \n        // Format monthly payment\n        const formattedMonthly = new Intl.NumberFormat('es-MX', {\n          style: 'currency',\n          currency: 'MXN',\n          minimumFractionDigits: 2\n        }).format(Number(newApp.monthly_payment || 0));\n        \n        // Transform application type to a more readable format\n        let appType = 'No especificado';\n        if (newApp.application_type) {\n          // Remove any trailing slash if it exists\n          const cleanType = newApp.application_type.replace(/\\/$/, '');\n          \n          if (cleanType === 'selected_plans') {\n            appType = 'Planes seleccionados';\n          } else if (cleanType === 'product_simulations') {\n            appType = 'Simulación de producto';\n          } else {\n            appType = cleanType\n              .split('_')\n              .map((word: string) => word.charAt(0).toUpperCase() + word.slice(1))\n              .join(' ');\n          }\n        }\n        \n        // Create a well-structured HTML message for the popup\n        const detailedMessage = `\n          <div class=\"grid grid-cols-2 gap-2 text-sm mt-2\">\n            <div class=\"font-semibold text-gray-700\">Cliente:</div>\n            <div class=\"text-gray-900\">${newApp.client_name || 'Sin nombre'}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Empresa:</div>\n            <div class=\"text-gray-900\">${newApp.company_name || 'No especificada'}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Tipo:</div>\n            <div class=\"text-gray-900\">${appType}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Monto:</div>\n            <div class=\"text-gray-900\">${formattedAmount}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Plazo:</div>\n            <div class=\"text-gray-900\">${newApp.term || 'N/A'} ${newApp.term === 1 ? 'mes' : 'meses'}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Tasa:</div>\n            <div class=\"text-gray-900\">${formattedRate}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Pago mensual:</div>\n            <div class=\"text-gray-900\">${formattedMonthly}</div>\n            \n            <div class=\"font-semibold text-gray-700\">Fecha:</div>\n            <div class=\"text-gray-900\">${formattedDate} ${formattedTime}</div>\n          </div>\n        `;\n        \n        const notificationTitle = '💼 Nueva solicitud recibida';\n        \n        // Create the notification for the panel\n        const newNotification = {\n          title: notificationTitle,\n          message: `Cliente: ${newApp.client_name || 'Sin nombre'} - ${newApp.company_name || 'Empresa no especificada'}`,\n          type: NotificationType.NEW_APPLICATION,\n          relatedItemType: 'application',\n          relatedItemId: appId\n        };\n        \n        // Add the notification to the panel\n        addNotification(newNotification);\n        \n        // Show popup with complete details\n        showPopup({\n          title: notificationTitle,\n          message: detailedMessage,\n          type: NotificationType.NEW_APPLICATION,\n          playSound: soundEnabled,\n          soundType: 'notification',\n          duration: 10000, // 10 seconds\n          customSound: '/sounds/clean-notification.mp3',\n          centerScreen: true,\n          relatedItemId: appId\n        });\n        \n        // Update last notification time to avoid duplicates\n        lastNotificationTimeRef.current = new Date();\n      } else {\n        console.log('No new applications found in the last 30 seconds');\n      }\n\n    } catch (error) {\n      console.error('Error checking for new notifications:', error);\n    } finally {\n      // Always mark as not running regardless of the result\n      checkingRef.current = false;\n    }\n  };\n\n  // Añadir una nueva notificación\n  const addNotification = (notification: Omit<Notification, 'id' | 'createdAt' | 'read'>) => {\n    const newNotification: Notification = {\n      ...notification,\n      // Using a proper UUID for the notification ID\n      id: generateUUID(),\n      createdAt: new Date(),\n      read: false,\n      timestamp: new Date()\n    };\n    \n    setNotifications(prev => {\n      const updated = [newNotification, ...prev];\n      // Guardar en localStorage (en producción esto iría al servidor)\n      localStorage.setItem('notifications', JSON.stringify(updated));\n      return updated;\n    });\n  };\n\n  // Marcar una notificación como leída\n  const markAsRead = (id: string) => {\n    setNotifications(prev => {\n      const updated = prev.map(notification => \n        notification.id === id \n          ? { ...notification, read: true, isRead: true } \n          : notification\n      );\n      \n      // Guardar en localStorage\n      localStorage.setItem('notifications', JSON.stringify(updated));\n      return updated;\n    });\n  };\n\n  // Marcar todas las notificaciones como leídas\n  const markAllAsRead = () => {\n    setNotifications(prev => {\n      const updated = prev.map(notification => ({ ...notification, read: true, isRead: true }));\n      \n      // Guardar en localStorage\n      localStorage.setItem('notifications', JSON.stringify(updated));\n      return updated;\n    });\n  };\n\n  // Limpiar todas las notificaciones\n  const clearNotifications = () => {\n    setNotifications([]);\n    // Limpiar del localStorage\n    localStorage.setItem('notifications', JSON.stringify([]));\n  };\n\n  // Mostrar una notificación emergente\n  const showPopup = (config: NotificationPopupConfig) => {\n    // Verificar si ya hay un popup con el mismo título y mensaje (posible duplicado)\n    if (currentPopup && \n        currentPopup.title === config.title && \n        currentPopup.message === config.message) {\n      console.log('Ignoring duplicate popup with the same content');\n      return;\n    }\n\n    // Clear any existing popups to prevent stacking\n    clearPopups();\n    \n    // Log what we're showing\n    console.log(`Showing popup: ${config.title}`);\n    \n    // Short timeout to ensure DOM updates before showing the new popup\n    setTimeout(() => {\n      setCurrentPopup(config);\n      \n      // Automatically close popup after the specified duration\n      setTimeout(() => {\n        setCurrentPopup(null);\n      }, config.duration || 5000);\n    }, 50);\n  };\n\n  // Clear any pending popups\n  const clearPopups = () => {\n    if (currentPopup) {\n      console.log('Clearing existing popup');\n      setCurrentPopup(null);\n    }\n  };\n\n  // Activar/desactivar sonidos de notificación\n  const toggleSound = () => {\n    const newValue = !soundEnabled;\n    setSoundEnabled(newValue);\n    // Guardar preferencia en localStorage\n    localStorage.setItem('notification_sound_enabled', newValue.toString());\n  };\n\n  const value = {\n    notifications,\n    unreadCount,\n    addNotification,\n    markAsRead,\n    markAllAsRead,\n    clearNotifications,\n    showPopup,\n    soundEnabled,\n    toggleSound,\n    setSoundEnabled\n  };\n\n  return (\n    <NotificationContext.Provider value={value}>\n      {children}\n      {currentPopup && (\n        <NotificationPopup\n          title={currentPopup.title}\n          message={currentPopup.message}\n          type={currentPopup.type as any}\n          duration={currentPopup.duration}\n          playSound={currentPopup.playSound}\n          soundType={currentPopup.soundType}\n          customSound={currentPopup.customSound}\n          onClose={() => setCurrentPopup(null)}\n          centerScreen={currentPopup.centerScreen}\n        />\n      )}\n    </NotificationContext.Provider>\n  );\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}