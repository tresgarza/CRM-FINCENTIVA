{"ast":null,"code":"import { executeQuery } from '../utils/databaseUtils';\nimport { TABLES } from '../utils/constants/tables';\n// Nombre de la tabla definido como constante para evitar errores de escritura\nconst CLIENTS_TABLE = TABLES.CLIENTS || 'clients';\n\n// Get all clients with filters\nexport const getClients = async filters => {\n  try {\n    // Construir la consulta base\n    let query = `SELECT * FROM ${CLIENTS_TABLE} WHERE 1=1`;\n\n    // Aplicar filtros si existen\n    if (filters) {\n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        query += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n\n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n\n      // Filtro por empresa\n      if (filters.company_id) {\n        query += ` AND company_id = '${filters.company_id}'`;\n      }\n\n      // Filtro por fecha\n      if (filters.dateFrom) {\n        query += ` AND created_at >= '${filters.dateFrom}'`;\n      }\n      if (filters.dateTo) {\n        query += ` AND created_at <= '${filters.dateTo}'`;\n      }\n    }\n\n    // Agregar ordenamiento\n    query += ` ORDER BY created_at DESC`;\n\n    // Agregar paginación si se especifica\n    if ((filters === null || filters === void 0 ? void 0 : filters.page) !== undefined && filters !== null && filters !== void 0 && filters.pageSize) {\n      const offset = (filters.page - 1) * filters.pageSize;\n      query += ` LIMIT ${filters.pageSize} OFFSET ${offset}`;\n    }\n\n    // Ejecutar la consulta\n    const data = await executeQuery(query);\n    return data || [];\n  } catch (error) {\n    console.error('Error al obtener clientes:', error);\n    // Si la tabla no existe o hay otro error, devolver un array vacío\n    return [];\n  }\n};\n\n// Get a single client by ID\nexport const getClientById = async id => {\n  try {\n    // Verificar si la tabla existe\n    const exists = await tableExists();\n    if (!exists) {\n      console.warn('La tabla clients no existe. Retornando cliente vacío.');\n      return null;\n    }\n    const {\n      data,\n      error\n    } = await supabase.from(CLIENTS_TABLE).select('*').eq('id', id).single();\n    if (error) {\n      var _error$message;\n      // Check if the error is because the table doesn't exist\n      if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Returning empty client.');\n        return null;\n      }\n      console.error(`Error fetching client with ID ${id}:`, error);\n      throw error;\n    }\n    return data;\n  } catch (error) {\n    var _error$message2, _error$message3;\n    // Verificar si el error es porque la tabla no existe\n    if (error instanceof Error && ((_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('does not exist') || (_error$message3 = error.message) !== null && _error$message3 !== void 0 && _error$message3.includes('42P01'))) {\n      console.warn('La tabla clients no existe. Retornando cliente vacío.');\n      return null;\n    }\n    console.error(`Error in getClientById:`, error);\n    throw error;\n  }\n};\n\n// Función para escapar cadenas de texto para SQL\nfunction escapeSQLString(str) {\n  if (!str) return '';\n  return str.replace(/'/g, \"''\");\n}\n\n// Get client applications\nexport const getClientApplications = async clientId => {\n  // Consultar aplicaciones usando MCP en lugar de Supabase\n  try {\n    // Primero obtenemos el cliente para saber su nombre\n    const client = await getClientById(clientId).catch(err => {\n      // If clients table doesn't exist, use a workaround\n      if (err.message === 'Clients table does not exist') {\n        return null;\n      }\n      throw err;\n    });\n    if (!client) {\n      console.warn('Client not found or clients table does not exist. Returning empty applications list.');\n      return [];\n    }\n\n    // Luego usamos el nombre del cliente para buscar aplicaciones\n    const query = `\n      SELECT * FROM ${TABLES.APPLICATIONS}\n      WHERE client_name = '${escapeSQLString(client.name)}'\n      ORDER BY created_at DESC\n    `;\n\n    // Usamos executeQuery que es el método para el MCP\n    const executeQuery = async query => {\n      try {\n        const response = await fetch('http://localhost:3100/query', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            query\n          })\n        });\n        const result = await response.json();\n        if (result.error) {\n          console.error('Error en la consulta SQL:', result.error);\n          throw new Error(result.error);\n        }\n        return result.data;\n      } catch (error) {\n        console.error('Error ejecutando la consulta:', error);\n        throw error;\n      }\n    };\n    const data = await executeQuery(query);\n    return data;\n  } catch (error) {\n    console.error(`Error fetching applications for client ${clientId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new client\nexport const createClient = async client => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from(CLIENTS_TABLE).insert([client]).select();\n    if (error) {\n      var _error$message4;\n      // Check if the error is because the table doesn't exist\n      if ((_error$message4 = error.message) !== null && _error$message4 !== void 0 && _error$message4.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Cannot create client.');\n        throw new Error('Clients table does not exist');\n      }\n      console.error('Error creating client:', error);\n      throw error;\n    }\n    return data[0];\n  } catch (error) {\n    console.error('Error in createClient:', error);\n    throw error;\n  }\n};\n\n// Update an existing client\nexport const updateClient = async (id, updates) => {\n  try {\n    const {\n      data,\n      error\n    } = await supabase.from(CLIENTS_TABLE).update(updates).eq('id', id).select();\n    if (error) {\n      var _error$message5;\n      // Check if the error is because the table doesn't exist\n      if ((_error$message5 = error.message) !== null && _error$message5 !== void 0 && _error$message5.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Cannot update client.');\n        throw new Error('Clients table does not exist');\n      }\n      console.error(`Error updating client with ID ${id}:`, error);\n      throw error;\n    }\n    return data[0];\n  } catch (error) {\n    console.error(`Error in updateClient:`, error);\n    throw error;\n  }\n};\n\n// Delete a client\nexport const deleteClient = async id => {\n  try {\n    const {\n      error\n    } = await supabase.from(CLIENTS_TABLE).delete().eq('id', id);\n    if (error) {\n      var _error$message6;\n      // Check if the error is because the table doesn't exist\n      if ((_error$message6 = error.message) !== null && _error$message6 !== void 0 && _error$message6.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Cannot delete client.');\n        throw new Error('Clients table does not exist');\n      }\n      console.error(`Error deleting client with ID ${id}:`, error);\n      throw error;\n    }\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteClient:`, error);\n    throw error;\n  }\n};\n\n// Check if a client exists with the given email or RFC\nexport const checkClientExists = async (email, rfc) => {\n  try {\n    let query = supabase.from(CLIENTS_TABLE).select('id, email, rfc').eq('email', email);\n    if (rfc) {\n      query = query.or(`rfc.eq.${rfc}`);\n    }\n    const {\n      data,\n      error\n    } = await query;\n    if (error) {\n      var _error$message7;\n      // Check if the error is because the table doesn't exist\n      if ((_error$message7 = error.message) !== null && _error$message7 !== void 0 && _error$message7.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Returning null.');\n        return null;\n      }\n      console.error('Error checking client existence:', error);\n      throw error;\n    }\n    return data.length > 0 ? data[0] : null;\n  } catch (error) {\n    console.error('Error in checkClientExists:', error);\n    throw error;\n  }\n};\n\n// Get client count by filters\nexport const getClientCount = async filters => {\n  try {\n    let query = supabase.from(CLIENTS_TABLE).select('id', {\n      count: 'exact',\n      head: true\n    });\n\n    // Apply filters\n    if (filters) {\n      // Filter by advisor\n      if (filters.advisor_id) {\n        query = query.eq('advisor_id', filters.advisor_id);\n      }\n\n      // Filter by company\n      if (filters.company_id) {\n        query = query.eq('company_id', filters.company_id);\n      }\n\n      // Filter by date range\n      if (filters.dateFrom) {\n        query = query.gte('created_at', filters.dateFrom);\n      }\n      if (filters.dateTo) {\n        query = query.lte('created_at', filters.dateTo);\n      }\n\n      // Search by name, email or phone\n      if (filters.searchQuery) {\n        query = query.or(`name.ilike.%${filters.searchQuery}%,email.ilike.%${filters.searchQuery}%,phone.ilike.%${filters.searchQuery}%,rfc.ilike.%${filters.searchQuery}%,curp.ilike.%${filters.searchQuery}%`);\n      }\n    }\n    const {\n      count,\n      error\n    } = await query;\n    if (error) {\n      var _error$message8;\n      // Check if the error is because the table doesn't exist\n      if ((_error$message8 = error.message) !== null && _error$message8 !== void 0 && _error$message8.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Returning count 0.');\n        return 0;\n      }\n      console.error('Error getting client count:', error);\n      throw error;\n    }\n    return count || 0;\n  } catch (error) {\n    console.error('Error in getClientCount:', error);\n    return 0;\n  }\n};","map":{"version":3,"names":["executeQuery","TABLES","CLIENTS_TABLE","CLIENTS","getClients","filters","query","searchQuery","advisor_id","company_id","dateFrom","dateTo","page","undefined","pageSize","offset","data","error","console","getClientById","id","exists","tableExists","warn","supabase","from","select","eq","single","_error$message","message","includes","code","_error$message2","_error$message3","Error","escapeSQLString","str","replace","getClientApplications","clientId","client","catch","err","APPLICATIONS","name","response","fetch","method","headers","body","JSON","stringify","result","json","createClient","insert","_error$message4","updateClient","updates","update","_error$message5","deleteClient","delete","_error$message6","checkClientExists","email","rfc","or","_error$message7","length","getClientCount","count","head","gte","lte","_error$message8"],"sources":["/Users/diegogg98/NEW CRM MAR18/src/services/clientService.ts"],"sourcesContent":["import { executeQuery } from '../utils/databaseUtils';\nimport { TABLES } from '../utils/constants/tables';\n\nexport interface Client {\n  id: string;\n  created_at: string;\n  name: string;\n  email: string;\n  phone: string;\n  address?: string;\n  city?: string;\n  state?: string;\n  postal_code?: string;\n  birth_date?: string;\n  rfc?: string;\n  curp?: string;\n  company_id?: string;\n  advisor_id?: string;\n}\n\nexport interface ClientFilter {\n  searchQuery?: string;\n  advisor_id?: string;\n  company_id?: string;\n  dateFrom?: string;\n  dateTo?: string;\n  page?: number;\n  pageSize?: number;\n}\n\n// Nombre de la tabla definido como constante para evitar errores de escritura\nconst CLIENTS_TABLE = TABLES.CLIENTS || 'clients';\n\n// Get all clients with filters\nexport const getClients = async (filters?: ClientFilter) => {\n  try {\n    // Construir la consulta base\n    let query = `SELECT * FROM ${CLIENTS_TABLE} WHERE 1=1`;\n\n    // Aplicar filtros si existen\n    if (filters) {\n      // Filtro por búsqueda\n      if (filters.searchQuery) {\n        query += ` AND (\n          name ILIKE '%${filters.searchQuery}%' OR\n          email ILIKE '%${filters.searchQuery}%' OR\n          phone ILIKE '%${filters.searchQuery}%' OR\n          rfc ILIKE '%${filters.searchQuery}%'\n        )`;\n      }\n\n      // Filtro por asesor\n      if (filters.advisor_id) {\n        query += ` AND advisor_id = '${filters.advisor_id}'`;\n      }\n\n      // Filtro por empresa\n      if (filters.company_id) {\n        query += ` AND company_id = '${filters.company_id}'`;\n      }\n\n      // Filtro por fecha\n      if (filters.dateFrom) {\n        query += ` AND created_at >= '${filters.dateFrom}'`;\n      }\n      if (filters.dateTo) {\n        query += ` AND created_at <= '${filters.dateTo}'`;\n      }\n    }\n\n    // Agregar ordenamiento\n    query += ` ORDER BY created_at DESC`;\n\n    // Agregar paginación si se especifica\n    if (filters?.page !== undefined && filters?.pageSize) {\n      const offset = (filters.page - 1) * filters.pageSize;\n      query += ` LIMIT ${filters.pageSize} OFFSET ${offset}`;\n    }\n\n    // Ejecutar la consulta\n    const data = await executeQuery(query);\n    return data || [];\n  } catch (error) {\n    console.error('Error al obtener clientes:', error);\n    // Si la tabla no existe o hay otro error, devolver un array vacío\n    return [];\n  }\n};\n\n// Get a single client by ID\nexport const getClientById = async (id: string) => {\n  try {\n    // Verificar si la tabla existe\n    const exists = await tableExists();\n    if (!exists) {\n      console.warn('La tabla clients no existe. Retornando cliente vacío.');\n      return null;\n    }\n\n    const { data, error } = await supabase\n      .from(CLIENTS_TABLE)\n      .select('*')\n      .eq('id', id)\n      .single();\n\n    if (error) {\n      // Check if the error is because the table doesn't exist\n      if (error.message?.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Returning empty client.');\n        return null;\n      }\n      \n      console.error(`Error fetching client with ID ${id}:`, error);\n      throw error;\n    }\n\n    return data as Client;\n  } catch (error) {\n    // Verificar si el error es porque la tabla no existe\n    if (error instanceof Error && (\n        error.message?.includes('does not exist') || \n        error.message?.includes('42P01'))) {\n      console.warn('La tabla clients no existe. Retornando cliente vacío.');\n      return null;\n    }\n    \n    console.error(`Error in getClientById:`, error);\n    throw error;\n  }\n};\n\n// Función para escapar cadenas de texto para SQL\nfunction escapeSQLString(str: string) {\n  if (!str) return '';\n  return str.replace(/'/g, \"''\");\n}\n\n// Get client applications\nexport const getClientApplications = async (clientId: string) => {\n  // Consultar aplicaciones usando MCP en lugar de Supabase\n  try {\n    // Primero obtenemos el cliente para saber su nombre\n    const client = await getClientById(clientId).catch(err => {\n      // If clients table doesn't exist, use a workaround\n      if (err.message === 'Clients table does not exist') {\n        return null;\n      }\n      throw err;\n    });\n    \n    if (!client) {\n      console.warn('Client not found or clients table does not exist. Returning empty applications list.');\n      return [];\n    }\n    \n    // Luego usamos el nombre del cliente para buscar aplicaciones\n    const query = `\n      SELECT * FROM ${TABLES.APPLICATIONS}\n      WHERE client_name = '${escapeSQLString(client.name)}'\n      ORDER BY created_at DESC\n    `;\n    \n    // Usamos executeQuery que es el método para el MCP\n    const executeQuery = async (query: string) => {\n      try {\n        const response = await fetch('http://localhost:3100/query', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({ query }),\n        });\n        \n        const result = await response.json();\n        \n        if (result.error) {\n          console.error('Error en la consulta SQL:', result.error);\n          throw new Error(result.error);\n        }\n        \n        return result.data;\n      } catch (error) {\n        console.error('Error ejecutando la consulta:', error);\n        throw error;\n      }\n    };\n    \n    const data = await executeQuery(query);\n    return data;\n  } catch (error) {\n    console.error(`Error fetching applications for client ${clientId}:`, error);\n    throw error;\n  }\n};\n\n// Create a new client\nexport const createClient = async (client: Omit<Client, 'id' | 'created_at'>) => {\n  try {\n    const { data, error } = await supabase\n      .from(CLIENTS_TABLE)\n      .insert([client])\n      .select();\n\n    if (error) {\n      // Check if the error is because the table doesn't exist\n      if (error.message?.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Cannot create client.');\n        throw new Error('Clients table does not exist');\n      }\n      \n      console.error('Error creating client:', error);\n      throw error;\n    }\n\n    return data[0] as Client;\n  } catch (error) {\n    console.error('Error in createClient:', error);\n    throw error;\n  }\n};\n\n// Update an existing client\nexport const updateClient = async (id: string, updates: Partial<Client>) => {\n  try {\n    const { data, error } = await supabase\n      .from(CLIENTS_TABLE)\n      .update(updates)\n      .eq('id', id)\n      .select();\n\n    if (error) {\n      // Check if the error is because the table doesn't exist\n      if (error.message?.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Cannot update client.');\n        throw new Error('Clients table does not exist');\n      }\n      \n      console.error(`Error updating client with ID ${id}:`, error);\n      throw error;\n    }\n\n    return data[0] as Client;\n  } catch (error) {\n    console.error(`Error in updateClient:`, error);\n    throw error;\n  }\n};\n\n// Delete a client\nexport const deleteClient = async (id: string) => {\n  try {\n    const { error } = await supabase\n      .from(CLIENTS_TABLE)\n      .delete()\n      .eq('id', id);\n\n    if (error) {\n      // Check if the error is because the table doesn't exist\n      if (error.message?.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Cannot delete client.');\n        throw new Error('Clients table does not exist');\n      }\n      \n      console.error(`Error deleting client with ID ${id}:`, error);\n      throw error;\n    }\n\n    return true;\n  } catch (error) {\n    console.error(`Error in deleteClient:`, error);\n    throw error;\n  }\n};\n\n// Check if a client exists with the given email or RFC\nexport const checkClientExists = async (email: string, rfc?: string) => {\n  try {\n    let query = supabase\n      .from(CLIENTS_TABLE)\n      .select('id, email, rfc')\n      .eq('email', email);\n\n    if (rfc) {\n      query = query.or(`rfc.eq.${rfc}`);\n    }\n\n    const { data, error } = await query;\n\n    if (error) {\n      // Check if the error is because the table doesn't exist\n      if (error.message?.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Returning null.');\n        return null;\n      }\n      \n      console.error('Error checking client existence:', error);\n      throw error;\n    }\n\n    return data.length > 0 ? data[0] : null;\n  } catch (error) {\n    console.error('Error in checkClientExists:', error);\n    throw error;\n  }\n};\n\n// Get client count by filters\nexport const getClientCount = async (filters?: ClientFilter) => {\n  try {\n    let query = supabase\n      .from(CLIENTS_TABLE)\n      .select('id', { count: 'exact', head: true });\n\n    // Apply filters\n    if (filters) {\n      // Filter by advisor\n      if (filters.advisor_id) {\n        query = query.eq('advisor_id', filters.advisor_id);\n      }\n\n      // Filter by company\n      if (filters.company_id) {\n        query = query.eq('company_id', filters.company_id);\n      }\n\n      // Filter by date range\n      if (filters.dateFrom) {\n        query = query.gte('created_at', filters.dateFrom);\n      }\n\n      if (filters.dateTo) {\n        query = query.lte('created_at', filters.dateTo);\n      }\n\n      // Search by name, email or phone\n      if (filters.searchQuery) {\n        query = query.or(\n          `name.ilike.%${filters.searchQuery}%,email.ilike.%${filters.searchQuery}%,phone.ilike.%${filters.searchQuery}%,rfc.ilike.%${filters.searchQuery}%,curp.ilike.%${filters.searchQuery}%`\n        );\n      }\n    }\n\n    const { count, error } = await query;\n\n    if (error) {\n      // Check if the error is because the table doesn't exist\n      if (error.message?.includes('does not exist') || error.code === '42P01') {\n        console.warn('Clients table does not exist. Returning count 0.');\n        return 0;\n      }\n      \n      console.error('Error getting client count:', error);\n      throw error;\n    }\n\n    return count || 0;\n  } catch (error) {\n    console.error('Error in getClientCount:', error);\n    return 0;\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}